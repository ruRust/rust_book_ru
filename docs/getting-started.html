<!DOCTYPE HTML>
<html lang="ru" class="no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Outdated link: C чего начать - Язык программирования Rust</title>
        <meta name="robots" content="noindex,follow">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="theme/first-edition.css">
        
    </head>
    <body class="light">
        <div id="page-wrapper" class="page-wrapper">
            <div class="page">
                <div id="draft-warning" class="warning">
    <span class="message">Вы читаете <strong>устаревшую</strong> версию TRPL. Новая версия <a href="https://doc.rust-lang.ru/book">здесь</a>.</span>
    <button type="button" id="hide-draft-warning" title="Hide draft warning" class="button">
        <i class="fa fa-times"></i>
    </button>
</div>
<!-- Hide / unhide warning before it is displayed -->
<script type="text/javascript">
var warning = localStorage.getItem('trpl-first-edition-draft-warning');

if (warning === 'hidden') {
    Array
    .from(document.querySelectorAll('#page-wrapper'))
    .forEach(function(block) { block.classList.remove('has-warning'); });
    var elem = document.getElementById("draft-warning");
    elem.parentNode.removeChild(elem);
}

document.addEventListener("DOMContentLoaded", function(event) {
    document.getElementById("hide-draft-warning").addEventListener("click", function(e) {
        var elem = document.getElementById("draft-warning");
        elem.parentNode.removeChild(elem);

        localStorage.setItem('trpl-first-edition-draft-warning', 'hidden');
    });
});
</script>

                <div id="content" class="content">
                    <main>
                        <p>% C чего начать</p>
<p>Первый раздел книги рассказывает о том, как начать работать с Rust и его
инструментами. Сначала мы установим Rust, затем напишем классическую программу
«Привет, мир!» и, наконец, поговорим о Cargo, который представляет собой
систему сборки и менеджер пакетов в Rust.</p>
<h1><a class="header" href="#Установка-rust" id="Установка-rust">Установка Rust</a></h1>
<p>Первым шагом к использованию Rust является его установка. В этой главе нам
понадобится интернет-соединение для выполнения команд, с помощью которых мы
загрузим Rust из Интернета.</p>
<p>Мы воспользуемся несколькими командами в терминале, и они все будут начинаться
с <code>$</code>. Вам не нужно вводить <code>$</code>: этот символ используется только для того, чтобы
обозначить начало каждой команды. В Интернете можно увидеть множество руководств
и примеров, которые следуют этому правилу: <code>$</code> обозначает команды, которые
выполняются с правами обычного пользователя, и <code>#</code> — команды, которые
выполняются с правами администратора.</p>
<h2><a class="header" href="#Поддерживаемые-платформы" id="Поддерживаемые-платформы">Поддерживаемые платформы</a></h2>
<p>Перечень платформ, на которых работает и для которых компилирует компилятор
Rust, довольно большой, однако не все платформы поддерживаются одинаково.
Существует три уровня поддержки Rust, каждый из которых предоставляет свой
набор гарантий.</p>
<p>Платформы идентифицируются по их «целевой тройке», которая является строкой,
сообщающей компилятору, какие выходные данные должны быть произведены. Столбцы
ниже указывают, работает ли соответствующий компонент на указанной платформе.</p>
<h3><a class="header" href="#Первый-уровень" id="Первый-уровень">Первый уровень</a></h3>
<p>Первый уровень платформ может восприниматься как «гарантированно собирается и
работает». В частности, каждая из них удовлетворяет следующим требованиям:</p>
<ul>
<li>Автоматические тесты обеспечивают тестирование этих платформ.</li>
<li>Изменения, принятые в ветку master репозитория <code>rust-lang/rust</code>, прошли
тестирование.</li>
<li>Для этих платформ предоставляются официальные пакеты.</li>
<li>Доступна документация о том, как собрать и использовать платформу.</li>
</ul>
<table><thead><tr><th>Target</th><th>std</th><th>rustc</th><th>cargo</th><th>notes</th></tr></thead><tbody>
<tr><td><code>x86_64-pc-windows-msvc</code></td><td>✓</td><td>✓</td><td>✓</td><td>64-bit MSVC (Windows 7+)</td></tr>
<tr><td><code>i686-pc-windows-gnu</code></td><td>✓</td><td>✓</td><td>✓</td><td>32-bit MinGW (Windows 7+)</td></tr>
<tr><td><code>x86_64-pc-windows-gnu</code></td><td>✓</td><td>✓</td><td>✓</td><td>64-bit MinGW (Windows 7+)</td></tr>
<tr><td><code>i686-apple-darwin</code></td><td>✓</td><td>✓</td><td>✓</td><td>32-bit OSX (10.7+, Lion+)</td></tr>
<tr><td><code>x86_64-apple-darwin</code></td><td>✓</td><td>✓</td><td>✓</td><td>64-bit OSX (10.7+, Lion+)</td></tr>
<tr><td><code>i686-unknown-linux-gnu</code></td><td>✓</td><td>✓</td><td>✓</td><td>32-bit Linux (2.6.18+)</td></tr>
<tr><td><code>x86_64-unknown-linux-gnu</code></td><td>✓</td><td>✓</td><td>✓</td><td>64-bit Linux (2.6.18+)</td></tr>
</tbody></table>
<h3><a class="header" href="#Второй-уровень" id="Второй-уровень">Второй уровень</a></h3>
<p>Второй уровень платформ может восприниматься как «гарантированно собирается».
Автоматические тесты не поддерживаются, и в связи с этим работоспособность
сборки не гарантируется. Но эти платформы обычно работают довольно хорошо,
и предложения по улучшению всегда приветствуются! В частности, эти платформы
удовлетворяют следующим требованиям:</p>
<ul>
<li>Настроена автоматическая сборка, но тестирования не происходит.</li>
<li>Изменения, принятые в ветку master репозитория <code>rust-lang/rust</code>, собираются
для этих платформ. Имейте в виду, что для некоторых платформ собирается
только стандартная библиотека, но для остальных настроена полная раскрутка
компилятора (bootstraping).</li>
<li>Для этих платформ предоставляются официальные пакеты.</li>
</ul>
<table><thead><tr><th>Target</th><th>std</th><th>rustc</th><th>cargo</th><th>notes</th></tr></thead><tbody>
<tr><td><code>i686-pc-windows-msvc</code></td><td>✓</td><td>✓</td><td>✓</td><td>32-bit MSVC (Windows 7+)</td></tr>
</tbody></table>
<h3><a class="header" href="#Третий-уровень" id="Третий-уровень">Третий уровень</a></h3>
<p>Третий уровень платформ — это те, которые Rust поддерживает, но для которых
принятые изменения автоматически не собираются и не тестируются. Для данных
платформ работоспособность сборки определятся степенью содействия сообщества.
К тому же официальные пакеты и установщики не предоставляются, но они могут
быть предоставлены сообществом.</p>
<table><thead><tr><th>Target</th><th>std</th><th>rustc</th><th>cargo</th><th>notes</th></tr></thead><tbody>
<tr><td><code>x86_64-unknown-linux-musl</code></td><td>✓</td><td></td><td></td><td>64-bit Linux with MUSL</td></tr>
<tr><td><code>arm-linux-androideabi</code></td><td>✓</td><td></td><td></td><td>ARM Android</td></tr>
<tr><td><code>i686-linux-android</code></td><td>✓</td><td></td><td></td><td>32-bit x86 Android</td></tr>
<tr><td><code>aarch64-linux-android</code></td><td>✓</td><td></td><td></td><td>ARM64 Android</td></tr>
<tr><td><code>arm-unknown-linux-gnueabi</code></td><td>✓</td><td>✓</td><td></td><td>ARM Linux (2.6.18+)</td></tr>
<tr><td><code>arm-unknown-linux-gnueabihf</code></td><td>✓</td><td>✓</td><td></td><td>ARM Linux (2.6.18+)</td></tr>
<tr><td><code>aarch64-unknown-linux-gnu</code></td><td>✓</td><td></td><td></td><td>ARM64 Linux (2.6.18+)</td></tr>
<tr><td><code>mips-unknown-linux-gnu</code></td><td>✓</td><td></td><td></td><td>MIPS Linux (2.6.18+)</td></tr>
<tr><td><code>mipsel-unknown-linux-gnu</code></td><td>✓</td><td></td><td></td><td>MIPS (LE) Linux (2.6.18+)</td></tr>
<tr><td><code>powerpc-unknown-linux-gnu</code></td><td>✓</td><td></td><td></td><td>PowerPC Linux (2.6.18+)</td></tr>
<tr><td><code>i386-apple-ios</code></td><td>✓</td><td></td><td></td><td>32-bit x86 iOS</td></tr>
<tr><td><code>x86_64-apple-ios</code></td><td>✓</td><td></td><td></td><td>64-bit x86 iOS</td></tr>
<tr><td><code>armv7-apple-ios</code></td><td>✓</td><td></td><td></td><td>ARM iOS</td></tr>
<tr><td><code>armv7s-apple-ios</code></td><td>✓</td><td></td><td></td><td>ARM iOS</td></tr>
<tr><td><code>aarch64-apple-ios</code></td><td>✓</td><td></td><td></td><td>ARM64 iOS</td></tr>
<tr><td><code>i686-unknown-freebsd</code></td><td>✓</td><td>✓</td><td></td><td>32-bit FreeBSD</td></tr>
<tr><td><code>x86_64-unknown-freebsd</code></td><td>✓</td><td>✓</td><td></td><td>64-bit FreeBSD</td></tr>
<tr><td><code>x86_64-unknown-openbsd</code></td><td>✓</td><td>✓</td><td></td><td>64-bit OpenBSD</td></tr>
<tr><td><code>x86_64-unknown-netbsd</code></td><td>✓</td><td>✓</td><td></td><td>64-bit NetBSD</td></tr>
<tr><td><code>x86_64-unknown-bitrig</code></td><td>✓</td><td>✓</td><td></td><td>64-bit Bitrig</td></tr>
<tr><td><code>x86_64-unknown-dragonfly</code></td><td>✓</td><td>✓</td><td></td><td>64-bit DragonFlyBSD</td></tr>
<tr><td><code>x86_64-rumprun-netbsd</code></td><td>✓</td><td></td><td></td><td>64-bit NetBSD Rump Kernel</td></tr>
<tr><td><code>i686-pc-windows-msvc</code> (XP)</td><td>✓</td><td></td><td></td><td>Windows XP support</td></tr>
<tr><td><code>x86_64-pc-windows-msvc</code> (XP)</td><td>✓</td><td></td><td></td><td>Windows XP support</td></tr>
</tbody></table>
<p>Имейте в виду, что данная таблица со временем может быть дополнена: это не
исчерпывающий набор платформ третьего уровня!</p>
<h2><a class="header" href="#Установка-на-linux-или-mac" id="Установка-на-linux-или-mac">Установка на Linux или Mac</a></h2>
<p>Если вы используете Linux или Mac, то всё, что вам нужно сделать, — это ввести
следующую команду в консоль:</p>
<pre><code class="language-bash">$ curl -sSf https://static.rust-lang.org/rustup.sh | sh
</code></pre>
<p>Эта команда загрузит скрипт и начнёт установку. Если всё пройдёт успешно, то вы
увидите следующий текст:</p>
<pre><code class="language-text">Welcome to Rust.

This script will download the Rust compiler and its package manager, Cargo, and
install them to /usr/local. You may install elsewhere by running this script
with the --prefix=&lt;path&gt; option.

The installer will run under ‘sudo’ and may ask you for your password. If you do
not want the script to run ‘sudo’ then pass it the --disable-sudo flag.

You may uninstall later by running /usr/local/lib/rustlib/uninstall.sh,
or by running this script again with the --uninstall flag.

Continue? (y/N)
</code></pre>
<p>Нажмите <code>y</code> для подтверждения и следуйте дальнейшим подсказкам.</p>
<h2><a class="header" href="#Установка-на-windows" id="Установка-на-windows">Установка на Windows</a></h2>
<p>Если вы используете Windows, то скачайте подходящий <a href="https://www.rust-lang.org/install.html">установщик</a>.</p>
<h2><a class="header" href="#Удаление" id="Удаление">Удаление</a></h2>
<p>Удалить Rust так же просто, как и установить его. На Linux или Mac нужно просто
запустить скрипт удаления:</p>
<pre><code class="language-bash">$ sudo /usr/local/lib/rustlib/uninstall.sh
</code></pre>
<p>Если вы использовали установщик Windows, то просто повторно запустите <code>.msi</code>,
который предложит вам возможность удаления.</p>
<h2><a class="header" href="#Решение-проблем" id="Решение-проблем">Решение проблем</a></h2>
<p>Если у вас установлен Rust, то можно открыть терминал и ввести:</p>
<pre><code class="language-bash">$ rustc --version
</code></pre>
<p>Вы должны увидеть версию, хеш коммита и дату коммита.</p>
<p>Если это так, то теперь у вас есть установленный Rust! Поздравляем!</p>
<p>Если нет и вы пользователь Windows, то убедитесь в том, что Rust прописан в
вашей системной переменной %PATH%. Если это не так, то запустите установщик
снова, выберите &quot;Change&quot; на странице &quot;Change, repair, or remove installation&quot; и
убедитесь, что &quot;Add to PATH&quot; указывает на локальный жёсткий диск.</p>
<p>Существует несколько мест, где вы можете получить помощь. Самый простой
вариант — <a href="irc://irc.mozilla.org/#rust">канал #rust на irc.mozilla.org</a>, к которому вы можете
подключиться через <a href="http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Mibbit</a>. Нажмите на эту ссылку, и вы будете общаться
в чате с другими Rustaceans (это дурашливое прозвище, которым мы себя называем),
и мы поможем вам. Другие полезные ресурсы, посвящённые Rust: <a href="https://users.rust-lang.org/">форум
пользователей</a> и <a href="http://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.
Русскоязычные ресурсы: <a href="http://rustycrate.ru">сайт сообщества</a>, <a href="http://forum.rustycrate.ru">форум</a>,
<a href="http://ru.stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.</p>
<p>Установщик также устанавливает документацию, которая доступна без подключения к
сети. На UNIX системах она располагается в директории
<code>/usr/local/share/doc/rust</code>. В Windows используется директория <code>share/doc</code>,
относительно того, куда вы установили Rust.</p>
<h1><a class="header" href="#Привет-мир" id="Привет-мир">Привет, мир!</a></h1>
<p>Теперь, когда вы установили Rust, давайте напишем первую программу на Rust.
Традиционно при изучении нового языка программирования первая написанная
программа просто выводит на экран «Привет, мир!», и мы следуем этой традиции.</p>
<p>Хорошо начинать с такой простой программы, поскольку можно убедиться, что ваш
компилятор не только установлен, но и работает правильно. Вывод информации на
экран будет замечательным способом проверить это.</p>
<blockquote>
<p>На самом деле это приводит к ещё одной проблеме, о которой мы должны
предупредить: данное руководство предполагает, что у вас есть базовые навыки
работы с командной строкой. Rust не выдвигает специфических требований к вашей
среде разработки или тому, как вы храните свой код. Если вы предпочитаете
использовать IDE, посмотрите на проект <a href="https://github.com/oakes/SolidOak">SolidOak</a>, или на плагины к
вашей любимой IDE. Есть множество расширений, разрабатываемых сообществом, а
также <a href="https://github.com/rust-lang/rust/blob/master/src/etc/CONFIGS.md">плагинов для разных редакторов</a>, поддерживаемых командой Rust.
Настройка вашего редактора или IDE выходит за пределы данного руководства.
Посмотрите руководство по использованию выбранного вами плагина.</p>
</blockquote>
<h2><a class="header" href="#Создание-проекта" id="Создание-проекта">Создание проекта</a></h2>
<p>Первое, с чего мы должны начать, — создание файла для нашего кода. Для Rust не
имеет значения, где находится ваш код, но в рамках этого руководства мы
рекомендуем создать директорию <em>projects</em> в вашей домашней директории и хранить
там все ваши проекты. Откройте терминал и введите следующие команды, чтобы
создать директорию для этого проекта:</p>
<pre><code class="language-bash">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<blockquote>
<p>Если вы используете Windows и не используете PowerShell, ~ может не работать.
Обратитесь к документации вашей оболочки для уточнения деталей.</p>
</blockquote>
<h2><a class="header" href="#Написание-и-запуск-программы-на-rust" id="Написание-и-запуск-программы-на-rust">Написание и запуск программы на Rust</a></h2>
<p>Теперь создадим новый файл для кода программы. Назовём наш файл <em>main.rs</em>.
Файлы с исходным кодом на Rust всегда имеют расширение <em>.rs</em>. Если вы
хотите использовать в имени вашего файла больше одного слова, разделяйте их
подчёркиванием; например <em>hello_world.rs</em>, а не <em>helloworld.rs</em>.</p>
<p>Теперь откройте только что созданный файл <em>main.rs</em> и добавьте в него следующий
код:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Привет, мир!&quot;);
}
</code></pre></pre>
<p>Сохраните файл и вернитесь к вашему окну терминала. На Linux или OSX введите
следующие команды:</p>
<pre><code class="language-bash">$ rustc main.rs
$ ./main
Привет, мир!
</code></pre>
<p>На Windows просто замените <code>main</code> на <code>main.exe</code>. Вне зависимости от вашей ОС
вы должны увидеть строку <code>Привет, мир!</code> в терминале. Поздравляем! Вы написали
первую программу на Rust. Теперь вы Rust-разработчик! Добро пожаловать!</p>
<h2><a class="header" href="#Анатомия-программ-на-rust" id="Анатомия-программ-на-rust">Анатомия программ на Rust</a></h2>
<p>Теперь давайте детально разберёмся, что происходит в программе «Привет, мир!».
Вот первый кусочек головоломки:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {

}
</code></pre></pre>
<p>Эти строки объявляют «функцию» в Rust. Функция <code>main</code> особенна: это начало
каждой программы на Rust. Первая строка говорит: «Мы объявляем функцию,
именуемую <code>main</code>, которая не получает параметров и ничего не возвращает». Если
бы мы хотели передать в функцию параметры, то указали бы их в скобках (<code>(</code> и
<code>)</code>). Поскольку нам не надо ничего возвращать из этой функции, мы можем опустить
указание типа возвращаемого значения. Мы вернёмся к этому позже.</p>
<p>Вы должны были заметить, что функция обёрнута в фигурные скобки (<code>{</code> и <code>}</code>).
Rust требует оборачивать ими тело любой функции. Также хорошим стилем считается
ставить открывающую фигурную скобку на той же строке, что и объявление функции,
разделяя их одним пробелом.</p>
<p>Теперь эта строка:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    println!(&quot;Привет, мир!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Эта строка делает всю работу в нашей маленькой программе: выводит текст на
экран. Тут есть несколько нюансов, которые имеют существенное значение.
Во-первых, отступ в четыре пробела, а не табуляция.</p>
<p>Теперь разберёмся с <code>println!()</code>. Это вызов одного из <a href="macros.html">макросов</a>,
которыми представлено метапрограммирование в Rust. Если бы вместо макроса была
функция, это выглядело бы следующим образом: <code>println()</code> (без <code>!</code>). Позже мы
обсудим макросы Rust подробнее, а на данный момент всё, что вам нужно знать:
если вы видите <code>!</code>, то вызывается макрос вместо обычной функции.</p>
<p>Идём дальше. <code>&quot;Привет, мир!&quot;</code> — это «строка». Строки — это удивительно сложная
тема для системного языка программирования. Это <a href="the-stack-and-the-heap.html">статически расположенная в
памяти</a> строка. Мы передаём строку в качестве аргумента в
<code>println!</code>, который выводит строки на экран. Достаточно просто!</p>
<p>Строка заканчивается точкой с запятой (<code>;</code>). Rust — <a href="glossary.html#expression-oriented-language">язык с ориентацией на
выражения</a>, а это означает, что в нём большая
часть вещей является выражением. <code>;</code> используется для указания конца выражения и
начала следующего. Большинство строк кода на Rust заканчивается символом <code>;</code>.</p>
<h2><a class="header" href="#Компиляция-и-запуск-это-отдельные-шаги" id="Компиляция-и-запуск-это-отдельные-шаги">Компиляция и запуск это отдельные шаги</a></h2>
<p>В разделе «Написание и запуск программы на Rust» мы рассмотрели, как запустить
только что созданную программу. Теперь мы разберём каждый шаг по отдельности.</p>
<p>Перед запуском программы её нужно скомпилировать. Вы можете воспользоваться
компилятором Rust с помощью команды <code>rustc</code> и передать ваш файл, как показано
здесь:</p>
<pre><code class="language-bash">$ rustc main.rs
</code></pre>
<p>Если раньше вы программировали на С или С++, то заметите, что это напоминает
<code>gcc</code> или <code>clang</code>. После успешной компиляции Rust создаст двоичный исполняемый
файл. На Linux или OSX вы можете убедиться в этом с помощью команды <code>ls</code>:</p>
<pre><code class="language-bash">$ ls
main  main.rs
</code></pre>
<p>Или в Windows:</p>
<pre><code class="language-bash">$ dir
main.exe  main.rs
</code></pre>
<p>У нас есть два файла: файл с нашим исходным кодом, имеющий расширение <code>.rs</code>, и
исполняемый файл (<code>main.exe</code> в Windows, <code>main</code> в остальных случаях). Все, что
осталось сделать, — это запустить <code>main</code> или <code>main.exe</code>:</p>
<pre><code class="language-bash">$ ./main  # или main.exe на Windows
</code></pre>
<p>Мы вывели наш текст <code>&quot;Привет, мир!&quot;</code> в окне терминала.</p>
<p>Если раньше вы использовали динамические языки программирования вроде Ruby,
Python или JavaScript, то, возможно, разделение компиляции и запуска покажется
вам странным. Rust — это язык, на котором программы <em>компилируются перед
исполнением</em>. Это означает, что вы можете собрать программу, дать её кому-то
ещё, и ему не нужно устанавливать Rust для запуска этой программы. Если вы
передадите кому-нибудь <code>.rb</code>, <code>.py</code> или <code>.js</code> файл, им понадобится интерпретатор
Ruby, Python или JavaScript, чтобы скомпилировать и запустить вашу программу
(это делается одной командой). В мире языков программирования много
компромиссов, и Rust сделал свой выбор.</p>
<p>Использовать <code>rustc</code> удобно лишь для небольших программ, но по мере роста
проекта потребуется инструмент, который поможет управлять настройками проекта,
а также позволит проще делиться кодом с другими людьми и проектами. Далее мы
познакомимся с новым инструментом <code>Cargo</code>, который используется для написания
настоящих программ на Rust.</p>
<h1><a class="header" href="#Привет-cargo" id="Привет-cargo">Привет, Cargo!</a></h1>
<p>Cargo — это система сборки и пакетный менеджер для Rust, и Rustaceans используют
его для управления своими проектами на Rust. Cargo заботится о трёх вещах:
сборка кода, загрузка библиотек, от которых зависит ваш код, и сборка этих
библиотек. Библиотеки, которые нужны вашему коду, мы называем «зависимостями»
(&quot;dependencies&quot;), поскольку ваш код зависит от них.</p>
<p>Поначалу вашей программе не понадобится никаких зависимостей, поэтому будем
использовать только первую часть его возможностей. Со временем нам понадобится
добавить несколько зависимостей, и нам не составит труда сделать это, используя
Cargo.</p>
<p>Подавляющее количество проектов на Rust используют Cargo, поэтому в рамках этой
книги мы будем исходить из того, что вы тоже делаете это. Если вы использовали
официальный установщик, то Cargo установился вместе с Rust. Если же вы
установили Rust каким-либо другим образом, то вы можете проверить, есть ли у вас
Cargo, введя следующую команду в терминал:</p>
<pre><code class="language-bash">$ cargo --version
</code></pre>
<p>Если вы увидели номер версии, то все в порядке. Если же вы увидели сообщение об
ошибке наподобие &quot;<code>команда не найдена</code>&quot;, то вам нужно ознакомиться с
документацией для системы, в которой вы установили Rust.</p>
<h2><a class="header" href="#Переход-на-cargo" id="Переход-на-cargo">Переход на Cargo</a></h2>
<p>Давайте переведём наш проект «Привет, мир!» на использование Cargo. Для перехода
на Cargo нужно сделать три вещи:</p>
<ol>
<li>Расположить файл с исходным кодом в правильной директории.</li>
<li>Избавиться от старого исполняемого файла (<code>main.exe</code> или <code>main</code>) и сделать
новый.</li>
<li>Создать конфигурационный файл для Cargo.</li>
</ol>
<p>Давайте сделаем это!</p>
<h3><a class="header" href="#Создание-нового-исполняемого-файла-и-директории-с-исходным-кодом" id="Создание-нового-исполняемого-файла-и-директории-с-исходным-кодом">Создание нового исполняемого файла и директории с исходным кодом</a></h3>
<p>Для начала вернитесь к вашему терминалу, перейдите в вашу директорию
<em>hello_world</em> и введите следующие команды:</p>
<pre><code class="language-bash">$ mkdir src
$ mv main.rs src/main.rs
$ rm main  # или 'del main.exe' для Windows
</code></pre>
<p>Cargo ожидает, что ваши файлы с исходным кодом находятся в директории <em>src</em>.
Такой подход оставляет верхний уровень вашего проекта для вещей вроде README,
файлов с текстом лицензии и других не относящихся к вашему коду. Cargo помогает
нам сохранять наши проекты красивыми и аккуратными. Всему есть своё место, и всё
находится на своих местах.</p>
<p>Теперь скопируйте <em>main.rs</em> в директорию <em>src</em> и удалите скомпилированный файл,
который вы создали с помощью <code>rustc</code>.</p>
<p>Отметим, что поскольку мы создаём исполняемый файл, то мы используем <code>main.rs</code>.
Если бы мы хотели создать библиотеку, то мы использовали бы lib.rs. Cargo
использует это соглашение для успешной компиляции вашего проекта, но вы можете
это изменить, если захотите.</p>
<h3><a class="header" href="#Создание-конфигурационного-файла" id="Создание-конфигурационного-файла">Создание конфигурационного файла</a></h3>
<p>Теперь создайте новый файл внутри директории <em>hello_world</em> и назовите его
<code>Cargo.toml</code>.</p>
<p>Убедитесь в том, что имя правильное: вам нужна заглавная <code>C</code>! В противном случае
Cargo не найдёт конфигурационный файл.</p>
<p>Это файл в формате <a href="https://github.com/toml-lang/toml"><em>TOML</em></a><!-- ignore --> (Tom's Obvious, Minimal Language). TOML — это аналог
INI, но с некоторыми дополнениями, и он используется в конфигурационных файлах
для Cargo.</p>
<p>Поместите в данный файл следующие строки:</p>
<pre><code class="language-toml">[package]

name = &quot;hello_world&quot;
version = &quot;0.0.1&quot;
authors = [ &quot;Your name &lt;you@example.com&gt;&quot; ]
</code></pre>
<p>Первая строка, <code>[package]</code>, говорит о том, что следующие параметры отвечают за
настройку пакета. Когда нам понадобится добавить больше информации в этот файл,
мы создадим другие разделы, но сейчас нам достаточно настроек пакета.</p>
<p>Другие три строчки устанавливают три значения конфигурации, которые необходимы
Cargo для компиляции вашей программы: имя, версия и автор.</p>
<p>После того как вы добавили эту информацию в <em>Cargo.toml</em>, сохраните изменения.
На этом создание конфигурационного файла завершено.</p>
<h2><a class="header" href="#Сборка-и-запуск-cargo-проекта" id="Сборка-и-запуск-cargo-проекта">Сборка и запуск Cargo проекта</a></h2>
<p>Теперь, после создания файла <code>Cargo.toml</code> в корневой директории, мы готовы
приступить к сборке и запуску нашего проекта. Чтобы сделать это, введите
следующие команды:</p>
<pre><code class="language-bash">$ cargo build
   Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
$ ./target/debug/hello_world
Привет, мир!
</code></pre>
<p>Та-да! Мы собрали наш проект, вызвав <code>cargo build</code>, и запустили его с помощью
<code>./target/debug/hello_world</code>. Мы можем сделать это в один шаг, используя
<code>cargo run</code>:</p>
<pre><code class="language-bash">$ cargo run
     Running `target/debug/hello_world`
Привет, мир!
</code></pre>
<p>Заметьте, что сейчас мы не пересобрали наш проект. Cargo понял, что мы не
изменили файл с исходным кодом, и сразу запустил исполняемый файл. Если бы мы
изменили файл, мы бы увидели оба шага:</p>
<pre><code class="language-bash">$ cargo run
   Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
     Running `target/debug/hello_world`
Привет, мир!
</code></pre>
<p>На первый взгляд это кажется сложнее, по сравнению с более простым
использованием <code>rustc</code>, но давайте подумаем о будущем: если в нашем проекте
будет больше одного файла, мы должны будем вызывать rustc для каждого из них и
передавать кучу параметров, чтобы собрать их вместе. С Cargo, когда наш проект
вырастет, нам понадобится вызвать только команду <code>cargo build</code>, и она всё
сделает за нас.</p>
<h2><a class="header" href="#Сборка-релизной-версии" id="Сборка-релизной-версии">Сборка релизной версии</a></h2>
<p>Когда вы закончите работать над проектом и он окончательно будет готов к
релизу, используйте команду <code>cargo build --release</code> для компиляции вашего
проекта с оптимизацией. Эти оптимизации делают ваш код на Rust быстрее, но
требуют больше времени на компиляцию. Именно из-за этого существует два разных
способа: один для разработки, другой для сборки финальной версии, которую вы
отдадите пользователям.</p>
<p>Также вы должны были заметить, что Cargo создал новый файл: <code>Cargo.lock</code>.</p>
<pre><code class="language-toml">[root]
name = &quot;hello_world&quot;
version = &quot;0.0.1&quot;
</code></pre>
<p>Этот файл используется Cargo для отслеживания зависимостей в вашем приложении.
Прямо сейчас у нас нет ни одной, поэтому этот файл немного пустоват. Вам не
нужно редактировать этот файл самостоятельно, Cargo сам с ним разберётся.</p>
<p>Вот и все! Мы успешно собрали <code>hello_world</code> с помощью Cargo.</p>
<p>Несмотря на то, что наша программа проста, мы использовали большую часть
реальных инструментов, которые вы будете использовать в своём дальнейшем пути
Rust-программиста. Более того, вы можете рассчитывать, что практически все
проекты на Rust можно будет собрать с помощью вариации этих команд:</p>
<pre><code class="language-bash">$ git clone someurl.com/foo
$ cd foo
$ cargo build
</code></pre>
<h2><a class="header" href="#Простой-способ-создать-новый-cargo-проект" id="Простой-способ-создать-новый-cargo-проект">Простой способ создать новый Cargo проект</a></h2>
<p>Вам не нужно повторять вышеприведённые шаги каждый раз, когда вы хотите создать
новый проект! Cargo может создать директорию проекта, в которой вы сразу сможете
приступить к разработке.</p>
<p>Чтобы создать новый проект с помощью Cargo, нужно ввести команду <code>cargo new</code>:</p>
<pre><code class="language-bash">$ cargo new hello_world --bin
</code></pre>
<p>Мы указываем аргумент <code>--bin</code>, так как хотим создать исполняемую программу. Если
мы не укажем этот аргумент, то Cargo создаст проект для библиотеки. Исполняемые
файлы часто называют <em>бинарниками</em> (поскольку обычно они находятся в
<code>/usr/bin</code>, если вы используете Unix систему).</p>
<p>Cargo сгенерировал два файла и одну директорию: <code>Cargo.toml</code> и директорию <em>src</em>
с файлом <em>main.rs</em>. Они должны выглядеть так же, как те, что мы создали ранее.</p>
<p>Этого достаточно для того, чтобы начать. Открыв <code>Cargo.toml</code>, вы должны увидеть
следующее:</p>
<pre><code class="language-toml">[package]

name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
</code></pre>
<p>Cargo наполнил этот файл значениями по умолчанию на основании переданных
аргументов и глобальной конфигурации <code>git</code>. Также он инициализировал
директорию <code>hello_world</code> как <code>git</code> репозиторий.</p>
<p>Вот что должно быть внутри <code>src/main.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Cargo создал «Hello World!» для нас, и вы уже можете приступить к
программированию!</p>
<blockquote>
<p>У Cargo есть собственное <a href="http://doc.crates.io/guide.html">руководство</a>, в котором про него рассказано
более детально.</p>
</blockquote>
<h1><a class="header" href="#Заключение" id="Заключение">Заключение</a></h1>
<p>Это основы, которые вы будете часто использовать на протяжении всего вашего
взаимодействия с Rust. Теперь давайте отложим инструментарий и узнаем больше о
самом языке.</p>
<p>У вас есть два пути: погрузиться в изучение реального проекта, открыв раздел
«<a href="learn-rust.html">Изучение Rust</a>», или начать с самого низа и постепенно продвигаться
наверх, начав с раздела «<a href="syntax-and-semantics.html">Синтаксис и семантика</a>». Программисты, имеющие
опыт работы с системными языками, вероятно, предпочтут «Изучение Rust», в то
время как программисты, имеющие опыт работы с динамическими языками, скорее
всего, захотят пойти по второму пути. Разные люди учатся по-разному! Выберите
то, что подходит именно вам.</p>

                    </main>
                </div>
            </div>
        </div>
    </body>
</html>
