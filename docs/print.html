<!DOCTYPE HTML>
<html lang="ru" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Язык программирования Rust</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="INTRODUCTION.html"><strong aria-hidden="true">1.</strong> Введение</a></li><li><a href="getting-started.html"><strong aria-hidden="true">2.</strong> C чего начать</a></li><li><a href="learn-rust.html"><strong aria-hidden="true">3.</strong> Изучение Rust</a></li><li><ol class="section"><li><a href="guessing-game.html"><strong aria-hidden="true">3.1.</strong> Угадайка</a></li><li><a href="dining-philosophers.html"><strong aria-hidden="true">3.2.</strong> Обедающие философы</a></li><li><a href="rust-inside-other-languages.html"><strong aria-hidden="true">3.3.</strong> Вызов кода на Rust из других языков</a></li></ol></li><li><a href="syntax-and-semantics.html"><strong aria-hidden="true">4.</strong> Синтаксис и семантика</a></li><li><ol class="section"><li><a href="variable-bindings.html"><strong aria-hidden="true">4.1.</strong> Связывание имён</a></li><li><a href="functions.html"><strong aria-hidden="true">4.2.</strong> Функции</a></li><li><a href="primitive-types.html"><strong aria-hidden="true">4.3.</strong> Простые типы</a></li><li><a href="comments.html"><strong aria-hidden="true">4.4.</strong> Комментарии</a></li><li><a href="if.html"><strong aria-hidden="true">4.5.</strong> Конструкция if</a></li><li><a href="loops.html"><strong aria-hidden="true">4.6.</strong> Циклы</a></li><li><a href="ownership.html"><strong aria-hidden="true">4.7.</strong> Владение</a></li><li><a href="references-and-borrowing.html"><strong aria-hidden="true">4.8.</strong> Ссылки и заимствование</a></li><li><a href="lifetimes.html"><strong aria-hidden="true">4.9.</strong> Время жизни</a></li><li><a href="mutability.html"><strong aria-hidden="true">4.10.</strong> Изменяемость</a></li><li><a href="structs.html"><strong aria-hidden="true">4.11.</strong> Структуры</a></li><li><a href="enums.html"><strong aria-hidden="true">4.12.</strong> Перечисления</a></li><li><a href="match.html"><strong aria-hidden="true">4.13.</strong> Конструкция match</a></li><li><a href="patterns.html"><strong aria-hidden="true">4.14.</strong> Шаблоны сопоставления match</a></li><li><a href="method-syntax.html"><strong aria-hidden="true">4.15.</strong> Синтаксис методов</a></li><li><a href="vectors.html"><strong aria-hidden="true">4.16.</strong> Вектора</a></li><li><a href="strings.html"><strong aria-hidden="true">4.17.</strong> Строки</a></li><li><a href="generics.html"><strong aria-hidden="true">4.18.</strong> Обобщённое программирование</a></li><li><a href="traits.html"><strong aria-hidden="true">4.19.</strong> Типажи</a></li><li><a href="drop.html"><strong aria-hidden="true">4.20.</strong> Типаж Drop</a></li><li><a href="if-let.html"><strong aria-hidden="true">4.21.</strong> Конструкция if let</a></li><li><a href="trait-objects.html"><strong aria-hidden="true">4.22.</strong> Типажи-объекты</a></li><li><a href="closures.html"><strong aria-hidden="true">4.23.</strong> Замыкания</a></li><li><a href="ufcs.html"><strong aria-hidden="true">4.24.</strong> Универсальный синтаксис вызова функций</a></li><li><a href="crates-and-modules.html"><strong aria-hidden="true">4.25.</strong> Контейнеры и модули</a></li><li><a href="const-and-static.html"><strong aria-hidden="true">4.26.</strong> const и static</a></li><li><a href="attributes.html"><strong aria-hidden="true">4.27.</strong> Атрибуты</a></li><li><a href="type-aliases.html"><strong aria-hidden="true">4.28.</strong> Псевдонимы типов</a></li><li><a href="casting-between-types.html"><strong aria-hidden="true">4.29.</strong> Приведение типов</a></li><li><a href="associated-types.html"><strong aria-hidden="true">4.30.</strong> Ассоциированные типы</a></li><li><a href="unsized-types.html"><strong aria-hidden="true">4.31.</strong> Безразмерные типы</a></li><li><a href="operators-and-overloading.html"><strong aria-hidden="true">4.32.</strong> Перегрузка операций</a></li><li><a href="deref-coercions.html"><strong aria-hidden="true">4.33.</strong> Преобразования при разыменовании</a></li><li><a href="macros.html"><strong aria-hidden="true">4.34.</strong> Макросы</a></li><li><a href="raw-pointers.html"><strong aria-hidden="true">4.35.</strong> Сырые указатели</a></li><li><a href="unsafe.html"><strong aria-hidden="true">4.36.</strong> Небезопасный код</a></li></ol></li><li><a href="effective-rust.html"><strong aria-hidden="true">5.</strong> Эффективное использование Rust</a></li><li><ol class="section"><li><a href="the-stack-and-the-heap.html"><strong aria-hidden="true">5.1.</strong> Стек и куча</a></li><li><a href="testing.html"><strong aria-hidden="true">5.2.</strong> Тестирование</a></li><li><a href="conditional-compilation.html"><strong aria-hidden="true">5.3.</strong> Условная компиляция</a></li><li><a href="documentation.html"><strong aria-hidden="true">5.4.</strong> Документация</a></li><li><a href="iterators.html"><strong aria-hidden="true">5.5.</strong> Итераторы</a></li><li><a href="concurrency.html"><strong aria-hidden="true">5.6.</strong> Многозадачность</a></li><li><a href="error-handling.html"><strong aria-hidden="true">5.7.</strong> Обработка ошибок</a></li><li><a href="choosing-your-guarantees.html"><strong aria-hidden="true">5.8.</strong> Выбор гарантий</a></li><li><a href="ffi.html"><strong aria-hidden="true">5.9.</strong> Интерфейс внешних функций</a></li><li><a href="borrow-and-asref.html"><strong aria-hidden="true">5.10.</strong> Типажи Borrow и AsRef</a></li><li><a href="release-channels.html"><strong aria-hidden="true">5.11.</strong> Каналы сборок</a></li><li><a href="using-rust-without-the-standard-library.html"><strong aria-hidden="true">5.12.</strong> Using Rust without the standard library</a></li></ol></li><li><a href="nightly-rust.html"><strong aria-hidden="true">6.</strong> Нестабильные возможности Rust</a></li><li><ol class="section"><li><a href="compiler-plugins.html"><strong aria-hidden="true">6.1.</strong> Плагины к компилятору</a></li><li><a href="inline-assembly.html"><strong aria-hidden="true">6.2.</strong> Встроенный ассемблерный код</a></li><li><a href="no-stdlib.html"><strong aria-hidden="true">6.3.</strong> Без stdlib</a></li><li><a href="intrinsics.html"><strong aria-hidden="true">6.4.</strong> Внутренние средства</a></li><li><a href="lang-items.html"><strong aria-hidden="true">6.5.</strong> Элементы языка</a></li><li><a href="advanced-linking.html"><strong aria-hidden="true">6.6.</strong> Продвинутое руководство по компоновке</a></li><li><a href="benchmark-tests.html"><strong aria-hidden="true">6.7.</strong> Тесты производительности</a></li><li><a href="box-syntax-and-patterns.html"><strong aria-hidden="true">6.8.</strong> Синтаксис упаковки и шаблоны match</a></li><li><a href="slice-patterns.html"><strong aria-hidden="true">6.9.</strong> Шаблоны match для срезов</a></li><li><a href="associated-constants.html"><strong aria-hidden="true">6.10.</strong> Ассоциированные константы</a></li><li><a href="custom-allocators.html"><strong aria-hidden="true">6.11.</strong> Пользовательские менеджеры памяти</a></li></ol></li><li><a href="glossary.html"><strong aria-hidden="true">7.</strong> Глоссарий</a></li><li><a href="syntax-index.html"><strong aria-hidden="true">8.</strong> Syntax Index</a></li><li><a href="bibliography.html"><strong aria-hidden="true">9.</strong> Библиография</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Язык программирования Rust</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p>% Введение</p>
<p>Добро пожаловать! Эта книга обучает основным принципам работы с языком
программирования <a href="http://rust-lang.org">Rust</a>. Rust — это системный язык программирования,
внимание которого сосредоточено на трёх задачах: безопасность, скорость и
параллелизм. Он решает эти задачи без сборщика мусора, что делает его полезным в
ряде случаев, когда использование других языков было бы нецелесообразно: при
встраивании в другие языки, при написании программ с особыми пространственными и
временными требованиями, при написании низкоуровневого кода, такого как драйверы
устройств и операционные системы. Во время компиляции Rust делает ряд проверок
безопасности. За счёт этого не возникает накладных расходов во время выполнения
приложения и устраняются все гонки данных.  Это даёт Rust преимущество над
другими языками программирования, имеющими аналогичную направленность. Rust
также направлен на достижение «абстракции с нулевой стоимостью». Хотя некоторые
из этих абстракций и ведут себя как в языках высокого уровня, но даже тогда Rust
по-прежнему обеспечивает точный контроль, как делал бы язык низкого уровня.</p>
<p>Книга «Язык программирования Rust» делится на восемь разделов. Это введение
является первым из них. Затем идут:</p>
<ul>
<li><a href="getting-started.html">C чего начать</a> — Настройка компьютера для разработки на Rust.</li>
<li><a href="learn-rust.html">Изучение Rust</a> — Обучение программированию на Rust на примере небольших
проектов.</li>
<li><a href="syntax-and-semantics.html">Синтаксис и семантика</a> — Каждое понятие Rust разбивается на небольшие
кусочки.</li>
<li><a href="effective-rust.html">Эффективное использование Rust</a> — Понятия более высокого уровня для
написания качественного кода на Rust.</li>
<li><a href="nightly-rust.html">Нестабильные возможности Rust</a> — Передовые возможности, которые пока не
добавлены в стабильную сборку.</li>
<li><a href="glossary.html">Глоссарий</a> — Ссылки на термины, используемые в книге.</li>
<li><a href="bibliography.html">Библиография</a> — Литература, которая оказала влияние на Rust.</li>
</ul>
<p>После прочтения этого введения, в зависимости от ваших предпочтений, вы можете
продолжить дальнейшее изучение либо в направлении «Изучение Rust», либо в
направлении «Синтаксис и семантика». Если вы предпочитаете изучить язык на
примере реального проекта, лучшим выбором будет раздел «Изучение Rust». Раздел
«Синтаксис и семантика» подойдёт тем, кто предпочитает тщательно изучить каждое
понятие языка отдельно, перед тем как двигаться дальше. Большое количество
перекрёстных ссылок соединяет эти части воедино.</p>
<h3><a class="header" href="#Содействие" id="Содействие">Содействие</a></h3>
<p>Исходные файлы, из которых генерируется оригинал этой книги, могут быть найдены
на <a href="https://github.com/rust-lang/rust/tree/master/src/doc/book">GitHub</a>.</p>
<p>Исходные файлы перевода этой книги на русский язык также находятся на GitHub:
<a href="https://github.com/ruRust/rust_book_ru">https://github.com/ruRust/rust_book_ru</a></p>
<p>% C чего начать</p>
<p>Первый раздел книги рассказывает о том, как начать работать с Rust и его
инструментами. Сначала мы установим Rust, затем напишем классическую программу
«Привет, мир!» и, наконец, поговорим о Cargo, который представляет собой
систему сборки и менеджер пакетов в Rust.</p>
<h1><a class="header" href="#Установка-rust" id="Установка-rust">Установка Rust</a></h1>
<p>Первым шагом к использованию Rust является его установка. В этой главе нам
понадобится интернет-соединение для выполнения команд, с помощью которых мы
загрузим Rust из Интернета.</p>
<p>Мы воспользуемся несколькими командами в терминале, и они все будут начинаться
с <code>$</code>. Вам не нужно вводить <code>$</code>: этот символ используется только для того, чтобы
обозначить начало каждой команды. В Интернете можно увидеть множество руководств
и примеров, которые следуют этому правилу: <code>$</code> обозначает команды, которые
выполняются с правами обычного пользователя, и <code>#</code> — команды, которые
выполняются с правами администратора.</p>
<h2><a class="header" href="#Поддерживаемые-платформы" id="Поддерживаемые-платформы">Поддерживаемые платформы</a></h2>
<p>Перечень платформ, на которых работает и для которых компилирует компилятор
Rust, довольно большой, однако не все платформы поддерживаются одинаково.
Существует три уровня поддержки Rust, каждый из которых предоставляет свой
набор гарантий.</p>
<p>Платформы идентифицируются по их «целевой тройке», которая является строкой,
сообщающей компилятору, какие выходные данные должны быть произведены. Столбцы
ниже указывают, работает ли соответствующий компонент на указанной платформе.</p>
<h3><a class="header" href="#Первый-уровень" id="Первый-уровень">Первый уровень</a></h3>
<p>Первый уровень платформ может восприниматься как «гарантированно собирается и
работает». В частности, каждая из них удовлетворяет следующим требованиям:</p>
<ul>
<li>Автоматические тесты обеспечивают тестирование этих платформ.</li>
<li>Изменения, принятые в ветку master репозитория <code>rust-lang/rust</code>, прошли
тестирование.</li>
<li>Для этих платформ предоставляются официальные пакеты.</li>
<li>Доступна документация о том, как собрать и использовать платформу.</li>
</ul>
<table><thead><tr><th>Target</th><th>std</th><th>rustc</th><th>cargo</th><th>notes</th></tr></thead><tbody>
<tr><td><code>x86_64-pc-windows-msvc</code></td><td>✓</td><td>✓</td><td>✓</td><td>64-bit MSVC (Windows 7+)</td></tr>
<tr><td><code>i686-pc-windows-gnu</code></td><td>✓</td><td>✓</td><td>✓</td><td>32-bit MinGW (Windows 7+)</td></tr>
<tr><td><code>x86_64-pc-windows-gnu</code></td><td>✓</td><td>✓</td><td>✓</td><td>64-bit MinGW (Windows 7+)</td></tr>
<tr><td><code>i686-apple-darwin</code></td><td>✓</td><td>✓</td><td>✓</td><td>32-bit OSX (10.7+, Lion+)</td></tr>
<tr><td><code>x86_64-apple-darwin</code></td><td>✓</td><td>✓</td><td>✓</td><td>64-bit OSX (10.7+, Lion+)</td></tr>
<tr><td><code>i686-unknown-linux-gnu</code></td><td>✓</td><td>✓</td><td>✓</td><td>32-bit Linux (2.6.18+)</td></tr>
<tr><td><code>x86_64-unknown-linux-gnu</code></td><td>✓</td><td>✓</td><td>✓</td><td>64-bit Linux (2.6.18+)</td></tr>
</tbody></table>
<h3><a class="header" href="#Второй-уровень" id="Второй-уровень">Второй уровень</a></h3>
<p>Второй уровень платформ может восприниматься как «гарантированно собирается».
Автоматические тесты не поддерживаются, и в связи с этим работоспособность
сборки не гарантируется. Но эти платформы обычно работают довольно хорошо,
и предложения по улучшению всегда приветствуются! В частности, эти платформы
удовлетворяют следующим требованиям:</p>
<ul>
<li>Настроена автоматическая сборка, но тестирования не происходит.</li>
<li>Изменения, принятые в ветку master репозитория <code>rust-lang/rust</code>, собираются
для этих платформ. Имейте в виду, что для некоторых платформ собирается
только стандартная библиотека, но для остальных настроена полная раскрутка
компилятора (bootstraping).</li>
<li>Для этих платформ предоставляются официальные пакеты.</li>
</ul>
<table><thead><tr><th>Target</th><th>std</th><th>rustc</th><th>cargo</th><th>notes</th></tr></thead><tbody>
<tr><td><code>i686-pc-windows-msvc</code></td><td>✓</td><td>✓</td><td>✓</td><td>32-bit MSVC (Windows 7+)</td></tr>
</tbody></table>
<h3><a class="header" href="#Третий-уровень" id="Третий-уровень">Третий уровень</a></h3>
<p>Третий уровень платформ — это те, которые Rust поддерживает, но для которых
принятые изменения автоматически не собираются и не тестируются. Для данных
платформ работоспособность сборки определятся степенью содействия сообщества.
К тому же официальные пакеты и установщики не предоставляются, но они могут
быть предоставлены сообществом.</p>
<table><thead><tr><th>Target</th><th>std</th><th>rustc</th><th>cargo</th><th>notes</th></tr></thead><tbody>
<tr><td><code>x86_64-unknown-linux-musl</code></td><td>✓</td><td></td><td></td><td>64-bit Linux with MUSL</td></tr>
<tr><td><code>arm-linux-androideabi</code></td><td>✓</td><td></td><td></td><td>ARM Android</td></tr>
<tr><td><code>i686-linux-android</code></td><td>✓</td><td></td><td></td><td>32-bit x86 Android</td></tr>
<tr><td><code>aarch64-linux-android</code></td><td>✓</td><td></td><td></td><td>ARM64 Android</td></tr>
<tr><td><code>arm-unknown-linux-gnueabi</code></td><td>✓</td><td>✓</td><td></td><td>ARM Linux (2.6.18+)</td></tr>
<tr><td><code>arm-unknown-linux-gnueabihf</code></td><td>✓</td><td>✓</td><td></td><td>ARM Linux (2.6.18+)</td></tr>
<tr><td><code>aarch64-unknown-linux-gnu</code></td><td>✓</td><td></td><td></td><td>ARM64 Linux (2.6.18+)</td></tr>
<tr><td><code>mips-unknown-linux-gnu</code></td><td>✓</td><td></td><td></td><td>MIPS Linux (2.6.18+)</td></tr>
<tr><td><code>mipsel-unknown-linux-gnu</code></td><td>✓</td><td></td><td></td><td>MIPS (LE) Linux (2.6.18+)</td></tr>
<tr><td><code>powerpc-unknown-linux-gnu</code></td><td>✓</td><td></td><td></td><td>PowerPC Linux (2.6.18+)</td></tr>
<tr><td><code>i386-apple-ios</code></td><td>✓</td><td></td><td></td><td>32-bit x86 iOS</td></tr>
<tr><td><code>x86_64-apple-ios</code></td><td>✓</td><td></td><td></td><td>64-bit x86 iOS</td></tr>
<tr><td><code>armv7-apple-ios</code></td><td>✓</td><td></td><td></td><td>ARM iOS</td></tr>
<tr><td><code>armv7s-apple-ios</code></td><td>✓</td><td></td><td></td><td>ARM iOS</td></tr>
<tr><td><code>aarch64-apple-ios</code></td><td>✓</td><td></td><td></td><td>ARM64 iOS</td></tr>
<tr><td><code>i686-unknown-freebsd</code></td><td>✓</td><td>✓</td><td></td><td>32-bit FreeBSD</td></tr>
<tr><td><code>x86_64-unknown-freebsd</code></td><td>✓</td><td>✓</td><td></td><td>64-bit FreeBSD</td></tr>
<tr><td><code>x86_64-unknown-openbsd</code></td><td>✓</td><td>✓</td><td></td><td>64-bit OpenBSD</td></tr>
<tr><td><code>x86_64-unknown-netbsd</code></td><td>✓</td><td>✓</td><td></td><td>64-bit NetBSD</td></tr>
<tr><td><code>x86_64-unknown-bitrig</code></td><td>✓</td><td>✓</td><td></td><td>64-bit Bitrig</td></tr>
<tr><td><code>x86_64-unknown-dragonfly</code></td><td>✓</td><td>✓</td><td></td><td>64-bit DragonFlyBSD</td></tr>
<tr><td><code>x86_64-rumprun-netbsd</code></td><td>✓</td><td></td><td></td><td>64-bit NetBSD Rump Kernel</td></tr>
<tr><td><code>i686-pc-windows-msvc</code> (XP)</td><td>✓</td><td></td><td></td><td>Windows XP support</td></tr>
<tr><td><code>x86_64-pc-windows-msvc</code> (XP)</td><td>✓</td><td></td><td></td><td>Windows XP support</td></tr>
</tbody></table>
<p>Имейте в виду, что данная таблица со временем может быть дополнена: это не
исчерпывающий набор платформ третьего уровня!</p>
<h2><a class="header" href="#Установка-на-linux-или-mac" id="Установка-на-linux-или-mac">Установка на Linux или Mac</a></h2>
<p>Если вы используете Linux или Mac, то всё, что вам нужно сделать, — это ввести
следующую команду в консоль:</p>
<pre><code class="language-bash">$ curl -sSf https://static.rust-lang.org/rustup.sh | sh
</code></pre>
<p>Эта команда загрузит скрипт и начнёт установку. Если всё пройдёт успешно, то вы
увидите следующий текст:</p>
<pre><code class="language-text">Welcome to Rust.

This script will download the Rust compiler and its package manager, Cargo, and
install them to /usr/local. You may install elsewhere by running this script
with the --prefix=&lt;path&gt; option.

The installer will run under ‘sudo’ and may ask you for your password. If you do
not want the script to run ‘sudo’ then pass it the --disable-sudo flag.

You may uninstall later by running /usr/local/lib/rustlib/uninstall.sh,
or by running this script again with the --uninstall flag.

Continue? (y/N)
</code></pre>
<p>Нажмите <code>y</code> для подтверждения и следуйте дальнейшим подсказкам.</p>
<h2><a class="header" href="#Установка-на-windows" id="Установка-на-windows">Установка на Windows</a></h2>
<p>Если вы используете Windows, то скачайте подходящий <a href="https://www.rust-lang.org/install.html">установщик</a>.</p>
<h2><a class="header" href="#Удаление" id="Удаление">Удаление</a></h2>
<p>Удалить Rust так же просто, как и установить его. На Linux или Mac нужно просто
запустить скрипт удаления:</p>
<pre><code class="language-bash">$ sudo /usr/local/lib/rustlib/uninstall.sh
</code></pre>
<p>Если вы использовали установщик Windows, то просто повторно запустите <code>.msi</code>,
который предложит вам возможность удаления.</p>
<h2><a class="header" href="#Решение-проблем" id="Решение-проблем">Решение проблем</a></h2>
<p>Если у вас установлен Rust, то можно открыть терминал и ввести:</p>
<pre><code class="language-bash">$ rustc --version
</code></pre>
<p>Вы должны увидеть версию, хеш коммита и дату коммита.</p>
<p>Если это так, то теперь у вас есть установленный Rust! Поздравляем!</p>
<p>Если нет и вы пользователь Windows, то убедитесь в том, что Rust прописан в
вашей системной переменной %PATH%. Если это не так, то запустите установщик
снова, выберите &quot;Change&quot; на странице &quot;Change, repair, or remove installation&quot; и
убедитесь, что &quot;Add to PATH&quot; указывает на локальный жёсткий диск.</p>
<p>Существует несколько мест, где вы можете получить помощь. Самый простой
вариант — <a href="irc://irc.mozilla.org/#rust">канал #rust на irc.mozilla.org</a>, к которому вы можете
подключиться через <a href="http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Mibbit</a>. Нажмите на эту ссылку, и вы будете общаться
в чате с другими Rustaceans (это дурашливое прозвище, которым мы себя называем),
и мы поможем вам. Другие полезные ресурсы, посвящённые Rust: <a href="https://users.rust-lang.org/">форум
пользователей</a> и <a href="http://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.
Русскоязычные ресурсы: <a href="http://rustycrate.ru">сайт сообщества</a>, <a href="http://forum.rustycrate.ru">форум</a>,
<a href="http://ru.stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.</p>
<p>Установщик также устанавливает документацию, которая доступна без подключения к
сети. На UNIX системах она располагается в директории
<code>/usr/local/share/doc/rust</code>. В Windows используется директория <code>share/doc</code>,
относительно того, куда вы установили Rust.</p>
<h1><a class="header" href="#Привет-мир" id="Привет-мир">Привет, мир!</a></h1>
<p>Теперь, когда вы установили Rust, давайте напишем первую программу на Rust.
Традиционно при изучении нового языка программирования первая написанная
программа просто выводит на экран «Привет, мир!», и мы следуем этой традиции.</p>
<p>Хорошо начинать с такой простой программы, поскольку можно убедиться, что ваш
компилятор не только установлен, но и работает правильно. Вывод информации на
экран будет замечательным способом проверить это.</p>
<blockquote>
<p>На самом деле это приводит к ещё одной проблеме, о которой мы должны
предупредить: данное руководство предполагает, что у вас есть базовые навыки
работы с командной строкой. Rust не выдвигает специфических требований к вашей
среде разработки или тому, как вы храните свой код. Если вы предпочитаете
использовать IDE, посмотрите на проект <a href="https://github.com/oakes/SolidOak">SolidOak</a>, или на плагины к
вашей любимой IDE. Есть множество расширений, разрабатываемых сообществом, а
также <a href="https://github.com/rust-lang/rust/blob/master/src/etc/CONFIGS.md">плагинов для разных редакторов</a>, поддерживаемых командой Rust.
Настройка вашего редактора или IDE выходит за пределы данного руководства.
Посмотрите руководство по использованию выбранного вами плагина.</p>
</blockquote>
<h2><a class="header" href="#Создание-проекта" id="Создание-проекта">Создание проекта</a></h2>
<p>Первое, с чего мы должны начать, — создание файла для нашего кода. Для Rust не
имеет значения, где находится ваш код, но в рамках этого руководства мы
рекомендуем создать директорию <em>projects</em> в вашей домашней директории и хранить
там все ваши проекты. Откройте терминал и введите следующие команды, чтобы
создать директорию для этого проекта:</p>
<pre><code class="language-bash">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<blockquote>
<p>Если вы используете Windows и не используете PowerShell, ~ может не работать.
Обратитесь к документации вашей оболочки для уточнения деталей.</p>
</blockquote>
<h2><a class="header" href="#Написание-и-запуск-программы-на-rust" id="Написание-и-запуск-программы-на-rust">Написание и запуск программы на Rust</a></h2>
<p>Теперь создадим новый файл для кода программы. Назовём наш файл <em>main.rs</em>.
Файлы с исходным кодом на Rust всегда имеют расширение <em>.rs</em>. Если вы
хотите использовать в имени вашего файла больше одного слова, разделяйте их
подчёркиванием; например <em>hello_world.rs</em>, а не <em>helloworld.rs</em>.</p>
<p>Теперь откройте только что созданный файл <em>main.rs</em> и добавьте в него следующий
код:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Привет, мир!&quot;);
}
</code></pre></pre>
<p>Сохраните файл и вернитесь к вашему окну терминала. На Linux или OSX введите
следующие команды:</p>
<pre><code class="language-bash">$ rustc main.rs
$ ./main
Привет, мир!
</code></pre>
<p>На Windows просто замените <code>main</code> на <code>main.exe</code>. Вне зависимости от вашей ОС
вы должны увидеть строку <code>Привет, мир!</code> в терминале. Поздравляем! Вы написали
первую программу на Rust. Теперь вы Rust-разработчик! Добро пожаловать!</p>
<h2><a class="header" href="#Анатомия-программ-на-rust" id="Анатомия-программ-на-rust">Анатомия программ на Rust</a></h2>
<p>Теперь давайте детально разберёмся, что происходит в программе «Привет, мир!».
Вот первый кусочек головоломки:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {

}
</code></pre></pre>
<p>Эти строки объявляют «функцию» в Rust. Функция <code>main</code> особенна: это начало
каждой программы на Rust. Первая строка говорит: «Мы объявляем функцию,
именуемую <code>main</code>, которая не получает параметров и ничего не возвращает». Если
бы мы хотели передать в функцию параметры, то указали бы их в скобках (<code>(</code> и
<code>)</code>). Поскольку нам не надо ничего возвращать из этой функции, мы можем опустить
указание типа возвращаемого значения. Мы вернёмся к этому позже.</p>
<p>Вы должны были заметить, что функция обёрнута в фигурные скобки (<code>{</code> и <code>}</code>).
Rust требует оборачивать ими тело любой функции. Также хорошим стилем считается
ставить открывающую фигурную скобку на той же строке, что и объявление функции,
разделяя их одним пробелом.</p>
<p>Теперь эта строка:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
    println!(&quot;Привет, мир!&quot;);
#}</code></pre></pre>
<p>Эта строка делает всю работу в нашей маленькой программе: выводит текст на
экран. Тут есть несколько нюансов, которые имеют существенное значение.
Во-первых, отступ в четыре пробела, а не табуляция.</p>
<p>Теперь разберёмся с <code>println!()</code>. Это вызов одного из <a href="macros.html">макросов</a>,
которыми представлено метапрограммирование в Rust. Если бы вместо макроса была
функция, это выглядело бы следующим образом: <code>println()</code> (без <code>!</code>). Позже мы
обсудим макросы Rust подробнее, а на данный момент всё, что вам нужно знать:
если вы видите <code>!</code>, то вызывается макрос вместо обычной функции.</p>
<p>Идём дальше. <code>&quot;Привет, мир!&quot;</code> — это «строка». Строки — это удивительно сложная
тема для системного языка программирования. Это <a href="the-stack-and-the-heap.html">статически расположенная в
памяти</a> строка. Мы передаём строку в качестве аргумента в
<code>println!</code>, который выводит строки на экран. Достаточно просто!</p>
<p>Строка заканчивается точкой с запятой (<code>;</code>). Rust — <a href="glossary.html#expression-oriented-language">язык с ориентацией на
выражения</a>, а это означает, что в нём большая
часть вещей является выражением. <code>;</code> используется для указания конца выражения и
начала следующего. Большинство строк кода на Rust заканчивается символом <code>;</code>.</p>
<h2><a class="header" href="#Компиляция-и-запуск-это-отдельные-шаги" id="Компиляция-и-запуск-это-отдельные-шаги">Компиляция и запуск это отдельные шаги</a></h2>
<p>В разделе «Написание и запуск программы на Rust» мы рассмотрели, как запустить
только что созданную программу. Теперь мы разберём каждый шаг по отдельности.</p>
<p>Перед запуском программы её нужно скомпилировать. Вы можете воспользоваться
компилятором Rust с помощью команды <code>rustc</code> и передать ваш файл, как показано
здесь:</p>
<pre><code class="language-bash">$ rustc main.rs
</code></pre>
<p>Если раньше вы программировали на С или С++, то заметите, что это напоминает
<code>gcc</code> или <code>clang</code>. После успешной компиляции Rust создаст двоичный исполняемый
файл. На Linux или OSX вы можете убедиться в этом с помощью команды <code>ls</code>:</p>
<pre><code class="language-bash">$ ls
main  main.rs
</code></pre>
<p>Или в Windows:</p>
<pre><code class="language-bash">$ dir
main.exe  main.rs
</code></pre>
<p>У нас есть два файла: файл с нашим исходным кодом, имеющий расширение <code>.rs</code>, и
исполняемый файл (<code>main.exe</code> в Windows, <code>main</code> в остальных случаях). Все, что
осталось сделать, — это запустить <code>main</code> или <code>main.exe</code>:</p>
<pre><code class="language-bash">$ ./main  # или main.exe на Windows
</code></pre>
<p>Мы вывели наш текст <code>&quot;Привет, мир!&quot;</code> в окне терминала.</p>
<p>Если раньше вы использовали динамические языки программирования вроде Ruby,
Python или JavaScript, то, возможно, разделение компиляции и запуска покажется
вам странным. Rust — это язык, на котором программы <em>компилируются перед
исполнением</em>. Это означает, что вы можете собрать программу, дать её кому-то
ещё, и ему не нужно устанавливать Rust для запуска этой программы. Если вы
передадите кому-нибудь <code>.rb</code>, <code>.py</code> или <code>.js</code> файл, им понадобится интерпретатор
Ruby, Python или JavaScript, чтобы скомпилировать и запустить вашу программу
(это делается одной командой). В мире языков программирования много
компромиссов, и Rust сделал свой выбор.</p>
<p>Использовать <code>rustc</code> удобно лишь для небольших программ, но по мере роста
проекта потребуется инструмент, который поможет управлять настройками проекта,
а также позволит проще делиться кодом с другими людьми и проектами. Далее мы
познакомимся с новым инструментом <code>Cargo</code>, который используется для написания
настоящих программ на Rust.</p>
<h1><a class="header" href="#Привет-cargo" id="Привет-cargo">Привет, Cargo!</a></h1>
<p>Cargo — это система сборки и пакетный менеджер для Rust, и Rustaceans используют
его для управления своими проектами на Rust. Cargo заботится о трёх вещах:
сборка кода, загрузка библиотек, от которых зависит ваш код, и сборка этих
библиотек. Библиотеки, которые нужны вашему коду, мы называем «зависимостями»
(&quot;dependencies&quot;), поскольку ваш код зависит от них.</p>
<p>Поначалу вашей программе не понадобится никаких зависимостей, поэтому будем
использовать только первую часть его возможностей. Со временем нам понадобится
добавить несколько зависимостей, и нам не составит труда сделать это, используя
Cargo.</p>
<p>Подавляющее количество проектов на Rust используют Cargo, поэтому в рамках этой
книги мы будем исходить из того, что вы тоже делаете это. Если вы использовали
официальный установщик, то Cargo установился вместе с Rust. Если же вы
установили Rust каким-либо другим образом, то вы можете проверить, есть ли у вас
Cargo, введя следующую команду в терминал:</p>
<pre><code class="language-bash">$ cargo --version
</code></pre>
<p>Если вы увидели номер версии, то все в порядке. Если же вы увидели сообщение об
ошибке наподобие &quot;<code>команда не найдена</code>&quot;, то вам нужно ознакомиться с
документацией для системы, в которой вы установили Rust.</p>
<h2><a class="header" href="#Переход-на-cargo" id="Переход-на-cargo">Переход на Cargo</a></h2>
<p>Давайте переведём наш проект «Привет, мир!» на использование Cargo. Для перехода
на Cargo нужно сделать три вещи:</p>
<ol>
<li>Расположить файл с исходным кодом в правильной директории.</li>
<li>Избавиться от старого исполняемого файла (<code>main.exe</code> или <code>main</code>) и сделать
новый.</li>
<li>Создать конфигурационный файл для Cargo.</li>
</ol>
<p>Давайте сделаем это!</p>
<h3><a class="header" href="#Создание-нового-исполняемого-файла-и-директории-с-исходным-кодом" id="Создание-нового-исполняемого-файла-и-директории-с-исходным-кодом">Создание нового исполняемого файла и директории с исходным кодом</a></h3>
<p>Для начала вернитесь к вашему терминалу, перейдите в вашу директорию
<em>hello_world</em> и введите следующие команды:</p>
<pre><code class="language-bash">$ mkdir src
$ mv main.rs src/main.rs
$ rm main  # или 'del main.exe' для Windows
</code></pre>
<p>Cargo ожидает, что ваши файлы с исходным кодом находятся в директории <em>src</em>.
Такой подход оставляет верхний уровень вашего проекта для вещей вроде README,
файлов с текстом лицензии и других не относящихся к вашему коду. Cargo помогает
нам сохранять наши проекты красивыми и аккуратными. Всему есть своё место, и всё
находится на своих местах.</p>
<p>Теперь скопируйте <em>main.rs</em> в директорию <em>src</em> и удалите скомпилированный файл,
который вы создали с помощью <code>rustc</code>.</p>
<p>Отметим, что поскольку мы создаём исполняемый файл, то мы используем <code>main.rs</code>.
Если бы мы хотели создать библиотеку, то мы использовали бы lib.rs. Cargo
использует это соглашение для успешной компиляции вашего проекта, но вы можете
это изменить, если захотите.</p>
<h3><a class="header" href="#Создание-конфигурационного-файла" id="Создание-конфигурационного-файла">Создание конфигурационного файла</a></h3>
<p>Теперь создайте новый файл внутри директории <em>hello_world</em> и назовите его
<code>Cargo.toml</code>.</p>
<p>Убедитесь в том, что имя правильное: вам нужна заглавная <code>C</code>! В противном случае
Cargo не найдёт конфигурационный файл.</p>
<p>Это файл в формате <a href="https://github.com/toml-lang/toml"><em>TOML</em></a><!-- ignore --> (Tom's Obvious, Minimal Language). TOML — это аналог
INI, но с некоторыми дополнениями, и он используется в конфигурационных файлах
для Cargo.</p>
<p>Поместите в данный файл следующие строки:</p>
<pre><code class="language-toml">[package]

name = &quot;hello_world&quot;
version = &quot;0.0.1&quot;
authors = [ &quot;Your name &lt;you@example.com&gt;&quot; ]
</code></pre>
<p>Первая строка, <code>[package]</code>, говорит о том, что следующие параметры отвечают за
настройку пакета. Когда нам понадобится добавить больше информации в этот файл,
мы создадим другие разделы, но сейчас нам достаточно настроек пакета.</p>
<p>Другие три строчки устанавливают три значения конфигурации, которые необходимы
Cargo для компиляции вашей программы: имя, версия и автор.</p>
<p>После того как вы добавили эту информацию в <em>Cargo.toml</em>, сохраните изменения.
На этом создание конфигурационного файла завершено.</p>
<h2><a class="header" href="#Сборка-и-запуск-cargo-проекта" id="Сборка-и-запуск-cargo-проекта">Сборка и запуск Cargo проекта</a></h2>
<p>Теперь, после создания файла <code>Cargo.toml</code> в корневой директории, мы готовы
приступить к сборке и запуску нашего проекта. Чтобы сделать это, введите
следующие команды:</p>
<pre><code class="language-bash">$ cargo build
   Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
$ ./target/debug/hello_world
Привет, мир!
</code></pre>
<p>Та-да! Мы собрали наш проект, вызвав <code>cargo build</code>, и запустили его с помощью
<code>./target/debug/hello_world</code>. Мы можем сделать это в один шаг, используя
<code>cargo run</code>:</p>
<pre><code class="language-bash">$ cargo run
     Running `target/debug/hello_world`
Привет, мир!
</code></pre>
<p>Заметьте, что сейчас мы не пересобрали наш проект. Cargo понял, что мы не
изменили файл с исходным кодом, и сразу запустил исполняемый файл. Если бы мы
изменили файл, мы бы увидели оба шага:</p>
<pre><code class="language-bash">$ cargo run
   Compiling hello_world v0.0.1 (file:///home/yourname/projects/hello_world)
     Running `target/debug/hello_world`
Привет, мир!
</code></pre>
<p>На первый взгляд это кажется сложнее, по сравнению с более простым
использованием <code>rustc</code>, но давайте подумаем о будущем: если в нашем проекте
будет больше одного файла, мы должны будем вызывать rustc для каждого из них и
передавать кучу параметров, чтобы собрать их вместе. С Cargo, когда наш проект
вырастет, нам понадобится вызвать только команду <code>cargo build</code>, и она всё
сделает за нас.</p>
<h2><a class="header" href="#Сборка-релизной-версии" id="Сборка-релизной-версии">Сборка релизной версии</a></h2>
<p>Когда вы закончите работать над проектом и он окончательно будет готов к
релизу, используйте команду <code>cargo build --release</code> для компиляции вашего
проекта с оптимизацией. Эти оптимизации делают ваш код на Rust быстрее, но
требуют больше времени на компиляцию. Именно из-за этого существует два разных
способа: один для разработки, другой для сборки финальной версии, которую вы
отдадите пользователям.</p>
<p>Также вы должны были заметить, что Cargo создал новый файл: <code>Cargo.lock</code>.</p>
<pre><code class="language-toml">[root]
name = &quot;hello_world&quot;
version = &quot;0.0.1&quot;
</code></pre>
<p>Этот файл используется Cargo для отслеживания зависимостей в вашем приложении.
Прямо сейчас у нас нет ни одной, поэтому этот файл немного пустоват. Вам не
нужно редактировать этот файл самостоятельно, Cargo сам с ним разберётся.</p>
<p>Вот и все! Мы успешно собрали <code>hello_world</code> с помощью Cargo.</p>
<p>Несмотря на то, что наша программа проста, мы использовали большую часть
реальных инструментов, которые вы будете использовать в своём дальнейшем пути
Rust-программиста. Более того, вы можете рассчитывать, что практически все
проекты на Rust можно будет собрать с помощью вариации этих команд:</p>
<pre><code class="language-bash">$ git clone someurl.com/foo
$ cd foo
$ cargo build
</code></pre>
<h2><a class="header" href="#Простой-способ-создать-новый-cargo-проект" id="Простой-способ-создать-новый-cargo-проект">Простой способ создать новый Cargo проект</a></h2>
<p>Вам не нужно повторять вышеприведённые шаги каждый раз, когда вы хотите создать
новый проект! Cargo может создать директорию проекта, в которой вы сразу сможете
приступить к разработке.</p>
<p>Чтобы создать новый проект с помощью Cargo, нужно ввести команду <code>cargo new</code>:</p>
<pre><code class="language-bash">$ cargo new hello_world --bin
</code></pre>
<p>Мы указываем аргумент <code>--bin</code>, так как хотим создать исполняемую программу. Если
мы не укажем этот аргумент, то Cargo создаст проект для библиотеки. Исполняемые
файлы часто называют <em>бинарниками</em> (поскольку обычно они находятся в
<code>/usr/bin</code>, если вы используете Unix систему).</p>
<p>Cargo сгенерировал два файла и одну директорию: <code>Cargo.toml</code> и директорию <em>src</em>
с файлом <em>main.rs</em>. Они должны выглядеть так же, как те, что мы создали ранее.</p>
<p>Этого достаточно для того, чтобы начать. Открыв <code>Cargo.toml</code>, вы должны увидеть
следующее:</p>
<pre><code class="language-toml">[package]

name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
</code></pre>
<p>Cargo наполнил этот файл значениями по умолчанию на основании переданных
аргументов и глобальной конфигурации <code>git</code>. Также он инициализировал
директорию <code>hello_world</code> как <code>git</code> репозиторий.</p>
<p>Вот что должно быть внутри <code>src/main.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Cargo создал «Hello World!» для нас, и вы уже можете приступить к
программированию!</p>
<blockquote>
<p>У Cargo есть собственное <a href="http://doc.crates.io/guide.html">руководство</a>, в котором про него рассказано
более детально.</p>
</blockquote>
<h1><a class="header" href="#Заключение" id="Заключение">Заключение</a></h1>
<p>Это основы, которые вы будете часто использовать на протяжении всего вашего
взаимодействия с Rust. Теперь давайте отложим инструментарий и узнаем больше о
самом языке.</p>
<p>У вас есть два пути: погрузиться в изучение реального проекта, открыв раздел
«<a href="learn-rust.html">Изучение Rust</a>», или начать с самого низа и постепенно продвигаться
наверх, начав с раздела «<a href="syntax-and-semantics.html">Синтаксис и семантика</a>». Программисты, имеющие
опыт работы с системными языками, вероятно, предпочтут «Изучение Rust», в то
время как программисты, имеющие опыт работы с динамическими языками, скорее
всего, захотят пойти по второму пути. Разные люди учатся по-разному! Выберите
то, что подходит именно вам.</p>
<p>% Изучение Rust</p>
<p>Добро пожаловать! Этот раздел книги содержит несколько глав, которые научат вас
создавать проекты на Rust. Вы также получите поверхностное представление о языке</p>
<ul>
<li>мы не будем сильно углубляться в детали.</li>
</ul>
<p>Если вы хотите более основательно изучить язык, читайте раздел
«<a href="syntax-and-semantics.html">Синтаксис и семантика</a>».</p>
<p>% Угадайка</p>
<p>В качестве нашего первого проекта мы решим классическую для начинающих
программистов задачу: игра-угадайка. Немного о том, как игра должна работать:
наша программа генерирует случайное целое число из промежутка от 1 до 100. Затем
она просит ввести число, которое она «загадала». Для каждого введённого нами
числа, она говорит, больше ли оно, чем «загаданное», или меньше. Игра
заканчивается когда мы отгадываем число. Звучит неплохо, не так ли?</p>
<h1><a class="header" href="#Создание-нового-проекта" id="Создание-нового-проекта">Создание нового проекта</a></h1>
<p>Давайте создадим новый проект. Перейдите в вашу директорию с проектами. Помните,
как мы создавали структуру директорий и <code>Cargo.toml</code> для <code>hello_world</code>? Cargo
может сделать это за нас. Давайте воспользуемся этим:</p>
<pre><code class="language-bash">$ cd ~/projects
$ cargo new guessing_game --bin
$ cd guessing_game
</code></pre>
<p>Мы сказали Cargo, что хотим создать новый проект с именем <code>guessing_game</code>. При
помощи флага <code>--bin</code> мы указали, что хотим создать исполняемый файл, а не
библиотеку.</p>
<p>Давайте посмотрим сгенерированный <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[package]

name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
</code></pre>
<p>Cargo взял эту информацию из вашего рабочего окружения. Если данные неверны,
исправьте их.</p>
<p>Наконец, Cargo создал программу «Привет, мир!». Загляните в файл <code>src/main.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Давайте попробуем скомпилировать созданный Cargo проект:</p>
<pre><code class="language-bash">$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
</code></pre>
<p>Замечательно! Снова откройте <code>src/main.rs</code>. Мы будем писать весь наш код в этом
файле.</p>
<p>Прежде чем мы начнём работу, давайте рассмотрим ещё одну команду Cargo: <code>run</code>.
<code>cargo run</code> похожа на <code>cargo build</code>, но после завершения компиляции она
запускает получившийся исполняемый файл:</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/debug/guessing_game`
Привет, мир!
</code></pre>
<p>Великолепно! Команда <code>run</code> помогает, когда надо быстро пересобрать проект. Наша
игра как раз и есть такой проект: нам требуется быстро тестировать каждое
изменение, прежде чем мы приступим к следующей части программы.</p>
<h1><a class="header" href="#Обработка-предположения" id="Обработка-предположения">Обработка предположения</a></h1>
<p>Давайте начнём! Первая вещь, которую мы должны сделать для нашей игры, — это
позволить игроку вводить предположения. Поместите следующий код в ваш
<code>src/main.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust no_run">use std::io;

fn main() {
    println!(&quot;Угадайте число!&quot;);

    println!(&quot;Пожалуйста, введите предположение.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Не удалось прочитать строку&quot;);

    println!(&quot;Ваша попытка: {}&quot;, guess);
}
</code></pre></pre>
<p>Здесь много чего! Давайте разберём этот участок по частям.</p>
<pre><code class="language-rust ignore">use std::io;
</code></pre>
<p>Нам надо получить то, что ввёл пользователь, а затем вывести результат на экран.
Значит нам понадобится библиотека <code>io</code> из стандартной библиотеки. Изначально
Rust импортирует в нашу программу лишь самые необходимые вещи — [<em>прелюдию</em>]
<a href="http://doc.rust-lang.org/std/prelude/index.html">prelude</a> (prelude). Если чего-то нет в прелюдии, мы должны при помощи
<code>use</code> явно указать, что хотим это использовать. Здесь также присутствует вторая
прелюдия — <a href="http://doc.rust-lang.org/std/io/prelude/index.html"><code>io</code>-прелюдия</a>; когда вы её импортируете,
она подключает ряд полезных вещей, связанных с <code>io</code>.</p>
<pre><code class="language-rust ignore">fn main() {
</code></pre>
<p>Как вы уже знаете, функция <code>main()</code> — это точка входа в нашу программу.
<code>fn</code> объявляет новую функцию. Пустые круглые скобки <code>()</code> показывают, что она не
принимает аргументов. Открывающая фигурная скобка <code>{</code> начинает тело нашей
функции. Из-за того, что мы не указали тип возвращаемого значения,
предполагается, что будет возвращаться <code>()</code> — пустой <a href="primitive-types.html#tuples">кортеж</a>.</p>
<pre><code class="language-rust ignore">    println!(&quot;Угадайте число!&quot;);

    println!(&quot;Пожалуйста, введите предположение.&quot;);
</code></pre>
<p>Мы уже изучили, что <code>println!()</code> — это <a href="macros.html">макрос</a>, который выводит
<a href="strings.html">строки</a> на экран.</p>
<pre><code class="language-rust ignore">    let mut guess = String::new();
</code></pre>
<p>Теперь интереснее! Как же много всего происходит в этой строке! Первая вещь, на
которую следует обратить внимание, — <a href="variable-bindings.html">выражение let</a>, которое используется
для <em>создания связи</em>. Оно выглядит так:</p>
<pre><code class="language-rust ignore">let foo = bar;
</code></pre>
<p>Это создаёт новую связь с именем <code>foo</code> и привязывает ей значение <code>bar</code>. Во
многих языках это называется <em>переменная</em>, но в Rust связывание переменных имеет
несколько трюков в рукаве.</p>
<p>Например, по умолчанию, связи <a href="mutability.html">неизменяемы</a>. По этой причине наш
пример использует <code>mut</code>: этот модификатор разрешает менять связь. С левой
стороны от присваивания у <code>let</code> может быть не просто имя связи, фактически он
принимает <a href="patterns.html">образец</a>. Мы будем использовать их дальше. Их достаточно
просто использовать:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let foo = 5; // неизменяемая связь
let mut bar = 5; // изменяемая связь
#}</code></pre></pre>
<p>Ах да, <code>//</code> начинает комментарий, который заканчивается в конце строки. Rust
игнорирует всё, что находится в <a href="comments.html">комментариях</a>.</p>
<p>Теперь мы знаем, что <code>let mut guess</code> объявляет изменяемую связь с именем
<code>guess</code>, а по другую сторону от <code>=</code> находится то, что будет привязано:
<code>String::new()</code>.</p>
<p><code>String</code> — это строковый тип, предоставляемый нам стандартной библиотекой.
<a href="http://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> — это текст в кодировке UTF-8 переменной длины.</p>
<p>Синтаксис <code>::new()</code> использует <code>::</code>, так как это привязанная к определённому
типу функция. То есть она привязана к самому типу <code>String</code>, а не к определённой
переменной типа <code>String</code>. Некоторые языки называют это «статическим методом».</p>
<p>Имя этой функции — <code>new()</code>, так как она создаёт новый, пустой экземпляр типа
<code>String</code>. Вы можете найти эту функцию у многих типов, потому что это общее имя
для создания нового значения определённого типа.</p>
<p>Давайте посмотрим дальше:</p>
<pre><code class="language-rust ignore">    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Не удалось прочитать строку&quot;);
</code></pre>
<p>Это уже побольше! Давайте это всё разберём. В первой строке есть две части.
Это первая:</p>
<pre><code class="language-rust ignore">io::stdin()
</code></pre>
<p>Помните, как мы импортировали (<code>use</code>) <code>std::io</code> в самом начале нашей программы?
Сейчас мы вызвали ассоциированную с ним функцию. Если бы мы не сделали <code>use std::io</code>, нам бы пришлось здесь написать <code>std::io::stdin()</code>.</p>
<p>Эта функция возвращает обработчик стандартного ввода нашего терминала. Более
подробно об этом можно почитать в <a href="http://doc.rust-lang.org/std/io/struct.Stdin.html"><code>std::io::Stdin</code></a>.</p>
<p>Следующая часть использует этот обработчик для получения всего, что введёт
пользователь:</p>
<pre><code class="language-rust ignore">.read_line(&amp;mut guess)
</code></pre>
<p>Здесь мы вызвали метод <a href="http://doc.rust-lang.org/std/io/struct.Stdin.html#method.read_line"><code>read_line()</code></a> обработчика. <a href="method-syntax.html">Методы</a>
похожи на ассоциированные функции, но доступны только у определённого экземпляра
типа, а не самого типа. Мы указали один аргумент функции <code>read_line()</code>: <code>&amp;mut guess</code>.</p>
<p>Помните, как мы выше привязали <code>guess</code>? Мы сказали, что эта ссылка изменяема.
Однако <code>read_line</code> не получает в качестве аргумента <code>String</code>: она получает <code>&amp;mut String</code>. В Rust есть такая особенность, называемая «<a href="references-and-borrowing.html"><em>ссылки</em></a>»,
которая позволяет нам иметь несколько ссылок на одни и те же данные, что
позволяет избежать излишнего их копирования. Ссылки — достаточно сложная
особенность, и одним из основных подкупающих достоинств Rust является то, как он
решает вопрос безопасности и простоты их использования. Пока что для завершения
программы нам не требуется разбираться в таких подробностях. Сейчас всё, что нам
нужно, — это знать, что ссылки, как и связывание при помощи <code>let</code>, неизменяемы
по умолчанию. Следовательно, мы должны написать <code>&amp;mut guess</code>, а не <code>&amp;guess</code>.</p>
<p>Почему <code>read_line()</code> получает изменяемую ссылку на строку? Его работа — это
взять то, что пользователь написал в стандартный ввод, и положить это в
строку. Итак, метод получает строку в качестве аргумента, и для того, чтобы
поместить в неё введённое значение, ссылка на данную строку должна быть
изменяемой.</p>
<p>Мы, однако, ещё не вполне разобрались с этой строкой кода. Хотя рассмотренный
фрагмент программы — просто одна строка её текста, он является лишь первой
частью одной <em>логической</em> строки кода. Посмотрим далее:</p>
<pre><code class="language-rust ignore">        .expect(&quot;Не удалось прочитать строку&quot;);
</code></pre>
<p>Когда мы вызываем метод, используя синтаксис <code>.foo()</code>, мы можем перенести вызов
в новую строку и сделать для него отступ. Это помогает разбивать длинные строки
на несколько. Мы <em>могли бы</em> сделать и так:</p>
<pre><code class="language-rust ignore">    io::stdin().read_line(&amp;mut guess).expect(&quot;Не удалось прочитать строку&quot;);
</code></pre>
<p>Однако это достаточно трудно читать. Поэтому мы разделили строку: по строке на
каждый вызов метода. Мы уже поговорили о <code>read_line()</code>, но ещё ничего не сказали
про <code>expect()</code>. Мы узнали, что <code>read_line()</code> помещает введённые пользователем
данные в ссылку <code>&amp;mut String</code>, которую мы передали методу в качестве аргумента.
Но данный метод также возвращает значение: в данном случае это экземпляр типа
<a href="http://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a>. В стандартной библиотеке Rust есть несколько типов
с именем <code>Result</code>: общая версия <a href="http://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> и несколько отдельных версий
в подбиблиотеках, например <code>io::Result</code>.</p>
<p>Назначение типов <code>Result</code> — преобразовывать информацию об ошибках, полученных
от обработчика. У значений типа <code>Result</code>, как и любого другого типа, есть
определённые для него методы. Так, у <code>io::Result</code> имеется <a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.expect">метод
<code>expect()</code></a>, который берёт значение, для которого был вызван этот метод,
и, если оно неудачное, выполняет <a href="error-handling.html"><code>panic!</code></a> со строкой, переданной методу
в качестве аргумента. <code>panic!</code> остановит нашу программу и выведет сообщение
об ошибке.</p>
<p>Если убрать вызовы этих двух методов, наша программа скомпилируется,
но компилятор выдаст следующее предупреждение:</p>
<pre><code class="language-bash">$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
src/main.rs:10:5: 10:39 warning: unused result which must be used,
#[warn(unused_must_use)] on by default
src/main.rs:10     io::stdin().read_line(&amp;mut guess);
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>
<p>Rust предупреждает, что мы не используем значение <code>Result</code>. Это предупреждение
пришло из специальной аннотации, которая указана в <code>io::Result</code>. Rust пытается
сказать нам, что мы не обрабатываем ошибки, которые могут возникнуть. Наиболее
правильным решением предотвращения ошибки будет её обработка. К счастью, если
мы только хотим обрушить приложение, когда возникает проблема, мы можем
использовать эти два небольших метода. Если мы можем восстановить что-либо
из ошибки, мы должны сделать кое-что другое, но мы оставим это для будущего
проекта.</p>
<p>Осталось разобрать всего одну строку из первого примера:</p>
<pre><code class="language-rust ignore">    println!(&quot;Ваша попытка: {}&quot;, guess);
}
</code></pre>
<p>Здесь выводится на экран строка, которая была получена с нашего ввода. <code>{}</code> —
это указатель места заполнения. В качестве второго аргумента макроса <code>println!</code>
мы указали значение <code>guess</code>, которое и будет подставлено вместо <code>{}</code>. Для вывода
нескольких значений мы могли бы использовать несколько указателей, по одному
на каждую привязку:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = 10;

println!(&quot;x и y: {} и {}&quot;, x, y);
#}</code></pre></pre>
<p>Просто.</p>
<p>Мы можем запустить то, что у нас есть, при помощи <code>cargo run</code>:</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/debug/guessing_game`
Угадайте число!
Пожалуйста, введите предположение.
6
Ваша попытка: 6
</code></pre>
<p>Всё правильно! Наша первая часть завершена: мы можем получать данные с
клавиатуры и потом печатать их на экран.</p>
<h1><a class="header" href="#Генерация-секретного-числа" id="Генерация-секретного-числа">Генерация секретного числа</a></h1>
<p>Далее, нам надо сгенерировать секретное число. В стандартной библиотеке Rust нет
ничего, что могло бы нам предоставить функционал для генерации случайных чисел.
Однако разработчики Rust для этого предоставили [<em>контейнер</em> (crate) <code>rand</code>]
<a href="https://crates.io/crates/rand">randcrate</a>. «Контейнер» — это пакет с кодом Rust. Наш проект — «бинарный
контейнер», из которого в итоге получится исполняемый файл. <code>rand</code> —
«библиотечный контейнер», который содержит код, предназначенный для
использования с другими программами.</p>
<p>Использование внешних контейнеров — задача для Cargo. Прежде чем мы начнём
писать код с использованием <code>rand</code>, мы должны модифицировать наш <code>Cargo.toml</code>.
Откроем его и добавим в конец следующие строчки:</p>
<pre><code class="language-toml">[dependencies]

rand=&quot;0.3.0&quot;
</code></pre>
<p>Раздел <code>[dependencies]</code> в <code>Cargo.toml</code> похож на раздел <code>[package]</code>: к нему
относится всё то, что помещено после строки объявления, вплоть до следующего
раздела. Cargo использует раздел зависимостей, чтобы знать, какие сторонние
контейнеры потребуются, а также какие их версии необходимы. В данном случае
мы используем версию <code>0.3.0</code>, под которой Cargo подразумевает любую версию,
совместимую с заданной. Cargo понимает [Семантическое версионирование]
<a href="http://semver.org/lang/ru">semver</a>, которое является стандартом нумерации версий. Простое указание номера,
как показано выше, является сокращением для <code>^0.3.0</code>, и обозначает «все версии,
совместимые с 0.3.0». Если мы хотим использовать только <code>0.3.0</code>, то можно
написать <code>rand=&quot;=0.3.0&quot;</code> (обратите внимание на два знака равенства). А если мы
хотим использовать последнюю версию контейнера, мы можем использовать <code>*</code>. Также
мы можем указать необходимый промежуток версий. В <a href="http://doc.crates.io/crates-io.html">документации Cargo</a>
вы найдёте больше информации.</p>
<p>Теперь, не совершив никаких изменений в коде нашей программы, давайте соберём
проект:</p>
<pre><code class="language-bash">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.8
 Downloading libc v0.1.6
   Compiling libc v0.1.6
   Compiling rand v0.3.8
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
</code></pre>
<p>(Конечно же, вы можете увидеть другие номера версий.)</p>
<p>Много нового! Теперь, когда у нас есть внешние зависимости, Cargo скачал
последние версии каждой из них из своего реестра, являющегося копией реестра с
<a href="https://crates.io">Crates.io</a>. Crates.io — это место, где программисты на Rust могут
публиковать свои проекты с открытым исходным кодом, чтобы их использовали в
других проектах.</p>
<p>После обновления реестра Cargo проверяет раздел <code>[dependencies]</code> и скачивает
всё, что нам необходимо. В нашем случае мы указали, что проект зависит от
<code>rand</code>. Самому контейнеру <code>rand</code> для работы нужен контейнер <code>libc</code>. По этой
причине Cargo скачал и <code>libc</code>. Загрузив библиотеки, Cargo компилирует их,
а затем собирает и наш проект.</p>
<p>Когда мы запустим <code>cargo build</code> снова, текст вывода будет уже другим:</p>
<pre><code class="language-bash">$ cargo build
</code></pre>
<p>Всё правильно, ничего не будет выведено! Cargo знает, и наш проект, и все его
зависимости уже собраны, и поэтому незачем делать это снова. Раз делать
ничего не надо, Cargo просто завершил работу. Если мы вновь откроем файл
<code>src/main.rs</code>, сделаем какие-нибудь изменения и затем сохраним их, мы увидим
только одну строку:</p>
<pre><code class="language-bash">$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
</code></pre>
<p>Итак, мы сказали Cargo, что нам нужна библиотека <code>rand</code> с любой версией ветки
<code>0.3.x</code>, и он взял последнюю версию на тот момент, когда его запустили, —
<code>v0.3.8</code>. Но что делать, когда на следующей неделе выйдет версия <code>v0.3.9</code>,
содержащая важные изменения? Что, если исправления настолько масштабны, что
версия <code>0.3.9</code> становится несовместимой с нашим кодом?</p>
<p>Решением этой проблемы является файл <code>Cargo.lock</code>, который находится в
директории с нашим проектом. Когда мы в первый раз собирали наш проект, Cargo
подобрал версии, подходящие под наши условия, и записал их в файл <code>Cargo.lock</code>.
Когда мы в будущем будем собирать наш проект, Cargo будет проверять, существует
ли <code>Cargo.lock</code>, и затем использовать указанные в нём версии контейнеров.
Благодаря этому мы автоматически получаем повторяемые сборки. Другими словами,
мы будем использовать контейнер версии <code>0.3.8</code> до тех пор, пока явно не обновим
информацию о его версии в <code>Cargo.lock</code>.</p>
<p>А что, если мы захотим использовать версию <code>v0.3.9</code>? У Cargo есть другая
команда, <code>update</code>, которая скажет Cargo: «Игнорируй Cargo.lock, найди и загрузи
последние версии библиотек из веток, указанных в Cargo.toml. Когда всё сделаешь,
запиши информацию о версиях в Cargo.lock». По умолчанию Cargo ищет только такую
версию, номер которой больше, чем <code>0.3.0</code>, и меньше, чем <code>0.4.0</code>. Если мы хотим
перейти на версии <code>0.4.x</code>, мы должны указать это в <code>Cargo.toml</code>. Потом, когда мы
запустим <code>cargo build</code>, Cargo обновит индекс и пересмотрит наши требования
к <code>rand</code>.</p>
<p>В <a href="http://doc.crates.io">документации</a> по Cargo можно узнать намного больше как о нём, так
и о <a href="http://doc.crates.io/crates-io.html">его экосистеме</a>, но сказанного выше нам пока хватит. Cargo
делает повторное использование библиотек намного проще, и программисты на Rust,
как правило, пишут небольшие проекты, которые входят в состав других, более
крупных, проектов.</p>
<p>Давайте наконец <em>использовать</em> <code>rand</code>. Вот наш следующий шаг:</p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Угадайте число!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Загаданное число: {}&quot;, secret_number);

    println!(&quot;Пожалуйста, введите предположение.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Не удалось прочитать строку&quot;);

    println!(&quot;Ваша попытка: {}&quot;, guess);
}
</code></pre>
<p>Первое, что мы сделали, — изменили первую строку. Теперь она выглядит так:
<code>extern crate rand</code>. Так как мы указали <code>rand</code> в разделе <code>[dependencies]</code>, мы
можем использовать <code>extern crate</code> для того, чтобы Rust знал, что мы собираемся
использовать эту зависимость. <code>extern crate</code> также выполняет эквивалент
оператора <code>use rand;</code>, т.е. теперь мы можем использовать всё, что есть в
контейнере <code>rand</code>, используя префикс <code>rand::</code>.</p>
<p>Далее, мы добавили новую строку <code>use</code>: <code>use rand::Rng</code>. Мы собираемся
использовать метод, а ему нужно, чтобы <code>Rng</code> был в области видимости. Основная
идея такова: методы, объявленные где-то в другом месте, называются «типажами»
(traits), и для того, чтобы этот метод можно было использовать, необходимо иметь
типаж в области видимости. Чтобы узнать об этом более подробно, вы можете
прочитать раздел о <a href="traits.html">типажах</a>.</p>
<p>Мы добавили две новые строки в середину кода:</p>
<pre><code class="language-rust ignore">    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Загаданное число: {}&quot;, secret_number);
</code></pre>
<p>Мы используем функцию <code>rand::thread_rng()</code> для получения копии генератора
случайных чисел, которая будет локальной для текущего <a href="concurrency.html">потока</a>
выполнения. Выше мы добавили <code>use rand::Rng</code> и теперь можем использовать метод
<code>gen_range()</code>. Этот метод получает два аргумента и генерирует число, которое
может быть больше либо равно первому аргументу и меньше, чем второй аргумент.
Таким образом, если мы укажем числа 1 и 101, то от генератора можно получить
числа от 1 до 100 включительно.</p>
<p>Вторая строка печатает наше секретное число. Это поможет нам во время
тестирования, пока мы разрабатываем нашу программу, но мы обязательно удалим
данную строчку в финальной версии. Будет неинтересно играть в игру, если она
сразу печатает ответ!</p>
<p>Давайте запустим изменённую программу:</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/debug/guessing_game`
Угадайте число!
Загаданное число: 7
Пожалуйста, введите предположение.
4
Ваша попытка: 4
$ cargo run
     Running `target/debug/guessing_game`
Угадайте число!
Загаданное число: 83
Пожалуйста, введите предположение.
5
Ваша попытка: 5
</code></pre>
<p>Замечательно! Следующий шаг — сравнение нашего предположения с «загаданным»
числом.</p>
<h1><a class="header" href="#Сравнение" id="Сравнение">Сравнение</a></h1>
<p>Теперь, когда мы знаем, что ввёл пользователь, давайте сравним «загаданное»
число с предполагаемым ответом. Здесь приведён наш следующий шаг, который, к
сожалению, не будет работать:</p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Угадайте число!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Загаданное число: {}&quot;, secret_number);

    println!(&quot;Пожалуйста, введите предположение.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Не удалось прочитать строку&quot;);

    println!(&quot;Ваша попытка: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less    =&gt; println!(&quot;Слишком маленькое!&quot;),
        Ordering::Greater =&gt; println!(&quot;Слишком большое!&quot;),
        Ordering::Equal   =&gt; println!(&quot;Вы выиграли!&quot;),
    }
}
</code></pre>
<p>Здесь мы видим что-то новое. Первое — это ещё один <code>use</code>. Мы ввели в область
видимости тип <code>std::cmp::Ordering</code>. Далее, ещё пять новых строк в конце, которые
используют его:</p>
<pre><code class="language-rust ignore">match guess.cmp(&amp;secret_number) {
    Ordering::Less    =&gt; println!(&quot;Слишком маленькое!&quot;),
    Ordering::Greater =&gt; println!(&quot;Слишком большое!&quot;),
    Ordering::Equal   =&gt; println!(&quot;Вы выиграли!&quot;),
}
</code></pre>
<p>Метод <code>cmp()</code> может быть вызван у чего-либо, что может сравниваться, и
получает в качестве аргумента ссылку на то, с чем мы хотим его сравнить.
Результатом сравнения будет значение типа <code>Ordering</code>, который мы импортировали
выше. Мы используем оператор <a href="match.html"><code>match</code></a> для определения <code>Ordering</code> —
результата сравнения. <code>Ordering</code> — <a href="enums.html"><code>перечисление</code></a>. Они обозначаются
<code>enum</code>, сокращённо от <code>enumeration</code> (перечисление). Перечисления выглядят
следующим образом:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Foo {
    Bar,
    Baz,
}
#}</code></pre></pre>
<p>С таким определением всё, что имеет тип <code>Foo</code> может иметь значение либо
<code>Foo::Bar</code>, либо <code>Foo::Baz</code>. Мы используем <code>::</code> для обозначения пространства
имён для вариантов перечисления.</p>
<p>У перечисления <a href="http://doc.rust-lang.org/std/cmp/enum.Ordering.html"><code>Ordering</code></a> есть три возможных варианта: <code>Less</code>,
<code>Equal</code> и <code>Greater</code>. Выражение <code>match</code> получает переменную какого-либо типа и
предлагает вам создать «ветви» для каждого возможного значения. Так как у нас
есть три возможных значения <code>Ordering</code>, у нас будет три ветви:</p>
<pre><code class="language-rust ignore">match guess.cmp(&amp;secret_number) {
    Ordering::Less    =&gt; println!(&quot;Слишком маленькое!&quot;),
    Ordering::Greater =&gt; println!(&quot;Слишком большое!&quot;),
    Ordering::Equal   =&gt; println!(&quot;Вы выиграли!&quot;),
}
</code></pre>
<p>Если результатом сравнения будет значение <code>Less</code>, мы выведем на экран <code>Слишком маленькое!</code>; если будет <code>Greater</code>, то <code>Слишком большое!</code>; и если <code>Equal</code>, то
<code>Вы выиграли!</code>. <code>match</code> очень удобен, и он часто используется в Rust.</p>
<p>Мы упоминали, что это не совсем корректный код, но всё же давайте попробуем:</p>
<pre><code class="language-bash">$ cargo build
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
src/main.rs:28:21: 28:35 error: mismatched types:
 expected `&amp;collections::string::String`,
    found `&amp;_`
(expected struct `collections::string::String`,
    found integral variable) [E0308]
src/main.rs:28     match guess.cmp(&amp;secret_number) {
                                   ^~~~~~~~~~~~~~
error: aborting due to previous error
Could not compile `guessing_game`.
</code></pre>
<p>У-у-у! Это большая ошибка. Суть этой ошибки в «несоответствии типов» (mismatched
types). В Rust строгая статическая система типов. Но в нём также есть вывод
типов. Когда мы пишем <code>let guess = String::new()</code>, Rust понимает, что <code>guess</code>
должна быть типа <code>String</code>, благодаря чему мы можем не указывать тип явно.
<code>secret_number</code> — число, которое может иметь значение от одного до ста.
Оно может иметь тип <code>i32</code> — 32-битное целое, или <code>u32</code> — 32-битное целое без
знака, или <code>i64</code> — 64-битное целое, или какой-нибудь другой. По умолчанию, Rust
сделает его 32-битным целым, <code>i32</code>. Однако здесь Rust не знает, как сравнить
<code>guess</code> и <code>secret_number</code>. Они должны быть одного типа. В итоге, чтобы можно
было сравнить <code>guess</code> и <code>secret_number</code>, мы должны преобразовать переменную
<code>guess</code>, которую мы прочитали с ввода, из типа <code>String</code> в настоящий числовой
тип. Мы можем сделать это, добавив несколько строчек. Вот как будет выглядеть
наша программа:</p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Угадайте число!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Загаданное число: {}&quot;, secret_number);

    println!(&quot;Пожалуйста, введите предположение.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Не удалось прочитать строку&quot;);

    let guess: u32 = guess.trim().parse()
        .expect(&quot;Пожалуйста, введите число!&quot;);

    println!(&quot;Ваша попытка: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less    =&gt; println!(&quot;Слишком маленькое!&quot;),
        Ordering::Greater =&gt; println!(&quot;Слишком большое!&quot;),
        Ordering::Equal   =&gt; println!(&quot;Вы выиграли!&quot;),
    }
}
</code></pre>
<p>Вот строки, которые мы добавили:</p>
<pre><code class="language-rust ignore">    let guess: u32 = guess.trim().parse()
        .expect(&quot;Пожалуйста, введите число!&quot;);
</code></pre>
<p>Подождите минутку, у нас ведь уже есть <code>guess</code>? Rust позволил нам «затенить»
(скрыть) предыдущее <code>guess</code> новым. Это часто используется в подобных случаях,
когда <code>guess</code> изначально бывает типа <code>String</code>, но нам требуется преобразовать её
в <code>u32</code>. Затенение позволяет нам переиспользовать имя <code>guess</code> вместо того, чтобы
создавать для значений разных типов уникальные имена (такие как <code>guess_str</code> и
<code>guess</code>).</p>
<p>Мы связали <code>guess</code> с выражением, похожим на написанное когда-то ранее:</p>
<pre><code class="language-rust ignore">guess.trim().parse()
</code></pre>
<p>Здесь <code>guess</code> ссылается на старый <code>guess</code>, который ещё является строкой,
полученной нами с ввода. Метод <code>trim()</code> у типа <code>String</code> удаляет все пробелы
из начала и конца нашей строки. Это важно, ведь для нормальной работы
<code>read_line()</code> нам необходимо нажать <code>Enter</code> по окончании ввода. Это значит,
что если мы наберём <code>5</code> и нажмём <code>Enter</code>, то <code>guess</code> будет выглядеть следующим
образом: <code>5\n</code>. Последовательность <code>\n</code> обозначает «новую строку» (newline) —
значение клавиши <code>Enter</code>. <code>trim()</code> удалит её и оставит только <code>5</code>. <a href="http://doc.rust-lang.org/std/primitive.str.html#method.parse">Метод
<code>parse()</code></a>, применяемый к строке, преобразует её в число. Он может
анализировать различные числа, но мы можем указать Rust, какой именно тип
нам нужен. Поэтому мы указали <code>let guess: u32</code>. Двоеточие <code>:</code>, идущее после
<code>guess</code>, говорит Rust, что мы указываем тип значения. <code>u32</code> — 32-битное
беззнаковое целое число. В Rust встроено <a href="primitive-types.html#numeric-types">несколько числовых типов</a>,
но мы выбрали именно <code>u32</code>. Это достаточно хороший тип, чтобы хранить небольшие
положительные числа.</p>
<p>Как и <code>read_line()</code>, вызов <code>parse()</code> может вызвать проблемы. Что, если наша
строка будет содержать <code>A👍%</code>? Мы не сможем преобразовать её в число. Как и в
случае с <code>read_line()</code>, мы будем использовать метод <code>expect()</code> на случай, если
<code>parse()</code> не сможет преобразовать строку.</p>
<p>Давайте запустим нашу программу!</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/guessing_game`
Угадайте число!
Загаданное число: 58
Пожалуйста, введите предположение.
  76
Ваша попытка: 76
Слишком большое!
</code></pre>
<p>Замечательно! Вы можете видеть, что мы добавили пробел перед нашим числом, но
программа поняла, что мы хотели сказать <code>76</code>. Запустим программу ещё несколько
раз и проверим, что загадывание числа работает.</p>
<p>Теперь большая часть нашей игры работает, но мы можем сделать только одно
предположение. Давайте изменим это, добавив циклы!</p>
<h1><a class="header" href="#Зацикливание" id="Зацикливание">Зацикливание</a></h1>
<p>Ключевое слово <code>loop</code> создаёт бесконечный цикл. Давайте добавим его:</p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Угадайте число!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Загаданное число: {}&quot;, secret_number);

    loop {
        println!(&quot;Пожалуйста, введите предположение.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .expect(&quot;Не удалось прочитать строку&quot;);

        let guess: u32 = guess.trim().parse()
            .expect(&quot;Пожалуйста, введите число!&quot;);

        println!(&quot;Ваша попытка: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Слишком маленькое!&quot;),
            Ordering::Greater =&gt; println!(&quot;Слишком большое!&quot;),
            Ordering::Equal   =&gt; println!(&quot;Вы выиграли!&quot;),
        }
    }
}
</code></pre>
<p>И посмотрим на работу приложения. Но подождите, мы же добавили бесконечный цикл?
Всё верно. Помните, что мы говорили о <code>parse()</code>? Если мы введём не числовой
ответ, то просто вызовем <code>panic!</code> и выйдем из программы. Посмотрите:</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/guessing_game`
Угадайте число!
Загаданное число: 59
Пожалуйста, введите предположение.
45
Ваша попытка: 45
Слишком маленькое!
Пожалуйста, введите предположение.
60
Ваша попытка: 60
Слишком большое!
Пожалуйста, введите предположение.
59
Ваша попытка: 59
Вы выиграли!
Пожалуйста, введите предположение.
quit
thread '&lt;main&gt;' panicked at 'Пожалуйста, введите число!'
</code></pre>
<p>Ха! Если мы введём <code>quit</code>, то действительно выйдем из программы. Как и при вводе
любого другого не числового значения. Что ж, это, мягко говоря, не очень хорошо.
Для начала давайте сделаем выход из программы, когда мы выиграли игру:</p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Угадайте число!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Загаданное число: {}&quot;, secret_number);

    loop {
        println!(&quot;Пожалуйста, введите предположение.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .expect(&quot;Не удалось прочитать строку&quot;);

        let guess: u32 = guess.trim().parse()
            .expect(&quot;Пожалуйста, введите число!&quot;);

        println!(&quot;Ваша попытка: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Слишком маленькое!&quot;),
            Ordering::Greater =&gt; println!(&quot;Слишком большое!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;Вы выиграли!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>С добавлением строки <code>break</code> после вывода <code>Вы выиграли!</code> мы получили
возможность выхода из цикла, когда мы угадали загаданное число. Выход из цикла
здесь также означает и завершение нашей программы, так как цикл — это последнее,
что есть в <code>main()</code>. Нам надо сделать ещё одно улучшение — при любом нечисловом
вводе мы не должны выходить из программы, мы просто должны проигнорировать ввод.
Мы можем сделать это следующим образом:</p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Угадайте число!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;Загаданное число: {}&quot;, secret_number);

    loop {
        println!(&quot;Пожалуйста, введите предположение.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .expect(&quot;Не удалось прочитать строку&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;Ваша попытка: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Слишком маленькое!&quot;),
            Ordering::Greater =&gt; println!(&quot;Слишком большое!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;Вы выиграли!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>Вот строка, которую мы изменили:</p>
<pre><code class="language-rust ignore">let guess: u32 = match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
</code></pre>
<p>Здесь показано, как мы можем перейти от «сбоя при ошибке» к «обработке ошибки»,
заменив <code>expect()</code> на инструкцию <code>match</code>. <code>Result</code>, возвращённый функцией
<code>parse()</code>, как и <code>Ordering</code>, является перечислением. Однако в данном случае
каждый из вариантов имеет некоторые ассоциированные с ним данные: <code>Ok</code> — успех,
<code>Err</code> — ошибку. У каждого есть некоторая дополнительная информация:
преобразованное число, либо тип ошибки. Здесь мы проверили значение результата
работы <code>parse()</code> при помощи <code>match</code>. В случае, если результат равен <code>Ok</code>, то
<code>match</code> привяжет внутреннее значение результата (<code>Ok(num)</code>) к имени <code>num</code> и
вернёт в привязку <code>guess</code>. Когда происходит ошибка (<code>Err</code>), нам не важно, какая
именно это ошибка, поэтому мы используем вместо имени <code>_</code>. Так мы проигнорируем
ошибку и вызовем <code>continue</code>, что отправит нас на следующую итерацию цикла.</p>
<p>Теперь всё должно быть нормально! Давайте посмотрим:</p>
<pre><code class="language-bash">$ cargo run
   Compiling guessing_game v0.1.0 (file:///home/you/projects/guessing_game)
     Running `target/guessing_game`
Угадайте число!
Загаданное число: 61
Пожалуйста, введите предположение.
10
Ваша попытка: 10
Слишком маленькое!
Пожалуйста, введите предположение.
99
Ваша попытка: 99
Слишком большое!
Пожалуйста, введите предположение.
foo
Пожалуйста, введите предположение.
61
Ваша попытка: 61
Вы выиграли!
</code></pre>
<p>Замечательно! Если мы ещё чуть-чуть подкрутим нашу программу, игра будет готова.
Догадываетесь, что нужно поменять? Всё правильно, мы не должны выводить наше
секретное число. Знание этого числа хорошо для тестирования, но оно портит всю
игру. Так выглядит окончательный вариант нашего кода:</p>
<pre><code class="language-rust ignore">extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Угадайте число!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Пожалуйста, введите предположение.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .expect(&quot;Не удалось прочитать строку&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;Ваша попытка: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less    =&gt; println!(&quot;Слишком маленькое!&quot;),
            Ordering::Greater =&gt; println!(&quot;Слишком большое!&quot;),
            Ordering::Equal   =&gt; {
                println!(&quot;Вы выиграли!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<h1><a class="header" href="#Готово" id="Готово">Готово!</a></h1>
<p>Вы сделали «Угадайку»! Поздравляем!</p>
<p>Этот первый проект показал вам многое: <code>let</code>, <code>match</code>, методы, ассоциированные
функции, использование внешних контейнеров и многое другое. Наш следующий проект
покажет ещё больше.</p>
<p>% Обедающие философы</p>
<p>Для нашего второго проекта мы выбрали классическую задачу с параллелизмом. Она
называется «Обедающие философы». Задача была сформулирована в 1965 году Эдсгером
Дейкстрой, но мы будем использовать версию задачи, <a href="http://www.usingcsp.com/cspbook.pdf">адаптированную</a> в
1985 году Ричардом Хоаром.</p>
<blockquote>
<p>В древние времена богатые филантропы пригласили погостить пятерых выдающихся
философов. Им выделили каждому по комнате, в которой они могли заниматься
своей профессиональной деятельностью — мышлением. Также была общая столовая,
где стоял большой круглый стол, а вокруг него пять стульев. Каждый стул имел
табличку с именем философа, который должен был сидеть на нем. Слева от каждого
философа лежала золотая вилка, а в центре стола стояла большая миска со
спагетти, которая постоянно пополнялась. Как подобает философам, они большую
часть своего времени проводили в раздумьях. Но однажды они почувствовали голод
и отправились в столовую. Каждый сел на свой стул, взял по вилке и воткнул её
в миску со спагетти. Но сущность запутанных спагетти такова, что необходима
вторая вилка, чтобы отправлять спагетти в рот. То есть философу требовалась
ещё и вилка справа от него. Философы положили свои вилки и встали из-за стола,
продолжая думать. Ведь вилка может быть использована только одним философом
одновременно. Если другой философ захочет её взять, то ему придётся ждать
когда она освободится.</p>
</blockquote>
<p>Эта классическая задача показывает различные элементы параллелизма. Сложность
реализации задачи состоит в том, что простая реализация может зайти в
безвыходное состояние. Давайте рассмотрим простой пример решения этой проблемы:</p>
<ol>
<li>Философ берет вилку в свою левую руку.</li>
<li>Затем берет вилку в свою правую руку.</li>
<li>Ест.</li>
<li>Кладёт вилки на место.</li>
</ol>
<p>Теперь представим это как последовательность действий философов:</p>
<ol>
<li>Философ 1 начинает выполнять алгоритм, берет вилку в левую руку.</li>
<li>Философ 2 начинает выполнять алгоритм, берет вилку в левую руку.</li>
<li>Философ 3 начинает выполнять алгоритм, берет вилку в левую руку.</li>
<li>Философ 4 начинает выполнять алгоритм, берет вилку в левую руку.</li>
<li>Философ 5 начинает выполнять алгоритм, берет вилку в левую руку.</li>
<li>...? Все вилки заняты и никто не может начать есть! Безвыходное состояние.</li>
</ol>
<p>Есть различные пути решения этой задачи. Мы в этом руководстве покажем своё
решение. Сначала давайте создадим проект с помощью <code>cargo</code>:</p>
<pre><code class="language-bash">$ cd ~/projects
$ cargo new dining_philosophers --bin
$ cd dining_philosophers
</code></pre>
<p>Теперь мы можем начать моделирование задачи. Начнём с философов в <code>src/main.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">struct Philosopher {
    name: String,
}

impl Philosopher {
    fn new(name: &amp;str) -&gt; Philosopher {
        Philosopher {
            name: name.to_string(),
        }
    }
}

fn main() {
    let p1 = Philosopher::new(&quot;Джудит Батлер&quot;);
    let p2 = Philosopher::new(&quot;Рая Дунаевская&quot;);
    let p3 = Philosopher::new(&quot;Зарубина Наталья&quot;);
    let p4 = Philosopher::new(&quot;Эмма Гольдман&quot;);
    let p5 = Philosopher::new(&quot;Анна Шмидт&quot;);
}
</code></pre></pre>
<p>Здесь мы создаём <a href="structs.html"><code>struct</code></a>, представляющую философа. На данный момент
нам нужно всего лишь имя. Мы выбрали тип <a href="strings.html"><code>String</code></a>, а не <code>&amp;str</code> для
хранения имени. Обычно проще работать с типом, владеющим данными, чем с типом,
использующим ссылки.</p>
<p>Продолжим:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Philosopher {
#     name: String,
# }
impl Philosopher {
    fn new(name: &amp;str) -&gt; Philosopher {
        Philosopher {
            name: name.to_string(),
        }
    }
}
#}</code></pre></pre>
<p>Этот блок <code>impl</code> позволяет объявить что-либо для структуры <code>Philosopher</code>. В
нашем случае мы объявляем «статическую функцию» <code>new</code>. Первая строка этой
функции выглядит так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Philosopher {
#     name: String,
# }
# impl Philosopher {
fn new(name: &amp;str) -&gt; Philosopher {
#         Philosopher {
#             name: name.to_string(),
#         }
#     }
# }
#}</code></pre></pre>
<p>Она принимает один аргумент, <code>name</code>, типа <code>&amp;str</code>. Это ссылка на другую строку.
Она возвращает новый экземпляр нашей структуры <code>Philosopher</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Philosopher {
#     name: String,
# }
# impl Philosopher {
#    fn new(name: &amp;str) -&gt; Philosopher {
Philosopher {
    name: name.to_string(),
}
#     }
# }
#}</code></pre></pre>
<p>Этот код создаёт новый экземпляр <code>Philosopher</code> и присваивает его полю <code>name</code>
значение переданного аргумента <code>name</code>. Но используется не сам аргумент, а
результат вызова его метода <code>.to_string()</code>. Этот вызов создаёт копию строки, на
которую указывает наш <code>&amp;str</code>, и возвращает новый экземпляр <code>String</code>, который и
будет присвоен полю <code>name</code> структуры <code>Philosopher</code>.</p>
<p>Почему бы сразу не передавать строку типа <code>String</code> напрямую? Так легче её
вызывать. Если бы мы принимали тип <code>String</code>, а тот, кто вызывает функцию, имел
бы ссылку на строку, <code>&amp;str</code>, то ему пришлось бы приводить её к типу <code>String</code>
перед каждым вызовом. Это уменьшит гибкость кода, и мы будем вынуждены <em>каждый
раз</em> создавать копию строки. Для этой небольшой программы это не очень важно,
так как мы знаем, что будем использовать только короткие строки.</p>
<p>И последнее на что следует обратить внимание: мы просто объявляем структуру
<code>Philosopher</code> и кажется, что ничего больше не делаем. Rust — это язык
программирования, «ориентированный на выражения», что означает, что каждое
выражение возвращает значение. Это верно и для функций, у которых автоматически
возвращается последнее выражение. Так как в нашем примере в последнем выражении
функции мы создаём структуру <code>Philosopher</code>, то она и будет возвращена функцией.</p>
<p>Имя функции <code>new()</code> не регламентируется Rust. Это просто соглашение об
именовании функций, которые возвращают новые экземпляры структур. Давайте снова
посмотрим на функцию <code>main()</code>:</p>
<pre><pre class="playpen"><code class="language-rust"># struct Philosopher {
#     name: String,
# }
#
# impl Philosopher {
#     fn new(name: &amp;str) -&gt; Philosopher {
#         Philosopher {
#             name: name.to_string(),
#         }
#     }
# }
#
fn main() {
    let p1 = Philosopher::new(&quot;Джудит Батлер&quot;);
    let p2 = Philosopher::new(&quot;Рая Дунаевская&quot;);
    let p3 = Philosopher::new(&quot;Зарубина Наталья&quot;);
    let p4 = Philosopher::new(&quot;Эмма Гольдман&quot;);
    let p5 = Philosopher::new(&quot;Анна Шмидт&quot;);
}
</code></pre></pre>
<p>Здесь мы связываем пять имён переменных с пятью новыми философами. Если бы
мы <em>не объявили</em> свою реализацию функции <code>new()</code>, то наш код выглядел бы так:</p>
<pre><pre class="playpen"><code class="language-rust"># struct Philosopher {
#     name: String,
# }
fn main() {
    let p1 = Philosopher { name: &quot;Джудит Батлер&quot;.to_string() };
    let p2 = Philosopher { name: &quot;Рая Дунаевская&quot;.to_string() };
    let p3 = Philosopher { name: &quot;Зарубина Наталья&quot;.to_string() };
    let p4 = Philosopher { name: &quot;Эмма Гольдман&quot;.to_string() };
    let p5 = Philosopher { name: &quot;Анна Шмидт&quot;.to_string() };
}
</code></pre></pre>
<p>Этот код выглядит не слишком изящно. Использование статической функции <code>new</code>
имеет и другие преимущества, но даже в этом простом случае, её использование
было оправдано.</p>
<p>Теперь у нас уже есть каркас программы, и можно заняться решением задачи с
обедающими философами. Начнём с конца: сделаем так, чтобы философ сообщал нам,
когда он закончит есть. Для этого потребуется метод, сообщающий нам об окончании
приёма пищи, и цикл, запускающий этот метод для каждого философа.</p>
<pre><pre class="playpen"><code class="language-rust">struct Philosopher {
    name: String,
}

impl Philosopher {
    fn new(name: &amp;str) -&gt; Philosopher {
        Philosopher {
            name: name.to_string(),
        }
    }

    fn eat(&amp;self) {
        println!(&quot;{} закончила есть.&quot;, self.name);
    }
}

fn main() {
    let philosophers = vec![
        Philosopher::new(&quot;Джудит Батлер&quot;),
        Philosopher::new(&quot;Рая Дунаевская&quot;),
        Philosopher::new(&quot;Зарубина Наталья&quot;),
        Philosopher::new(&quot;Эмма Гольдман&quot;),
        Philosopher::new(&quot;Анна Шмидт&quot;),
    ];

    for p in &amp;philosophers {
        p.eat();
    }
}
</code></pre></pre>
<p>Давайте сначала рассмотрим функцию <code>main()</code>. Вместо того чтобы создавать пять
отдельных связанных имён для философов, мы создаём для них <code>Vec&lt;T&gt;</code>. <code>Vec&lt;T&gt;</code>
называют «вектор», он является расширяемой версией массива. Затем в цикле
<a href="loops.html#for"><code>for</code></a> мы перебираем вектор, получая ссылку на очередного философа на
каждой итерации.</p>
<p>В теле цикла мы вызываем метод <code>p.eat()</code>, который объявлен выше:</p>
<pre><code class="language-rust ignore">fn eat(&amp;self) {
    println!(&quot;{} закончила есть.&quot;, self.name);
}
</code></pre>
<p>В Rust методы явно получают параметр <code>self</code>. Вот почему <code>eat()</code> является
методом, а <code>new</code> — статической функцией: <code>new()</code> не получает параметр <code>self</code>.
Для нашей первой версии метода <code>eat()</code> мы выводим только имя философа и
сообщение о том, что он закончил есть. Запустив эту программу вы получите:</p>
<pre><code class="language-text">Джудит Батлер закончила есть.
Рая Дунаевская закончила есть.
Зарубина Наталья закончила есть.
Эмма Гольдман закончила есть.
Анна Шмидт закончила есть.
</code></pre>
<p>Это было не сложно! Осталось чуть-чуть и приступим к самой задаче.</p>
<p>Дальше нам нужно сделать так, чтобы философы не только заканчивали, но и
начинали есть. Это новая версия программы:</p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::time::Duration;

struct Philosopher {
    name: String,
}

impl Philosopher {
    fn new(name: &amp;str) -&gt; Philosopher {
        Philosopher {
            name: name.to_string(),
        }
    }

    fn eat(&amp;self) {
        println!(&quot;{} начала есть.&quot;, self.name);

        thread::sleep(Duration::from_millis(1000));

        println!(&quot;{} закончила есть.&quot;, self.name);
    }
}

fn main() {
    let philosophers = vec![
        Philosopher::new(&quot;Джудит Батлер&quot;),
        Philosopher::new(&quot;Рая Дунаевская&quot;),
        Philosopher::new(&quot;Зарубина Наталья&quot;),
        Philosopher::new(&quot;Эмма Гольдман&quot;),
        Philosopher::new(&quot;Анна Шмидт&quot;),
    ];

    for p in &amp;philosophers {
        p.eat();
    }
}
</code></pre></pre>
<p>Появились некоторые небольшие изменения. Давайте посмотрим, что же изменилось:</p>
<pre><code class="language-rust ignore">use std::thread;
</code></pre>
<p>Конструкция <code>use</code> предоставляет доступ к области видимости модуля <code>thread</code> из
стандартной библиотеки. Мы собираемся использовать этот модуль далее в коде, и
поэтому нам нужно объявить о его использовании.</p>
<pre><code class="language-rust ignore">    fn eat(&amp;self) {
        println!(&quot;{} начала есть.&quot;, self.name);

        thread::sleep(Duration::from_millis(1000));

        println!(&quot;{} закончила есть.&quot;, self.name);
    }
</code></pre>
<p>Здесь мы выводим на экран два сообщения и вызываем функцию <code>sleep</code> между
ними. Эта функция останавливает рабочий поток на 1000 миллисекунд, что
симулирует процесс приёма пищи философа.</p>
<p>Если вы запустите программу теперь, то увидите, что каждый философ, по очереди,
начинает есть, ест какое-то время и заканчивает есть:</p>
<pre><code class="language-text">Джудит Батлер начала есть.
Джудит Батлер закончила есть.
Рая Дунаевская начала есть.
Рая Дунаевская закончила есть.
Зарубина Наталья начала есть.
Зарубина Наталья закончила есть.
Эмма Гольдман начала есть.
Эмма Гольдман закончила есть.
Анна Шмидт начала есть.
Анна Шмидт закончила есть.
</code></pre>
<p>Превосходно! Теперь у нас осталась только одна проблема: наши философы едят по
очереди, а не одновременно, то есть мы пока не решили задачу параллелизма.</p>
<p>Для того, чтобы наши философы начали есть одновременно, нам нужно внести
некоторые изменения в код:</p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::time::Duration;

struct Philosopher {
    name: String,
}

impl Philosopher {
    fn new(name: &amp;str) -&gt; Philosopher {
        Philosopher {
            name: name.to_string(),
        }
    }

    fn eat(&amp;self) {
        println!(&quot;{} начала есть.&quot;, self.name);

        thread::sleep(Duration::from_millis(1000));

        println!(&quot;{} закончила есть.&quot;, self.name);
    }
}

fn main() {
    let philosophers = vec![
        Philosopher::new(&quot;Джудит Батлер&quot;),
        Philosopher::new(&quot;Рая Дунаевская&quot;),
        Philosopher::new(&quot;Зарубина Наталья&quot;),
        Philosopher::new(&quot;Эмма Гольдман&quot;),
        Philosopher::new(&quot;Анна Шмидт&quot;),
    ];

    let handles: Vec&lt;_&gt; = philosophers.into_iter().map(|p| {
        thread::spawn(move || {
            p.eat();
        })
    }).collect();

    for h in handles {
        h.join().unwrap();
    }
}
</code></pre></pre>
<p>Мы добавили ещё один цикл в функцию <code>main()</code>. Теперь она выглядит так:</p>
<pre><code class="language-rust ignore">let handles: Vec&lt;_&gt; = philosophers.into_iter().map(|p| {
    thread::spawn(move || {
        p.eat();
    })
}).collect();
</code></pre>
<p>Тут добавились трудные к пониманию пять строк кода. Давайте разбираться.</p>
<pre><code class="language-rust ignore">let handles: Vec&lt;_&gt; =
</code></pre>
<p>Объявляем новое связанное имя <code>handles</code>. Мы задали такое имя, потому что
собираемся создать несколько потоков, в результате чего получим для них
дескрипторы, с помощью которых сможем контролировать их выполнение. Здесь нам
нужно явно указать тип, а зачем это необходимо, мы расскажем чуть позже. <code>_</code> -
это заполнитель типа. Мы говорим компилятору «<code>handles</code> — это вектор, содержащий
элементы, тип которых Rust должен вывести самостоятельно».</p>
<pre><code class="language-rust ignore">philosophers.into_iter().map(|p| {
</code></pre>
<p>Мы берём наш список философов и вызываем метод <code>into_iter()</code>. Этот метод создаёт
итератор, который при каждой итерации забирает право владения на соответствующий
элемент. Это нужно для передачи элемента вектора в поток. Мы берём этот итератор
и вызываем метод <code>map</code>, который принимает замыкание в качестве аргумента и
вызывает это замыкание для каждого из элементов итератора.</p>
<pre><code class="language-rust ignore">    thread::spawn(move || {
        p.eat();
    })
</code></pre>
<p>Вот здесь происходит сам параллелизм. Функция <code>thread::spawn</code> принимает в
качестве аргумента замыкание и исполняет это замыкание в новом потоке. Это
замыкание дополнительно нуждается в указании ключевого слова <code>move</code>, которое
сообщает, что это замыкание получает владение переменными, которые оно
захватывает. В данном случае — переменной <code>p</code> функции <code>map</code>.</p>
<p>Внутри потока мы всего лишь вызываем метод <code>eat()</code> переменной <code>p</code>. Также
обратите внимание, что вызов <code>thread::spawn</code> не оканчивается точкой с запятой,
что превращает его в выражение. Этот нюанс важен, так как возвращается
правильное значение. Для получения более подробной информации, прочитайте главу
<a href="functions.html#expressions-vs-statements">Выражения и операторы</a>.</p>
<pre><code class="language-rust ignore">}).collect();
</code></pre>
<p>По завершении мы получаем результат вызова <code>map</code> и собираем полученный результат
в коллекцию с помощью метода <code>collect()</code>. Метод <code>collect()</code> создаёт коллекцию
какого-то типа, и для того, чтобы Rust понял, коллекцию какого типа мы хотим
получить, мы указали для <code>handle</code> тип принимаемого значения <code>Vec&lt;T&gt;</code>. Элементами
коллекции будут возвращаемые из методов <code>thread::spawn</code> значения, которые
являются дескрипторами этих потоков. Вот так!</p>
<pre><code class="language-rust ignore">for h in handles {
    h.join().unwrap();
}
</code></pre>
<p>В конце функции <code>main()</code> мы в цикле перебираем каждый дескриптор и вызываем для
него метод <code>join()</code>, который блокирует дальнейшее исполнение основного потока,
пока не завершится дочерний поток. Это позволяет нам быть уверенными, что потоки
завершат работу до того как произойдёт выход из программы.</p>
<p>Если вы запустите эту программу, то вы увидите, что философы едят не дожидаясь
своей очереди! У нас многопоточность!</p>
<pre><code class="language-text">Джудит Батлер начала есть.
Рая Дунаевская начала есть.
Зарубина Наталья начала есть.
Эмма Гольдман начала есть.
Анна Шмидт начала есть.
Джудит Батлер закончила есть.
Рая Дунаевская закончила есть.
Зарубина Наталья закончила есть.
Эмма Гольдман закончила есть.
Анна Шмидт закончила есть.
</code></pre>
<p>Но как же быть с вилками? Их мы пока ещё не смоделировали.</p>
<p>Давайте же начнём. Сначала сделаем новую структуру:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::sync::Mutex;

struct Table {
    forks: Vec&lt;Mutex&lt;()&gt;&gt;,
}
#}</code></pre></pre>
<p>Структура <code>Table</code> содержит вектор мьютексов (<code>Mutex</code>). Мьютекс — способ
управления доступом к данным для параллельно выполняющихся потоков: только один
поток может получить доступ к данным в конкретный момент времени. Это именно то
свойство, которое нужно для реализации наших вилок. В коде мы используем пустой
кортеж, <code>()</code>, внутри мьютекса, так как не собираемся использовать это значение,
а мьютекс используется только для организации доступа.</p>
<p>Давайте изменим программу, используя структуру <code>Table</code>:</p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::time::Duration;
use std::sync::{Mutex, Arc};

struct Philosopher {
    name: String,
    left: usize,
    right: usize,
}

impl Philosopher {
    fn new(name: &amp;str, left: usize, right: usize) -&gt; Philosopher {
        Philosopher {
            name: name.to_string(),
            left: left,
            right: right,
        }
    }

    fn eat(&amp;self, table: &amp;Table) {
        let _left = table.forks[self.left].lock().unwrap();
        thread::sleep(Duration::from_millis(150));
        let _right = table.forks[self.right].lock().unwrap();

        println!(&quot;{} начала есть.&quot;, self.name);

        thread::sleep(Duration::from_millis(1000));

        println!(&quot;{} закончила есть.&quot;, self.name);
    }
}

struct Table {
    forks: Vec&lt;Mutex&lt;()&gt;&gt;,
}

fn main() {
    let table = Arc::new(Table { forks: vec![
        Mutex::new(()),
        Mutex::new(()),
        Mutex::new(()),
        Mutex::new(()),
        Mutex::new(()),
    ]});

    let philosophers = vec![
        Philosopher::new(&quot;Джудит Батлер&quot;, 0, 1),
        Philosopher::new(&quot;Рая Дунаевская&quot;, 1, 2),
        Philosopher::new(&quot;Зарубина Наталья&quot;, 2, 3),
        Philosopher::new(&quot;Эмма Гольдман&quot;, 3, 4),
        Philosopher::new(&quot;Анна Шмидт&quot;, 0, 4),
    ];

    let handles: Vec&lt;_&gt; = philosophers.into_iter().map(|p| {
        let table = table.clone();

        thread::spawn(move || {
            p.eat(&amp;table);
        })
    }).collect();

    for h in handles {
        h.join().unwrap();
    }
}
</code></pre></pre>
<p>Много изменений! Однако, с этими изменениями мы получили корректно работающую
программу. Приступим к рассмотрению:</p>
<pre><code class="language-rust ignore">use std::sync::{Mutex, Arc};
</code></pre>
<p>Нам далее понадобится структура <code>Arc&lt;T&gt;</code> из модуля стандартной библиотеки
<code>std::sync</code>. Мы поговорим о ней чуть позже.</p>
<pre><code class="language-rust ignore">struct Philosopher {
    name: String,
    left: usize,
    right: usize,
}
</code></pre>
<p>Нам понадобилось добавить ещё два поля в нашу структуру <code>Philosopher</code>. Каждый
философ должен иметь две вилки: одну — для левой руки, другую — для правой руки.
Мы используем тип <code>usize</code> для идентификации каждой вилки. Мы используем его при
создании философа, передавая идентификаторы двух вилок. Эти два значения будут
использоваться полем <code>forks</code> структуры <code>Table</code>.</p>
<pre><code class="language-rust ignore">fn new(name: &amp;str, left: usize, right: usize) -&gt; Philosopher {
    Philosopher {
        name: name.to_string(),
        left: left,
        right: right,
    }
}
</code></pre>
<p>Мы используем функцию <code>new()</code> для задания значений <code>left</code> и <code>right</code>.</p>
<pre><code class="language-rust ignore">fn eat(&amp;self, table: &amp;Table) {
    let _left = table.forks[self.left].lock().unwrap();
    thread::sleep(Duration::from_millis(150));
    let _right = table.forks[self.right].lock().unwrap();

    println!(&quot;{} начала есть.&quot;, self.name);

    thread::sleep(Duration::from_millis(1000));

    println!(&quot;{} закончила есть.&quot;, self.name);
}
</code></pre>
<p>Здесь появились три новые строки. Мы добавили один аргумент, <code>table</code>. Мы
получаем доступ к списку вилок через структуру <code>Table</code>. Затем используем
идентификаторы вилок <code>self.left</code> и <code>self.right</code> для получения доступа к вилке по
определённому индексу. В результате чего мы получаем <code>Mutex</code>, который регулирует
доступ к вилке, и вызываем для него метод <code>lock()</code>, блокируя доступ к вилке.
Если в настоящее время доступ к вилке уже предоставлен кому-то ещё, то мы будем
блокированы, пока вилка не станет доступной. Мы также вызываем <code>thread::sleep</code>
между взятием первой и второй вилки, поскольку этот процесс не моментален.</p>
<p>Вызов метода <code>lock()</code> может потерпеть неудачу, и если это случается, то мы
аварийно завершаем работу программы. Может возникнуть ситуация, когда поток
аварийно завершит свою работу, а мьютекс при этом останется заблокированным.
Такой мьютекс называется «<a href="https://doc.rust-lang.org/stable/std/sync/struct.Mutex.html#poisoning">отравленным (poisoned)</a>». Но в нашем случае
это не может произойти, потому как мы просто используем метод <code>unwrap()</code>.</p>
<p>Результаты выполнения этих двух строк имеют имена <code>_left</code> и <code>_right</code>
соответственно. Зачем мы используем знаки подчёркивания в начале имён? Это для
того, чтобы сказать компилятору, что мы хотим получить значения, которые далее
<em>не планируем использовать</em>. Таким образом Rust не будет выводить предупреждение
о неиспользуемых именах.</p>
<p>Когда же мьютекс будет освобождён? Это произойдёт автоматически, когда <code>_left</code> и
<code>_right</code> выйдут из области видимости, то есть по окончании работы функции.</p>
<pre><code class="language-rust ignore">    let table = Arc::new(Table { forks: vec![
        Mutex::new(()),
        Mutex::new(()),
        Mutex::new(()),
        Mutex::new(()),
        Mutex::new(()),
    ]});
</code></pre>
<p>Далее в <code>main()</code> мы создаём новый экземпляр структуры <code>Table</code> и оборачиваем его
в <code>Arc&lt;T&gt;</code>. Это «атомарный счётчик ссылок» (atomic reference count). Он нужен
для обеспечения доступа к нашей структуре <code>Table</code> из нескольких потоков. Когда
он передаётся в новый поток, то счётчик увеличивается, а когда этот поток
завершает работу, то счётчик уменьшается.</p>
<pre><code class="language-rust ignore">let philosophers = vec![
    Philosopher::new(&quot;Джудит Батлер&quot;, 0, 1),
    Philosopher::new(&quot;Рая Дунаевская&quot;, 1, 2),
    Philosopher::new(&quot;Зарубина Наталья&quot;, 2, 3),
    Philosopher::new(&quot;Эмма Гольдман&quot;, 3, 4),
    Philosopher::new(&quot;Анна Шмидт&quot;, 0, 4),
];
</code></pre>
<p>Мы добавили наши значения <code>left</code> и <code>right</code> при создании структуры <code>Philosopher</code>.
Здесь есть <em>очень важная</em> деталь, на которую следует обратить внимание.
Посмотрите на последнюю строку создания <code>Philosopher</code>. Конструктор Анны Шмидт
должен был бы принимать в качестве аргументов значения <code>4</code> и <code>0</code>, но вместо
этого он принимает значения <code>0</code> и <code>4</code>. Это помешает нашей программе попасть в
безвыходное состояние, если каждый возьмёт по одной вилке одновременно. Так что
давайте представим, что один из философов у нас левша! Это один из способов
решить данную проблему, и, на мой взгляд, самый простой. Если вы поменяете
порядок параметров, то программа попадёт в безвыходное состояние.</p>
<pre><code class="language-rust ignore">let handles: Vec&lt;_&gt; = philosophers.into_iter().map(|p| {
    let table = table.clone();

    thread::spawn(move || {
        p.eat(&amp;table);
    })
}).collect();
</code></pre>
<p>Внутри нашего цикла <code>map()</code>/<code>collect()</code> мы вызываем метод <code>table.clone()</code>. Метод
<code>clone()</code> структуры <code>Arc&lt;T&gt;</code> клонирует значение и инкрементирует счётчик,
который автоматически декрементируется, когда клонированное значение покинет
область видимости. Это необходимо для того, чтобы мы знали, как много ссылок на
<code>table</code> существуют в рамках наших потоков на данный момент времени. Если бы у
нас не было подсчёта ссылок, то мы бы не знали, как и когда освободить хранимое
значение.</p>
<p>Вы можете заметить, что здесь мы выполняем новое связывание с именем <code>table</code>,
затеняя старое связанное имя <code>table</code>. Это позволяет нам не вводить новое
уникальное имя.</p>
<p>Теперь наша программа работает! Только два философа могут обедать одновременно.
После запуска программы вы можете получить такой результат.</p>
<pre><code class="language-text">Рая Дунаевская начала есть.
Эмма Гольдман начала есть.
Эмма Гольдман закончила есть.
Рая Дунаевская закончила есть.
Джудит Батлер начала есть.
Зарубина Наталья начала есть.
Джудит Батлер закончила есть.
Анна Шмидт начала есть.
Зарубина Наталья закончила есть.
Анна Шмидт закончила есть.
</code></pre>
<p>Поздравляем! Вы реализовали классическую задачу параллелизма на языке Rust.</p>
<p>% Вызов кода на Rust из других языков</p>
<p>Для нашего третьего проекта мы собираемся выбрать что-то, что подчеркнёт одну из
самых сильных сторон в Rust: фактическое отсутствие среды исполнения.</p>
<p>По мере роста организации, программисты все больше полагаются на множество
языков программирования. У каждого языка программирования есть свои сильные и
слабые стороны, а знание нескольких языков позволяет использовать определённый
язык там, где проявляется его сильные стороны, и использовать другой язык там,
где первый не очень хорош.</p>
<p>Существует несколько областей, где многие языки программирования слабы в плане
производительности выполнения программ. Часто компромисс заключается в том,
чтобы использовать более медленный язык, который взамен способствует повышению
производительности программиста. Чтобы решить эту проблему, часть кода системы
можно написать на C, а затем вызвать этот код, написанный на C, как если бы он
был написан на языке высокого уровня. Это называется «интерфейс внешних функций»
(foreign function interface), часто сокращается до FFI.</p>
<p>Rust включает поддержку FFI в обоих направлениях: он легко может вызвать C код,
и он так же легко, как и C код, может быть вызван <em>извне</em>. Rust сочетает в себе
отсутствие сборщика мусора и низкие требования к среде исполнения, что делает
Rust отличным кандидатом на роль вызываемого из других языков, когда нужны
некоторые дополнительные возможности.</p>
<p>В этой книге есть целая <a href="ffi.html">глава, посвящённая FFI</a> и его специфике, а в этой
главе мы рассмотрим именно конкретный частный случай FFI, с тремя примерами, на
Ruby, Python и JavaScript.</p>
<h1><a class="header" href="#Проблема" id="Проблема">Проблема</a></h1>
<p>Есть много различных проектов, которые мы могли бы выбрать, но мы хотим
подобрать такой пример, который продемонстрирует явное преимущество Rust над
многими другими языками: сложные вычисления и многопоточность.</p>
<p>Во многих языках числа размещаются в куче, а не в стеке. Это обеспечивает
целостность поведения языка при работе с числами и с другими объектами. Особенно
в языках, которые сосредотачиваются на объектно-ориентированном программировании
и использовании сборщика мусора, по умолчанию память выделяется из кучи. Иногда,
при оптимизации, для конкретных чисел память может выделяться в стеке, но вместо
того, чтобы полагаться на работу оптимизации, мы можем захотеть убедиться в том,
что мы используем примитивные типы чисел, а не какой-либо тип объекта.</p>
<p>Во-вторых, многие языки имеют «глобальную блокировку интерпретатора» (global
interpreter lock), которая ограничивает параллелизм во многих ситуациях. Это
делается во имя безопасности, что оказывает положительный эффект, но это также и
ограничивает объем работ, который может быть выполнен одновременно, что, в свою
очередь, оказывает большой отрицательный эффект.</p>
<p>Чтобы подчеркнуть эти два аспекта, мы собираемся создать небольшой проект,
который в значительной степени их использует. Поскольку внимание в этом примере
сфокусировано на встраивание Rust в другие языки, а не самой проблеме, мы будем
использовать игрушечный пример:</p>
<blockquote>
<p>Запустить десять потоков. Внутри каждого потока считать от одного до пяти
миллионов. После того как все десять потоков завершатся, напечатать
&quot;сделано!&quot;.</p>
</blockquote>
<p>Мы выбрали пять миллионов руководствуясь тем, сколько времени занимает эта
работа на современном компьютере. Вот пример этого кода на Ruby:</p>
<pre><code class="language-ruby">threads = []

10.times do
  threads &lt;&lt; Thread.new do
    count = 0

    5_000_000.times do
      count += 1
    end
  end
end

threads.each { |t| t.join }
puts &quot;сделано!&quot;
</code></pre>
<p>Попробуйте запустить этот пример, и подберите число, которое обеспечит работу в
течение нескольких секунд. В зависимости от аппаратного обеспечения компьютера,
возможно, придётся увеличить или уменьшить это число.</p>
<p>На выбранной нами системе эта программа работает <code>2.156</code> секунд. И если мы
воспользуемся какой-нибудь утилитой для мониторинга процессов (например, <code>top</code>),
то увидим, что она использует только одно ядро. Это GIL делает своё дело.</p>
<p>Хотя это и игрушечная программа, на её примере можно продемонстрировать много
проблем, аналогичных этой, характерных для реального мира. Для наших целей,
долго крутящиеся занятые потоки представляют собой параллельные, требующие
больших затрат, вычисления.</p>
<h1><a class="header" href="#Библиотека-на-rust" id="Библиотека-на-rust">Библиотека на Rust</a></h1>
<p>Давайте перепишем эту задачу на Rust. Во-первых, давайте сделаем новый проект с
помощью Cargo:</p>
<pre><code class="language-bash">$ cargo new embed
$ cd embed
</code></pre>
<p>Эту программу легко переписать на Rust:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::thread;

fn process() {
    let handles: Vec&lt;_&gt; = (0..10).map(|_| {
        thread::spawn(|| {
            let mut x = 0;
            for _ in 0..5_000_000 {
                x += 1
            }
            x
        })
    }).collect();

    for h in handles {
        println!(&quot;Поток завершился со счётом={}&quot;,
        h.join().map_err(|_| &quot;Не удалось соединиться с потоком!&quot;).unwrap());
    }
}
#}</code></pre></pre>
<p>Мы уже знакомы с частью этого кода из предыдущих примеров. Мы создаём десять
потоков, собирая их в вектор <code>handles</code>. Внутри каждого потока мы осуществляем
пять миллионов повторений в цикле, и прибавляем к <code>x</code> единицу каждый раз.
Наконец, мы воссоединяем все потоки.</p>
<p>Сейчас, однако, это просто библиотека Rust, которая не включает все необходимое
для успешного вызова из другого языка. Если мы попытаемся подключить её к
другому языку в том виде, в котором она сейчас, то это не будет работать. Нам
нужно сделать два небольших изменения, чтобы исправить это. Первое, что мы
должны сделать, это изменить начало нашего кода:</p>
<pre><code class="language-rust ignore">#[no_mangle]
pub extern fn process() {
</code></pre>
<p>Мы добавили новый атрибут, <code>no_mangle</code>. В процессе создания библиотеки Rust, в
выходном скомпилированном файле происходит изменение имени функции. Причины
этого выходят за рамки данного руководства, но для того, чтобы и другие языки
знали, как вызвать функцию, мы должны не делать этого. Указанный атрибут
выключает такое поведение.</p>
<p>Другим изменением, которое мы добавили, является <code>pub extern</code>. <code>pub</code> означает,
что эта функция может быть вызвана за пределами этого модуля, а <code>extern</code>
говорит, что её возможно вызвать из С. Вот и все! Не так и много изменений.</p>
<p>Второе, что мы должны сделать, это изменить настройки в <code>Cargo.toml</code>. Добавьте
это в конец файла:</p>
<pre><code class="language-toml">[lib]
name = &quot;embed&quot;
crate-type = [&quot;dylib&quot;]
</code></pre>
<p>Это говорит Rust, что мы хотим скомпилировать нашу библиотеку в виде стандартной
динамической библиотеки. По умолчанию, Rust компилирует в rlib, Rust-
специфичный формат.</p>
<p>Давайте теперь соберём проект:</p>
<pre><code class="language-bash">$ cargo build --release
   Compiling embed v0.1.0 (file:///home/steve/src/embed)
</code></pre>
<p>Мы ввели команду <code>cargo build --release</code>, которая выполняет сборку с включённой
оптимизацией. Мы хотим, чтобы код был как можно более быстрым! Вы можете найти
собранную библиотеку в <code>target/release</code>:</p>
<pre><code class="language-bash">$ ls target/release/
build  deps  examples  libembed.so  native
</code></pre>
<p>Файл <code>libembed.so</code> — и есть наша динамическая библиотека (shared object). Мы
можем использовать этот файл также как и любую другую динамическую библиотеку,
написанную на C! Попутно следует отметить, это может быть <code>embed.dll</code> (Microsoft
Windows) или <code>libembed.dylib</code> (Mac OS X), в зависимости от операционной системы.</p>
<p>Теперь, когда мы получили нашу собранную библиотеку Rust, давайте используем её
из нашего кода на Ruby.</p>
<h1><a class="header" href="#ruby" id="ruby">Ruby</a></h1>
<p>Откройте файл <code>embed.rb</code> внутри нашего проекта, и сделайте следующее:</p>
<pre><code class="language-ruby">require 'ffi'

module Hello
  extend FFI::Library
  ffi_lib 'target/release/libembed.so'
  attach_function :process, [], :void
end

Hello.process

puts 'сделано!'
</code></pre>
<p>Прежде чем мы сможем запустить этот код, нам нужно установить пакет <code>ffi</code>:</p>
<pre><code class="language-bash">$ gem install ffi # this may need sudo
Fetching: ffi-1.9.8.gem (100%)
Building native extensions.  This could take a while...
Successfully installed ffi-1.9.8
Parsing documentation for ffi-1.9.8
Installing ri documentation for ffi-1.9.8
Done installing documentation for ffi after 0 seconds
1 gem installed
</code></pre>
<p>И, наконец, мы можем попробовать запустить его:</p>
<pre><code class="language-bash">$ ruby embed.rb
Поток завершился со счётом=5000000
Поток завершился со счётом=5000000
Поток завершился со счётом=5000000
Поток завершился со счётом=5000000
Поток завершился со счётом=5000000
Поток завершился со счётом=5000000
Поток завершился со счётом=5000000
Поток завершился со счётом=5000000
Поток завершился со счётом=5000000
Поток завершился со счётом=5000000
сделано!
$
</code></pre>
<p>Ничего себе, это было быстро! На моей системе это заняло <code>0.086</code> секунд, а не
две секунды как это было на чистом Ruby. Давайте разберём этот Ruby код:</p>
<pre><code class="language-ruby">require 'ffi'
</code></pre>
<p>Первый делом, нам надо объявить пакет <code>ffi</code>. Он предоставляет нам интерфейс для
использования нашей библиотеки на Rust, как библиотеку на C.</p>
<pre><code class="language-ruby">module Hello
  extend FFI::Library
  ffi_lib 'target/release/libembed.so'
</code></pre>
<p>Автор пакета <code>ffi</code> рекомендует использовать модуль, чтобы ограничить область
действия функции, которую мы импортировали из разделяемой библиотеки. Внутри мы
указали <code>extend</code>, чтобы воспользоваться необходимым модулем <code>FFI::Library</code>, а
затем вызвали <code>ffi_lib</code>, чтобы подгрузить нашу библиотеку. Мы просто передаём
путь к библиотеке, который мы уже видели раньше, это
<code>target/release/libembed.so</code>.</p>
<pre><code class="language-ruby">attach_function :process, [], :void
</code></pre>
<p>Метод <code>attach_function</code> предоставляется пакетом <code>FFI</code>. Здесь соединяются наша
функция <code>process()</code>, написанная на Rust, и одноимённая функция на Ruby. Так как
<code>process()</code> не принимает аргументов, второй параметр является пустым массивом, и
поскольку функция ничего не возвращает, мы передаём <code>:void</code> в качестве
завершающего аргумента.</p>
<pre><code class="language-ruby">Hello.process
</code></pre>
<p>Здесь мы совершаем вызов нашей Rust функции. Сочетание нашего <code>module</code> и вызова
к <code>attach_function</code> завершает подготовку. Это выглядит как функция Ruby, но на
самом деле это Rust!</p>
<pre><code class="language-ruby">puts 'сделано!'
</code></pre>
<p>Наконец, в соответствие с нашими требованиями к проекту, мы пишем <code>сделано!</code> по
окончанию работы программы.</p>
<p>Вот и все! Как мы увидели, совместить два языка очень просто, и взамен мы
получили большую производительность.</p>
<p>Теперь давайте попробуем на Python!</p>
<h1><a class="header" href="#python" id="python">Python</a></h1>
<p>Создайте файл <code>embed.py</code> в этой директории и поместите в него следующее:</p>
<pre><code class="language-python">from ctypes import cdll

lib = cdll.LoadLibrary(&quot;target/release/libembed.so&quot;)

lib.process()

print(&quot;сделано!&quot;)
</code></pre>
<p>Довольно просто! Мы импортируем <code>cdll</code> из модуля <code>ctypes</code>. Затем вызываем
<code>LoadLibrary</code>. И теперь мы можем вызвать <code>process()</code>.</p>
<p>На моей системе это заняло <code>0.017</code> секунд. Быстро!</p>
<h1><a class="header" href="#nodejs" id="nodejs">Node.js</a></h1>
<p>Node — это не язык, но, в настоящее время, это доминирующая реализация
исполнения JavaScript на сервере.</p>
<p>Для того, чтобы сделать FFI в Node, нам сначала надо установить библиотеку:</p>
<pre><code class="language-bash">$ npm install ffi
</code></pre>
<p>После установки, мы можем ей воспользоваться:</p>
<pre><code class="language-javascript">var ffi = require('ffi');

var lib = ffi.Library('target/release/libembed', {
  'process': ['void', []]
});

lib.process();

console.log(&quot;сделано!&quot;);
</code></pre>
<p>Пример больше похож на Ruby, чем на Python. Мы используем модуль <code>ffi</code>, чтобы
получить доступ к <code>ffi.Library()</code>, который загружает нашу библиотеку. Нам нужно
указать тип возвращаемого значения и типы аргументов функции: <code>void</code> для
возвращаемого значения и пустой массив для указания отсутствия аргументов. После
этого мы просто вызываем функцию и печатаем результат.</p>
<p>На моей системе это заняло <code>0.092</code> секунды.</p>
<h1><a class="header" href="#Заключение-1" id="Заключение-1">Заключение</a></h1>
<p>Как вы можете видеть, основы, рассмотренные здесь, являются <em>очень</em> простыми.
Конечно, мы могли бы сделать куда больше того, что мы здесь показали. Посмотрите
главу <a href="ffi.html">FFI</a> для более подробной информации.</p>
<p>% Синтаксис и семантика</p>
<p>Эта часть разбита на небольшие главы, каждая из которых описывает определённое
понятие Rust.</p>
<p>Если вы хотите изучить Rust «от и до», продолжайте чтение данной части по
порядку - вы на верном пути!</p>
<p>Эти главы также являются справочником понятий, так что если при чтении другого
материала вам будет что-то непонятно, вы всегда сможете найти объяснение здесь.</p>
<p>% Связывание имён</p>
<p>Любая реальная программа на Rust посложнее, чем «Hello World», использует
<em>связывание имён</em>. Они связывают значение с именем, для того чтобы
воспользоваться им позже. Для связывания используется команда <code>let</code>:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;
}
</code></pre></pre>
<p>Все операции, производимые ниже, будут происходить в функции <code>main()</code>, так как
каждый раз вставлять в примеры <code>fn main() {</code> немного утомляет. Убедитесь, что
примеры, приведённые в этом разделе, вы вводите в функцию <code>main()</code>, иначе можете
получить ошибку при компиляции.</p>
<h1><a class="header" href="#Шаблоны" id="Шаблоны">Шаблоны</a></h1>
<p>Во многих языках программирования связывание имён называется <em>переменной</em>. Но у
связывания имен в Rust есть пара трюков в рукаве. В левой части выражения
<code>let</code> располагается не просто имя переменной, а &quot;<a href="patterns.html">шаблон</a>&quot;. Это значит,
что мы можем делать вещи вроде этой:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let (x, y) = (1, 2);
#}</code></pre></pre>
<p>После завершения этого выражения <code>x</code> будет единицей, a <code>y</code> — двойкой. Шаблоны
очень мощны, и о них написана отдельная <a href="patterns.html">глава</a>. Но на данный момент
нам не нужны эти возможности, так что мы просто будем помнить о них и пойдём
дальше.</p>
<h1><a class="header" href="#Указание-типов" id="Указание-типов">Указание типов</a></h1>
<p>Rust — статически типизированный язык программирования, и значит мы должны
указывать типы, и они будут проверяться во время компиляции. Так почему же наш
первый пример скомпилировался? В Rust есть нечто, называемое <em>выводом типов</em>.
Если Rust самостоятельно может понять, какой тип у переменной, то он не требует
указывать его.</p>
<p>Тем не менее, мы можем указать желаемый тип. Он следует после двоеточия (<code>:</code>):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x: i32 = 5;
#}</code></pre></pre>
<p>Если бы мы попросили вас прочитать это вслух, вы бы сказали «<code>x</code> — это
связывание типа <code>int</code> со значением <code>пять</code>».</p>
<p>В этом случае мы указали, что <code>x</code> у нас будет 32-битным целым числом со знаком.
В Rust есть и другие целочисленные типы. Их имена начинаются с <code>i</code> для целых
чисел со знаком и с <code>u</code> для целых чисел без знака. Целые числа могут иметь
размер 8, 16, 32 и 64 бита.</p>
<p>В дальнейших примерах мы будем указывать тип в комментариях. Это будет выглядеть
вот так:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5; // x: i32
}
</code></pre></pre>
<p>Обратите внимание на сходство между этим комментарием и синтаксисом, который вы
используете с <code>let</code>. Включение такого типа комментариев не является
идиоматичным для Rust, но иногда мы будем включать их для того, чтобы помочь
вам понять, какие типы будут выведены Rust.</p>
<h1><a class="header" href="#Изменяемость" id="Изменяемость">Изменяемость</a></h1>
<p>По умолчанию, связывание <em>неизменяемо</em>. Этот код не скомпилируется:</p>
<pre><code class="language-rust ignore">let x = 5;
x = 10;
</code></pre>
<p>И вы получите ошибку:</p>
<pre><code class="language-text">error: re-assignment of immutable variable `x`
     x = 10;
     ^~~~~~~
</code></pre>
<p>Если вы хотите, чтобы связывание было изменяемым, вы можете использовать
модификатор <code>mut</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut x = 5; // mut x: i32
x = 10;
#}</code></pre></pre>
<p>Может показаться, что незачем делать связывание неизменяемым по умолчанию. Но
вспомните, на чём в первую очередь фокусируется Rust: на безопасности. Если вы
случайно забыли указать <code>mut</code> и изменили связывание, компилятор заметит это, и
сообщит вам, что вы попытались изменить не то, что собирались. Если бы по
умолчанию связывание было изменяемым, то в приведённой выше ситуации компилятор
не сможет вам помочь. Если вы намерены изменить значение переменной, то просто
добавьте <code>mut</code>.</p>
<p>Есть и другие весомые аргументы в пользу того, чтобы по возможности избегать
изменяемого состояния, но это выходит за рамки данной книги. В общем, зачастую
вы можете избежать явных изменений, и это предпочтительнее в Rust. Тем не менее,
иногда без изменения значения просто не обойтись, так что это не запрещено.</p>
<h1><a class="header" href="#Инициализация-связывания" id="Инициализация-связывания">Инициализация связывания</a></h1>
<p>Связывание имен в Rust имеет ещё одно отличие от других языков: оно
требует инициализации перед использованием.</p>
<p>Давайте приступим к рассмотрению вышесказанного. Измените ваш файл <code>src/main.rs</code>
так, что бы он выглядел следующим образом:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x: i32;

    println!(&quot;Hello world!&quot;);
}
</code></pre></pre>
<p>Используйте команду <code>cargo build</code> в командной строке, чтобы собрать проект. Вы
должны получить предупреждение, но программа будет работать и будет выводить
строку «Привет, мир!»:</p>
<pre><code class="language-text">   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)
src/main.rs:2:9: 2:10 warning: unused variable: `x`, #[warn(unused_variable)]
   on by default
src/main.rs:2     let x: i32;
                      ^
</code></pre>
<p>Rust предупредит нас о том, что мы не используем связанную переменную, но от
того, что мы её не используем, не будет никакого вреда, поэтому это не ошибка.
Однако, всё изменится, если мы попробуем использовать <code>x</code>. Сделаем это. Измените
вашу программу так, что бы она выглядела следующим образом:</p>
<pre><code class="language-rust ignore">fn main() {
    let x: i32;

    println!(&quot;x имеет значение {}&quot;, x);
}
</code></pre>
<p>И попробуйте собрать проект. Вы получите ошибку:</p>
<pre><code class="language-bash">$ cargo build
   Compiling hello_world v0.0.1 (file:///home/you/projects/hello_world)
src/main.rs:4:39: 4:40 error: use of possibly uninitialized variable: `x`
src/main.rs:4     println!(&quot;x имеет значение {}&quot;, x);
                                                    ^
note: in expansion of format_args!
&lt;std macros&gt;:2:23: 2:77 note: expansion site
&lt;std macros&gt;:1:1: 3:2 note: in expansion of println!
src/main.rs:4:5: 4:42 note: expansion site
error: aborting due to previous error
Could not compile `hello_world`.
</code></pre>
<p>Rust не позволит использовать неинициализированную переменную. Далее, поговорим
о <code>{}</code>, которые мы добавили в <code>println!</code>.</p>
<p>Если вы добавите две фигурные скобки (<code>{}</code>, иногда называемые «усами»...) в вашу
печатаемую строку, Rust истолкует это как просьбу вставки некоторого значения.
<em>Строковая интерполяция</em> — это термин в информатике, который обозначает
«вставить посреди строки». Мы добавили запятую, и затем <code>x</code>, чтобы указать, что
мы хотим вставить <code>x</code> в строку. Запятая используется для разделения параметров,
если в функцию или макрос передаётся больше одного параметра.</p>
<p>При вставке переменной в строку, Rust проверит её тип и попытается отобразить
осмысленное значение. Если вы хотите указать формат более детально, то можете
ознакомиться с <a href="http://doc.rust-lang.org/std/fmt/index.html">доступными способами форматирования строк (англ.)</a>. На
данный момент мы просто используем способ по умолчанию: печатать целые числа не
очень сложно.</p>
<h1><a class="header" href="#Область-видимости-и-затенение" id="Область-видимости-и-затенение">Область видимости и затенение</a></h1>
<p>Вернёмся к связыванию. Связанные имена имеют область видимости — они
ограничены блоком, в котором они были объявлены. Блок — это совокупность
операторов, заключённая в фигурных скобках (<code>{</code> и <code>}</code>). Функции тоже объявляются
с помощью блоков! Сейчас мы объявим два связанных имени, <code>x</code> и <code>y</code>, которые
существуют в различных блоках. К <code>x</code> можно получить доступ внутри блока
<code>fn main() {}</code>, в то же время <code>y</code> доступен только во внутреннем блоке:</p>
<pre><code class="language-rust ignore">fn main() {
    let x: i32 = 17;
    {
        let y: i32 = 3;
        println!(&quot;Значение x равно {} и значение y равно {}&quot;, x, y);
    }
    // Ошибка компиляции
    println!(&quot;Значение x равно {} и значение y равно {}&quot;, x, y);
}
</code></pre>
<p>Первый <code>println!</code> выведет &quot;Значение x равно 17 и значение y равно 3&quot;, но этот
пример не скомпилируется, потому что второй <code>println!</code> не может получить доступ
к значению <code>y</code>, оно вне области видимости. Вместо этого мы увидим ошибку:</p>
<pre><code class="language-bash">$ cargo build
   Compiling hello v0.1.0 (file:///home/you/projects/hello_world)
main.rs:8:62: 8:63 error: unresolved name `y`. Did you mean `x`? [E0425]
main.rs:8     println!(&quot;Значение x равно {} и значение y равно {}&quot;, x, y);
                                                                       ^
&lt;std macros&gt;:2:25: 2:56 note: in this expansion of format_args!
&lt;std macros&gt;:3:1: 3:54 note: in this expansion of print! (defined in &lt;std macros&gt;)
main.rs:8:5: 8:65 note: in this expansion of println! (defined in &lt;std macros&gt;)
main.rs:8:62: 8:63 help: run `rustc --explain E0425` to see a detailed explanation
error: aborting due to previous error
Could not compile `hello`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Помимо прочего, связанные имена могут быть затенены. Это значит, что, если
объявить связывание с именем, которое уже существует, то оно переопределит
предыдущее.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x: i32 = 8;
{
    println!(&quot;{}&quot;, x); // Выводит &quot;8&quot;
    let x = 12;
    println!(&quot;{}&quot;, x); // Выводит &quot;12&quot;
}
println!(&quot;{}&quot;, x); // Выводит &quot;8&quot;
let x =  42;
println!(&quot;{}&quot;, x); // Выводит &quot;42&quot;
#}</code></pre></pre>
<p>Затенение и изменяемое связывание могут казаться двумя сторонами одной монеты, но
они являются двумя отдельными концепциями, которые не всегда взаимозаменяемы.
Например, затенение позволяет связать имя с другим типом или изменить связь с
изменяемой на неизменяемую.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut x: i32 = 1;
x = 7;
let x = x; // теперь X неизменяемое и связанно с 7

let y = 4;
let y = &quot;Я так же могу быть связан с текстом!&quot;; // теперь Y другого типа
#}</code></pre></pre>
<p>% Функции</p>
<p>Каждая программа на Rust имеет по крайней мере одну функцию — <code>main</code>:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
}
</code></pre></pre>
<p>Это простейшее объявление функции. Как мы упоминали ранее, ключевое слово <code>fn</code>
объявляет функцию. За ним следует её имя, пустые круглые скобки (поскольку эта
функция не принимает аргументов), а затем тело функции, заключённое в фигурные
скобки. Вот функция <code>foo</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo() {
}
#}</code></pre></pre>
<p>Итак, что насчёт аргументов, принимаемых функцией? Вот функция, печатающая
число:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn print_number(x: i32) {
    println!(&quot;x равен: {}&quot;, x);
}
#}</code></pre></pre>
<p>Вот полная программа, использующая функцию <code>print_number</code>:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    print_number(5);
}

fn print_number(x: i32) {
    println!(&quot;x равен: {}&quot;, x);
}
</code></pre></pre>
<p>Как видите, аргументы функций похожи на операторы <code>let</code>: вы можете объявить тип
аргумента после двоеточия.</p>
<p>Вот полная программа, которая складывает два числа и печатает их:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    print_sum(5, 6);
}

fn print_sum(x: i32, y: i32) {
    println!(&quot;сумма чисел: {}&quot;, x + y);
}
</code></pre></pre>
<p>Аргументы разделяются запятой — и при вызове функции, и при её объявлении.</p>
<p>В отличие от <code>let</code>, вы <em>должны</em> объявлять типы аргументов функции. Этот код не
скомпилируется:</p>
<pre><code class="language-rust ignore">fn print_sum(x, y) {
    println!(&quot;сумма чисел: {}&quot;, x + y);
}
</code></pre>
<p>Вы увидите такую ошибку:</p>
<pre><code class="language-text">expected one of `!`, `:`, or `@`, found `)`
fn print_number(x, y) {
</code></pre>
<p>Это осознанное решение при проектировании языка. Бесспорно, вывод типов во всей
программе возможен. Однако даже в Haskell считается хорошим стилем явно
документировать типы функций, хотя в этом языке и возможен полный вывод типов.
Мы считаем, что принудительное объявление типов функций при сохранении
локального вывода типов — это хороший компромисс.</p>
<p>Как насчёт возвращаемого значения? Вот функция, которая прибавляет один к
целому:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn add_one(x: i32) -&gt; i32 {
    x + 1
}
#}</code></pre></pre>
<p>Функции в Rust возвращают ровно одно значение, тип которого объявляется после
«стрелки». «Стрелка» представляет собой дефис (<code>-</code>), за которым следует знак
«больше» (<code>&gt;</code>). Заметьте, что в функции выше нет точки с запятой. Если бы мы
добавили её:</p>
<pre><code class="language-rust ignore">fn add_one(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
<p>мы бы получили ошибку:</p>
<pre><code class="language-text">error: not all control paths return a value
fn add_one(x: i32) -&gt; i32 {
     x + 1;
}

help: consider removing this semicolon:
     x + 1;
          ^
</code></pre>
<p>Здесь показаны две интересные особенности Rust. Во-первых, это язык,
ориентированный на выражения, и во-вторых, смысл точки с запятой отличается от
смысла аналогичного символа в других языках с синтаксисом на основе фигурных
скобок и точки с запятой. Эти две особенности связаны.</p>
<p><a name="expressions-vs-statements"></a></p>
<h2><a class="header" href="#Выражения-и-операторы" id="Выражения-и-операторы">Выражения и операторы</a></h2>
<p>Rust — в первую очередь язык, ориентированный на выражения. Есть только два типа
операторов, а всё остальное является выражением.</p>
<p>А в чём же разница? Выражение возвращает значение, в то время как оператор -
нет. Вот почему мы получаем здесь «not all control paths return a value»:
оператор <code>х + 1;</code> не возвращает значение. Есть два типа операторов в Rust:
«операторы объявления» и «операторы выражения». Все остальное — выражения.
Давайте сначала поговорим об операторах объявления.</p>
<p><em>Оператор объявления</em> — это связывание. В некоторых языках связывание переменных
может быть записано как выражение, а не только как оператор. Например, в Ruby:</p>
<pre><code class="language-ruby">x = y = 5
</code></pre>
<p>Однако, в Rust использование <code>let</code> для связывания <em>не является</em> выражением.
Следующий код вызовет ошибку компиляции:</p>
<pre><code class="language-ignore">let x = (let y = 5); // expected identifier, found keyword `let`
</code></pre>
<p>Здесь компилятор сообщил нам, что ожидал увидеть выражение, но <code>let</code> является
оператором, а не выражением.</p>
<p>Обратите внимание, что присвоение уже связанной переменной (например: <code>y = 5</code>)
является выражением, но его значение не особенно полезно. В отличие от других
языков, где результатом присваивания является присваиваемое значение (например,
<code>5</code> из предыдущего примера), в Rust значением присваивания является пустой
кортеж <code>()</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut y = 5;

let x = (y = 6);  // x будет присвоено значение `()`, а не `6`
#}</code></pre></pre>
<p>Вторым типом операторов в Rust является <em>оператор выражения</em>. Его цель -
превратить любое выражение в оператор. В практическом плане, грамматика Rust
ожидает, что за операторами будут идти другие операторы. Это означает, что вы
используете точку с запятой для отделения выражений друг от друга. Rust выглядит
как многие другие языки, которые требуют использовать точку с запятой в конце
каждой строки. Вы увидите её в конце почти каждой строки кода на Rust.</p>
<p>Из-за чего мы говорим «почти»? Вы это уже видели в этом примере:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn add_one(x: i32) -&gt; i32 {
    x + 1
}
#}</code></pre></pre>
<p>Наша функция объявлена как возвращающая <code>i32</code>. Но если в конце есть точка с
запятой, то вместо этого функция вернёт <code>()</code>. Компилятор Rust обрабатывает эту
ситуацию и предлагает удалить точку с запятой.</p>
<h2><a class="header" href="#Досрочный-возврат-из-функции" id="Досрочный-возврат-из-функции">Досрочный возврат из функции</a></h2>
<p>А что насчёт досрочного возврата из функции? У нас есть для этого ключевое слово
<code>return</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(x: i32) -&gt; i32 {
    return x;

    // дальнейший код не будет исполнен!
    x + 1
}
#}</code></pre></pre>
<p><code>return</code> можно написать в последней строке тела функции, но это считается
плохим стилем:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(x: i32) -&gt; i32 {
    return x + 1;
}
#}</code></pre></pre>
<p>Если вы никогда не работали с языком, в котором операторы являются выражениями,
предыдущее определение без <code>return</code> может показаться вам странным. Но со
временем вы просто перестанете замечать это.</p>
<h2><a class="header" href="#Расходящиеся-функции" id="Расходящиеся-функции">Расходящиеся функции</a></h2>
<p>Для функций, которые не возвращают управление («расходящихся»), в Rust есть
специальный синтаксис:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn diverges() -&gt; ! {
    panic!(&quot;Эта функция не возвращает управление!&quot;);
}
#}</code></pre></pre>
<p><code>panic!</code> — это макрос, как и <code>println!()</code>, который мы встречали ранее. В отличие
от <code>println!()</code>, <code>panic!()</code> вызывает остановку текущего потока исполнения с
заданным сообщением. Поскольку эта функция вызывает остановку исполнения, она
никогда не вернёт управление. Поэтому тип её возвращаемого значения обозначается
знаком <code>!</code> и читается как «расходится».</p>
<p>Если добавить функцию <code>diverges()</code> и запустить её, то вы получите следующее
сообщение:</p>
<pre><code class="language-text">thread ‘&lt;main&gt;’ panicked at ‘Эта функция не возвращает управление!’, hello.rs:2
</code></pre>
<p>Для получение более подробной информации вы можете посмотреть трассировку
установив переменную среды <code>RUST_BACKTRACE</code>:</p>
<pre><code class="language-text">$ RUST_BACKTRACE=1 ./diverges
thread '&lt;main&gt;' panicked at 'Эта функция не возвращает управление!', hello.rs:2
stack backtrace:
   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r
   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w
   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw
   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650
   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa
   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa
   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231
   8:     0x7f402773d1d8 - __rust_try
   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w
  10:     0x7f4027738a19 - main
  11:     0x7f402694ab44 - __libc_start_main
  12:     0x7f40277386c8 - &lt;unknown&gt;
  13:                0x0 - &lt;unknown&gt;
</code></pre>
<p><code>RUST_BACKTRACE</code> также работает при выполнении команды <code>run</code>:</p>
<pre><code class="language-text">$ RUST_BACKTRACE=1 cargo run
     Running `target/debug/diverges`
thread '&lt;main&gt;' panicked at 'Эта функция не возвращает управление!', hello.rs:2
stack backtrace:
   1:     0x7f402773a829 - sys::backtrace::write::h0942de78b6c02817K8r
   2:     0x7f402773d7fc - panicking::on_panic::h3f23f9d0b5f4c91bu9w
   3:     0x7f402773960e - rt::unwind::begin_unwind_inner::h2844b8c5e81e79558Bw
   4:     0x7f4027738893 - rt::unwind::begin_unwind::h4375279447423903650
   5:     0x7f4027738809 - diverges::h2266b4c4b850236beaa
   6:     0x7f40277389e5 - main::h19bb1149c2f00ecfBaa
   7:     0x7f402773f514 - rt::unwind::try::try_fn::h13186883479104382231
   8:     0x7f402773d1d8 - __rust_try
   9:     0x7f402773f201 - rt::lang_start::ha172a3ce74bb453aK5w
  10:     0x7f4027738a19 - main
  11:     0x7f402694ab44 - __libc_start_main
  12:     0x7f40277386c8 - &lt;unknown&gt;
  13:                0x0 - &lt;unknown&gt;
</code></pre>
<p>Значение расходящейся функции может быть использовано как значение любого типа:</p>
<pre><code class="language-should_panic"># fn diverges() -&gt; ! {
#    panic!(&quot;Эта функция никогда не выходит!&quot;);
# }
let x: i32 = diverges();
let x: String = diverges();
</code></pre>
<h2><a class="header" href="#Указатели-на-функции" id="Указатели-на-функции">Указатели на функции</a></h2>
<p>Можно объявить имя, связанное с функцией:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let f: fn(i32) -&gt; i32;
#}</code></pre></pre>
<p><code>f</code> — это имя, связанное с указателем на функцию, которая принимает в качестве
аргумента <code>i32</code> и возвращает <code>i32</code>. Например:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn plus_one(i: i32) -&gt; i32 {
    i + 1
}

// без вывода типа
let f: fn(i32) -&gt; i32 = plus_one;

// с выводом типа
let f = plus_one;
#}</code></pre></pre>
<p>Теперь мы можем использовать <code>f</code>, чтобы вызвать функцию:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn plus_one(i: i32) -&gt; i32 { i + 1 }
# let f = plus_one;
let six = f(5);
#}</code></pre></pre>
<p>% Простые типы</p>
<p>Язык Rust имеет несколько типов, которые считаются «простыми» («примитивными»).
Это означает, что они встроены в язык. Rust структурирован таким образом, что
стандартная библиотека также предоставляет ряд полезных типов, построенных на
базе этих простых типов, но это самые простые.</p>
<h1><a class="header" href="#Логический-тип" id="Логический-тип">Логический тип</a></h1>
<p>Rust имеет встроенный логический тип, называемый <code>bool</code>. Он может принимать два
значения, <code>true</code> и <code>false</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = true;

let y: bool = false;
#}</code></pre></pre>
<p>Логические типы часто используются в <a href="if.html">конструкции <code>if</code></a>.</p>
<p>Вы можете найти больше информации о логических типах (<code>bool</code>) в <a href="http://doc.rust-lang.org/std/primitive.bool.html">документации к
стандартной библиотеке (англ.)</a>.</p>
<h1><a class="header" href="#Символы" id="Символы">Символы</a></h1>
<p>Тип <code>char</code> представляет собой одиночное скалярное значение Unicode. Вы можете
создать <code>char</code> с помощью одинарных кавычек: (<code>'</code>)</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 'x';
let two_hearts = '💕';
#}</code></pre></pre>
<p>Это означает, что в отличие от некоторых других языков, <code>char</code> в Rust
представлен не одним байтом, а четырьмя.</p>
<p>Вы можете найти больше информации о символах (<code>char</code>) в <a href="http://doc.rust-lang.org/std/primitive.char.html">документации к
стандартной библиотеке (англ.)</a>.</p>
<p><a name="numeric-types"></a></p>
<h1><a class="header" href="#Числовые-типы" id="Числовые-типы">Числовые типы</a></h1>
<p>Rust имеет целый ряд числовых типов, разделённых на несколько категорий:
знаковые и беззнаковые, фиксированного и переменного размера, числа с плавающей
точкой и целые числа.</p>
<p>Эти типы состоят из двух частей: категория и размер. Например, <code>u16</code>
представляет собой тип без знака с размером в шестнадцать бит. Чем большим
количеством бит представлен тип, тем большее число мы можем задать.</p>
<p>Если для числового литерала не указан тип, то он будет выведен по умолчанию:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 42; // x имеет тип i32

let y = 1.0; // y имеет тип f64
#}</code></pre></pre>
<p>Ниже представлен список различных числовых типов, со ссылками на их документацию
в стандартной библиотеке:</p>
<ul>
<li><a href="http://doc.rust-lang.org/std/primitive.i8.html">i8</a></li>
<li><a href="http://doc.rust-lang.org/std/primitive.i16.html">i16</a></li>
<li><a href="http://doc.rust-lang.org/std/primitive.i32.html">i32</a></li>
<li><a href="http://doc.rust-lang.org/std/primitive.i64.html">i64</a></li>
<li><a href="http://doc.rust-lang.org/std/primitive.u8.html">u8</a></li>
<li><a href="http://doc.rust-lang.org/std/primitive.u16.html">u16</a></li>
<li><a href="http://doc.rust-lang.org/std/primitive.u32.html">u32</a></li>
<li><a href="http://doc.rust-lang.org/std/primitive.u64.html">u64</a></li>
<li><a href="http://doc.rust-lang.org/std/primitive.isize.html">isize</a></li>
<li><a href="http://doc.rust-lang.org/std/primitive.usize.html">usize</a></li>
<li><a href="http://doc.rust-lang.org/std/primitive.f32.html">f32</a></li>
<li><a href="http://doc.rust-lang.org/std/primitive.f64.html">f64</a></li>
</ul>
<p>Давайте пройдёмся по их категориям.</p>
<h2><a class="header" href="#Знаковые-и-беззнаковые" id="Знаковые-и-беззнаковые">Знаковые и беззнаковые</a></h2>
<p>Целые типы бывают двух видов: знаковые и беззнаковые. Чтобы понять разницу,
давайте рассмотрим число с размером в четыре бита. Знаковые четырёхбитные числа,
позволяют хранить значения от <code>-8</code> до <code>+7</code>. Знаковые числа используют
представление «дополнение до двух» (дополнительный код). Беззнаковые
четырёхбитные числа, ввиду того что не нужно хранить отрицательные значения,
позволяют хранить значения от <code>0</code> до <code>+15</code>.</p>
<p>Беззнаковые типы используют <code>u</code> для своей категории, а знаковые типы используют
<code>i</code>. <code>i</code> означает «integer». Так, <code>u8</code> представляет собой число без знака с
размером восемь бит, а <code>i8</code> представляет собой число со знаком с размером восемь
бит.</p>
<h2><a class="header" href="#Типы-фиксированного-размера" id="Типы-фиксированного-размера">Типы фиксированного размера</a></h2>
<p>Типы с фиксированным размером соответственно имеют фиксированное количество бит
в своём представлении. Допустимыми размерами являются <code>8</code>, <code>16</code>, <code>32</code>, <code>64</code>.
Таким образом, <code>u32</code> представляет собой целое число без знака с размером 32
бита, а <code>i64</code> — целое число со знаком с размером 64 бита.</p>
<h2><a class="header" href="#Типы-переменного-размера" id="Типы-переменного-размера">Типы переменного размера</a></h2>
<p>Rust также предоставляет типы, размер которых зависит от размера указателя на
целевой машине. Эти типы имеют «size» в названии в качестве признака размера, и
могут быть знаковыми или беззнаковыми. Таким образом, существует два типа:
<code>isize</code> и <code>usize</code>.</p>
<h2><a class="header" href="#С-плавающей-точкой" id="С-плавающей-точкой">С плавающей точкой</a></h2>
<p>В Rust также есть два типа с плавающей точкой: <code>f32</code> и <code>f64</code>. Они соответствуют
IEEE-754 числам с плавающей точкой одинарной и двойной точности соответственно.</p>
<h1><a class="header" href="#Массивы" id="Массивы">Массивы</a></h1>
<p>В Rust, как и во многих других языках программирования, есть
типы-последовательности, для представления последовательностей неких вещей.
Самый простой из них — это <em>массив</em>, то есть последовательность элементов одного
и того же типа, имеющая фиксированный размер. Массивы неизменяемы по умолчанию.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [1, 2, 3]; // a: [i32; 3]
let mut m = [1, 2, 3]; // m: [i32; 3]
#}</code></pre></pre>
<p>Массивы имеют тип <code>[T; N]</code>. О значении <code>T</code> мы поговорим позже, когда будем
рассматривать <a href="generics.html">обобщённое программирование</a>. <code>N</code> — это константа
времени компиляции, представляющая собой длину массива.</p>
<p>Для инициализации всех элементов массива одним и тем же значением есть
специальный синтаксис. В этом примере каждый элемент <code>a</code> будет инициализирован
значением <code>0</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [0; 20]; // a: [i32; 20]
#}</code></pre></pre>
<p>Вы можете получить число элементов массива <code>a</code> с помощью метода <code>a.len()</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [1, 2, 3];

println!(&quot;Число элементов в a: {}&quot;, a.len());
#}</code></pre></pre>
<p>Вы можете получить определённый элемент массива с помощью <em>индекса</em>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let names = [&quot;Graydon&quot;, &quot;Brian&quot;, &quot;Niko&quot;]; // names: [&amp;str; 3]

println!(&quot;Второе имя: {}&quot;, names[1]);
#}</code></pre></pre>
<p>Индексы нумеруются с нуля, как и в большинстве языков программирования, поэтому
мы получаем первое имя с помощью <code>names[0]</code>, а второе — с помощью <code>names[1]</code>.
Пример выше печатает <code>Второе имя: Brian</code>. Если вы попытаетесь использовать
индекс, который не входит в массив, вы получите ошибку: при доступе к массивам
происходит проверка границ во время исполнения программы. Такая ошибочная
попытка доступа — источник многих проблем в других языках системного
программирования.</p>
<p>Вы можете найти больше информации о массивах (<code>array</code>) в
<a href="http://doc.rust-lang.org/std/primitive.array.html">документации к стандартной библиотеке (англ.)</a>.</p>
<p><a name="slices"></a></p>
<h1><a class="header" href="#Срезы" id="Срезы">Срезы</a></h1>
<p><em>Срез</em> — это ссылка на (или «проекция» в) другую структуру данных. Они полезны,
когда нужно обеспечить безопасный, эффективный доступ к части массива без
копирования. Например, возможно вам нужно сослаться на единственную строку
файла, считанного в память. Из-за своей ссылочной природы, срезы создаются не
напрямую, а из существующих связанных имён. У срезов есть длина, они могут быть
изменяемы или неизменяемы.</p>
<h2><a class="header" href="#Синтаксис-срезов" id="Синтаксис-срезов">Синтаксис срезов</a></h2>
<p>Для создания срезов из различных сущностей можно использовать комбинации <code>&amp;</code> и
<code>[]</code>. Символ <code>&amp;</code> указывает на то, что срезы схожи со ссылками, а в квадратных
скобках указывается диапазон, задающий длину среза:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let a = [0, 1, 2, 3, 4];
let complete = &amp;a[..]; // Срез, содержащий все элементы массива `a`
let middle = &amp;a[1..4]; // Срез `a`: только элементы 1, 2, и 3
#}</code></pre></pre>
<p>Срезы имеют тип <code>&amp;[T]</code>. О значении <code>T</code> мы поговорим позже, когда будем
рассматривать <a href="generics.html">обобщённое программирование</a>.</p>
<p>Вы можете найти больше информации о срезах (<code>slice</code>) в <a href="http://doc.rust-lang.org/std/primitive.slice.html">документации к
стандартной библиотеке (англ.)</a>.</p>
<h1><a class="header" href="#str" id="str"><code>str</code></a></h1>
<p>Тип <code>str</code> в Rust является наиболее простым типом строк. Это
<a href="unsized-types.html">безразмерный тип</a>, поэтому сам по себе он не очень полезен, но он
становится полезным при использовании ссылки, <a href="strings.html"><code>&amp;str</code></a>. Пока просто
остановимся на этом.</p>
<p>Вы можете найти больше информации о строках (<code>str</code>) в <a href="http://doc.rust-lang.org/std/primitive.str.html">документации к
стандартной библиотеке (англ.)</a>.</p>
<p><a name="tuples"></a></p>
<h1><a class="header" href="#Кортежи" id="Кортежи">Кортежи</a></h1>
<p>Кортеж — это последовательность фиксированного размера. Вроде такой:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = (1, &quot;привет&quot;);
#}</code></pre></pre>
<p>Этот кортеж из двух элементов создан с помощью скобок и запятой между
элементами. Вот тот же код, но с аннотациями типов:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x: (i32, &amp;str) = (1, &quot;привет&quot;);
#}</code></pre></pre>
<p>Как вы можете видеть, тип кортежа выглядит как сам кортеж, но места элементов
занимают типы. Внимательные читатели также отметят, что кортежи гетерогенны: в
этом кортеже одновременно хранятся значения типов <code>i32</code> и <code>&amp;str</code>. В языках
системного программирования строки немного более сложны, чем в других языках.
Пока вы можете читать <code>&amp;str</code> как <em>срез строки</em>. Мы вскоре узнаем об этом больше.</p>
<p>Можно присваивать один кортеж другому, если они содержат значения одинаковых
типов и имеют одинаковую <a href="glossary.html#arity">арность</a>. Арность кортежей одинакова, когда их
длина совпадает.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut x = (1, 2); // x: (i32, i32)
let y = (2, 3); // y: (i32, i32)

x = y;
#}</code></pre></pre>
<p>Стоит отметить и ещё один момент, касающийся длины кортежей: кортеж нулевой
длины (<code>()</code>; пустой кортеж) часто называют «единичным значением».
Соответственно, тип такого значения — «единичный тип».</p>
<p>Доступ к полям кортежа можно получить с помощью <em>деконструирующего let</em>. Вот
пример:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let (x, y, z) = (1, 2, 3);

println!(&quot;x это {}&quot;, x);
#}</code></pre></pre>
<p>Помните, мы <a href="variable-bindings.html">говорили</a>, что левая часть оператора <code>let</code> может больше, чем
просто присваивать имена? Мы имели ввиду то, что приведено выше. Мы можем
написать слева от <code>let</code> шаблон, и, если он совпадает со значением справа,
произойдёт присваивание имён сразу нескольким значениям. В данном случае, <code>let</code>
«деконструирует» или «разбивает» кортеж, и присваивает его части трём именам.</p>
<p>Это очень удобный шаблон программирования, и мы ещё не раз увидим его.</p>
<p>Вы можете устранить неоднозначность трактовки для кортежа, состоящего из одного
элемента, и значения в скобках с помощью запятой:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
(0,); // одноэлементный кортеж
(0); // ноль в круглых скобках
#}</code></pre></pre>
<h2><a class="header" href="#Индексация-кортежей" id="Индексация-кортежей">Индексация кортежей</a></h2>
<p>Вы также можете получить доступ к полям кортежа с помощью индексации:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let tuple = (1, 2, 3);

let x = tuple.0;
let y = tuple.1;
let z = tuple.2;

println!(&quot;x is {}&quot;, x);
#}</code></pre></pre>
<p>Как и в случае индексации массивов, индексы начинаются с нуля, но здесь, в
отличие от массивов, используется <code>.</code>, а не <code>[]</code>.</p>
<p>Вы можете найти больше информации о кортежах (<code>tuple</code>) в <a href="http://doc.rust-lang.org/std/primitive.tuple.html">документации к
стандартной библиотеке (англ.)</a>.</p>
<h1><a class="header" href="#Функции" id="Функции">Функции</a></h1>
<p>Функции тоже имеют тип! Это выглядит следующим образом:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(x: i32) -&gt; i32 { x }

let x: fn(i32) -&gt; i32 = foo;
#}</code></pre></pre>
<p>В данном примере <code>x</code> — это «указатель на функцию», которая принимает в качестве
аргумента <code>i32</code> и возвращает <code>i32</code>.</p>
<p>% Комментарии</p>
<p>Теперь, когда у нас есть несколько функций, неплохо бы узнать о комментариях.
Комментарии — это заметки, которые вы оставляете для других программистов, чтобы
помочь объяснить некоторые вещи в вашем коде. Компилятор в основном игнорирует
их («в основном», потому что есть документирующие комментарии и примеры в
документации).</p>
<p>В Rust есть два вида комментариев: <em>строчные комментарии</em> и <em>doc-комментарии</em>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Строчные комментарии — это всё что угодно после '//' и до конца строки.

let x = 5; // это тоже строчный комментарий.

// Если у вас длинное объяснение для чего-либо, вы можете расположить строчные
// комментарии один за другим. Поместите пробел между '//' и вашим комментарием,
// так как это более читаемо.
#}</code></pre></pre>
<p>Другое применение комментария — это doc-комментарий. Doc-комментарий использует
<code>///</code> вместо <code>//</code>, и поддерживает Markdown-разметку внутри:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Прибавляем единицу к заданному числу.
///
/// # Examples
///
/// ```
/// let five = 5;
///
/// assert_eq!(6, add_one(5));
/// ```
fn add_one(x: i32) -&gt; i32 {
    x + 1
}
#}</code></pre></pre>
<p>При написании doc-комментария очень полезно добавлять разделы для аргументов,
возвращаемых значений и привести некоторые примеры использования. Заметьте, что
здесь мы использовали новый макрос: <code>assert_eq!</code>. Он сравнивает два значения и
вызывает <code>panic!</code>, если они не равны. Для документации такие примеры очень
полезны. Так же есть и другой макрос, <code>assert!</code>, который вызывает <code>panic!</code> когда
значение равно <code>false</code>.</p>
<p>Вы можете использовать <a href="documentation.html"><code>rustdoc</code></a> для генерации HTML-
документации из этих doc-комментариев, а так же запуска кода из примеров как
тестов.</p>
<p>% Конструкция <code>if</code></p>
<p><code>if</code> в Rust не сильно сложен и больше похож на <code>if</code> в динамически типизированных
языках, чем на более традиционный из системных. Давайте поговорим о нём, чтобы
вы поняли некоторые его нюансы.</p>
<p><code>if</code> является одной из форм более общего понятия, именуемого <em>ветвлением</em>. Это
название произошло от ветвей деревьев: конечный результат зависит от того, какой
из нескольких вариантов будет выбран.</p>
<p><code>if</code> содержит одно условие, в зависимости от которого будет выполняться одна из
двух ветвей:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;

if x == 5 {
    println!(&quot;x равняется пяти!&quot;);
}
#}</code></pre></pre>
<p>При изменении значения <code>x</code> на какое-либо другое, эта строчка не будет выведена
на экран. Если подробнее, то когда условие будет иметь значение <code>true</code>,
следующий после него блок кода выполнится. В противном случае — нет.</p>
<p>Бывает нужно что-то выполнить, если условие не выполнится (выражение будет иметь 
значение false). В таком случае можно использовать <code>else</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;

if x == 5 {
    println!(&quot;x равняется пяти!&quot;);
} else {
    println!(&quot;x это не пять :(&quot;);
}
#}</code></pre></pre>
<p>Когда необходимо больше одного выбора, можно использовать <code>else if</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;

if x == 5 {
    println!(&quot;x равняется пяти!&quot;);
} else if x == 6 {
    println!(&quot;x это шесть!&quot;);
} else {
    println!(&quot;x это ни пять, ни шесть :(&quot;);
}
#}</code></pre></pre>
<p>Всё это довольно прозаично. Однако, вы также можете сделать такую штуку:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;

let y = if x == 5 {
    10
} else {
    15
}; // y: i32
#}</code></pre></pre>
<p>Которую мы можем (и должны) записать примерно следующим образом:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;

let y = if x == 5 { 10 } else { 15 }; // y: i32
#}</code></pre></pre>
<p>Это работает, потому что <code>if</code> является выражением. Его значением является
значение последнего выражения из выбранной ветви. <code>if</code> без <code>else</code> всегда
возвращает <code>()</code> в качестве значения.</p>
<p>% Циклы</p>
<p>На данный момент в Rust есть три способа организовать циклическое исполнение
кода. Это <code>loop</code>, <code>while</code> и <code>for</code>. У каждого подхода своё применение.</p>
<h2><a class="header" href="#Циклы-loop" id="Циклы-loop">Циклы <code>loop</code></a></h2>
<p>Бесконечный цикл (<code>loop</code>) — простейшая форма цикла в Rust. С помощью этого
ключевого слова можно организовать цикл, который продолжается, пока не
выполнится какой-либо оператор, прерывающий его. Бесконечный цикл в Rust
выглядит так:</p>
<pre><code class="language-rust ignore">loop {
    println!(&quot;Зациклились!&quot;);
}
</code></pre>
<h2><a class="header" href="#Циклы-while" id="Циклы-while">Циклы <code>while</code></a></h2>
<p>Цикл <code>while</code> — это ещё один вид конструкции цикла в Rust. Выглядит он так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut x = 5; // mut x: i32
let mut done = false; // mut done: bool

while !done {
    x += x - 3;

    println!(&quot;{}&quot;, x);

    if x % 5 == 0 {
        done = true;
    }
}
#}</code></pre></pre>
<p>Он применяется, если неизвестно, сколько раз нужно выполнить тело цикла, чтобы
получить результат. При каждой итерации цикла проверяется условие, и если оно
истинно, то запускается следующая итерация. Иначе цикл <code>while</code> завершается.</p>
<p>Если вам нужен бесконечный цикл, то можете сделать условие всегда истинным:</p>
<pre><code class="language-rust ignore">while true {
</code></pre>
<p>Однако, для такого случая в Rust имеется ключевое слово <code>loop</code>:</p>
<pre><code class="language-rust ignore">loop {
</code></pre>
<p>В Rust анализатор потока управления обрабатывает конструкцию <code>loop</code> иначе, чем
<code>while true</code>, хотя для нас это одно и тоже. На данном этапе изучения Rust нам не
важно знать в чем именно различие между этими конструкциями, но если вы хотите
сделать бесконечный цикл, то используйте конструкцию <code>loop</code>. Компилятор
сможет транслировать ваш код в более эффективный и безопасный машинный код.</p>
<p><a name="for"></a></p>
<h2><a class="header" href="#Циклы-for" id="Циклы-for">Циклы <code>for</code></a></h2>
<p>Цикл <code>for</code> нужен для повторения блока кода определённое количество раз. Циклы
<code>for</code> в Rust работают немного иначе, чем в других языках программирования.
Например в Си-подобном языке цикл <code>for</code> выглядит так:</p>
<pre><code class="language-c">for (x = 0; x &lt; 10; x++) {
    printf( &quot;%d\n&quot;, x );
}
</code></pre>
<p>Однако, этот код в Rust будет выглядеть следующим образом:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for x in 0..10 {
    println!(&quot;{}&quot;, x); // x: i32
}
#}</code></pre></pre>
<p>Можно представить цикл более абстрактно:</p>
<pre><code class="language-ignore">for переменная in выражение {
    тело_цикла
}
</code></pre>
<p>Выражение — это <a href="iterators.html">итератор</a>. Их мы будем рассматривать позже в этом
руководстве. Итератор возвращает серию элементов, где каждый элемент будет
являться одной итерацией цикла. Значение этого элемента затем присваивается
<code>переменной</code>, которая будет доступна в теле цикла. После окончания тела цикла,
берётся следующее значение итератора и снова выполняется тело цикла. Когда в
итераторе закончатся значения, цикл <code>for</code> завершается.</p>
<p>В нашем примере, <code>0..10</code> — это выражение, которое задаёт начальное и конечное
значение, и возвращает итератор. Обратите внимание, что конечное значение не
включается в него. В нашем примере будут напечатаны числа от <code>0</code> до <code>9</code>, но не
будет напечатано <code>10</code>.</p>
<p>В Rust намеренно нет цикла <code>for</code> в стиле C. Управлять каждым элементом цикла
вручную сложно, и это может приводить к ошибкам даже у опытных программистов на
C.</p>
<h3><a class="header" href="#Перечисление" id="Перечисление">Перечисление</a></h3>
<p>Если вы хотите отслеживать число прошедших итераций, используйте функцию
<code>.enumerate()</code>.</p>
<h4><a class="header" href="#С-интервалами" id="С-интервалами">С интервалами</a></h4>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for (i,j) in (5..10).enumerate() {
    println!(&quot;i = {} и j = {}&quot;, i, j);
}
#}</code></pre></pre>
<p>Выводит:</p>
<pre><code class="language-text">i = 0 и j = 5
i = 1 и j = 6
i = 2 и j = 7
i = 3 и j = 8
i = 4 и j = 9
</code></pre>
<p>Не забудьте написать скобки вокруг интервала.</p>
<h4><a class="header" href="#С-итераторами" id="С-итераторами">С итераторами</a></h4>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let lines = &quot;привет\nмир\nhello\nworld&quot;.lines();
for (linenumber, line) in lines.enumerate() {
    println!(&quot;{}: {}&quot;, linenumber, line);
}
#}</code></pre></pre>
<p>Outputs:</p>
<pre><code class="language-text">0: привет
1: мир
2: hello
3: world
</code></pre>
<h2><a class="header" href="#Раннее-прерывание-цикла" id="Раннее-прерывание-цикла">Раннее прерывание цикла</a></h2>
<p>Давайте ещё раз посмотрим на цикл <code>while</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut x = 5;
let mut done = false;

while !done {
    x += x - 3;

    println!(&quot;{}&quot;, x);

    if x % 5 == 0 {
        done = true;
    }
}
#}</code></pre></pre>
<p>В этом примере в условии для выхода из цикла используется изменяемое имя <code>done</code>
логического типа. В Rust имеются два ключевых слова, которые помогают работать с
итерациями цикла: <code>break</code> и <code>continue</code>.</p>
<p>Мы можем переписать цикл с помощью <code>break</code>, чтобы избавиться от переменной
<code>done</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut x = 5;

loop {
    x += x - 3;

    println!(&quot;{}&quot;, x);

    if x % 5 == 0 { break; }
}
#}</code></pre></pre>
<p>Теперь мы используем бесконечный цикл <code>loop</code> и <code>break</code> для выхода из цикла.
Использование явного <code>return</code> также остановит выполнение цикла.</p>
<p><code>continue</code> похож на <code>break</code>, но вместо выхода из цикла переходит к следующей
итерации. Следующий пример отобразит только нечётные числа:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for x in 0..10 {
    if x % 2 == 0 { continue; }

    println!(&quot;{}&quot;, x);
}
#}</code></pre></pre>
<h2><a class="header" href="#Метки-циклов" id="Метки-циклов">Метки циклов</a></h2>
<p>Когда у вас много вложенных циклов, вы можете захотеть указать, к какому именно
циклу относится <code>break</code> или <code>continue</code>. Как и во многих других языках, по
умолчанию эти операторы будут относиться к самому внутреннему циклу. Если вы
хотите прервать внешний цикл, вы можете использовать метку. Так, этот код будет
печатать на экране только когда и <code>x</code>, и <code>y</code> нечётны:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
'outer: for x in 0..10 {
    'inner: for y in 0..10 {
        if x % 2 == 0 { continue 'outer; } // продолжает цикл по x
        if y % 2 == 0 { continue 'inner; } // продолжает цикл по y
        println!(&quot;x: {}, y: {}&quot;, x, y);
    }
}
#}</code></pre></pre>
<p>% Владение</p>
<p>Эта глава является одной из трёх, описывающих систему владения ресурсами Rust.
Эта система представляет собой наиболее уникальную и привлекательную особенность
Rust, о которой разработчики должны иметь полное представление. Владение — это
то, как Rust достигает своей главной цели — безопасности памяти. Система
владения включает в себя несколько различных концепций, каждая из которых
рассматривается в своей собственной главе:</p>
<ul>
<li>владение, её вы читаете сейчас</li>
<li><a href="references-and-borrowing.html">заимствование</a>, и связанная с ним возможность «ссылки»</li>
<li><a href="lifetimes.html">время жизни</a>, расширение понятия заимствования</li>
</ul>
<p>Эти три главы взаимосвязаны, и их порядок важен. Вы должны будете освоить все
три главы, чтобы полностью понять систему владения.</p>
<h1><a class="header" href="#Мета" id="Мета">Мета</a></h1>
<p>Прежде чем перейти к подробностям, отметим два важных момента в системе
владения.</p>
<p>Rust сфокусирован на безопасности и скорости. Это достигается за счёт
«абстракций с нулевой стоимостью» (zero-cost abstractions). Это значит, что в
Rust стоимость абстракций должна быть настолько малой, насколько это возможно
без ущерба для работоспособности. Система владения ресурсами — это яркий пример
абстракции с нулевой стоимостью. Весь анализ, о котором мы будем говорить в этом
руководстве, выполняется <em>во время компиляции</em>. Во время исполнения вы не
платите за какую-либо из возможностей ничего.</p>
<p>Тем не менее, эта система всё же имеет определённую стоимость: кривая обучения.
Многие новые пользователи Rust «борются с проверкой заимствования» — компилятор
Rust отказывается компилировать программу, которая по мнению автора является
абсолютно правильной. Это часто происходит потому, что мысленное представление
программиста о том, как должно работать владение, не совпадает с реальными
правилами, которыми оперирует Rust. Вы, наверное, поначалу также будете
испытывать подобные трудности. Однако существует и хорошая новость: более
опытные разработчики на Rust говорят, что чем больше они работают с правилами
системы владения, тем меньше они борются с компилятором.</p>
<p>Имея это в виду, давайте перейдём к изучению системы владения.</p>
<h1><a class="header" href="#Владение" id="Владение">Владение</a></h1>
<p><a href="variable-bindings.html">Связанные имена</a> имеют одну особенность в Rust: они «владеют» тем, с
чем они связаны. Это означает, что, когда имя выходит за пределы области
видимости, ресурс, с которым оно связано, будет освобождён. Например:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo() {
    let v = vec![1, 2, 3];
}
#}</code></pre></pre>
<p>Когда <code>v</code> входит в область видимости, создаётся новый <a href="http://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a>. В данном
случае вектор также выделяет из <a href="the-stack-and-the-heap.html">кучи</a> пространство для трёх элементов.
Когда <code>v</code> выходит из области видимости в конце <code>foo()</code>, Rust очищает все,
связанное с вектором, даже динамически выделенную память. Это происходит
детерминировано, в конце области видимости.</p>
<p><a name="move-semantics"></a></p>
<h1><a class="header" href="#Семантика-перемещения" id="Семантика-перемещения">Семантика перемещения</a></h1>
<p>Хотя тут есть некоторые тонкости: Rust гарантирует, что существует <em>ровно одно</em>
связывание какого-либо ресурса. Например, если у нас есть вектор, то мы можем
присвоить этот вектор другому имени:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3];

let v2 = v;
#}</code></pre></pre>
<p>Но, если после этого мы попытаемся использовать <code>v</code>, то получим ошибку:</p>
<pre><code class="language-rust ignore">let v = vec![1, 2, 3];

let v2 = v;

println!(&quot;v[0] = {}&quot;, v[0]);
</code></pre>
<p>Ошибка выглядит следующим образом:</p>
<pre><code class="language-text">error: use of moved value: `v`
println!(&quot;v[0] = {}&quot;, v[0]);
                        ^
</code></pre>
<p>То же самое произойдёт, если мы определим функцию, которая принимает владение, и
попробуем использовать значение после того, как мы передали это значение в
качестве аргумента в эту функцию:</p>
<pre><code class="language-rust ignore">fn take(v: Vec&lt;i32&gt;) {
    // что будет здесь не очень важно
}

let v = vec![1, 2, 3];

take(v);

println!(&quot;v[0] = {}&quot;, v[0]);
</code></pre>
<p>Та же самая ошибка: «use of moved value» («используется перемещённое значение»).
Когда мы передаём право владения куда-то ещё, мы как бы говорим, что мы
«перемещаем» то, на что ссылаемся. При этом не нужно указывать какую-либо
специальную аннотацию, Rust делает это по умолчанию.</p>
<h2><a class="header" href="#Подробности" id="Подробности">Подробности</a></h2>
<p>Причина, по которой мы не можем использовать значение после того, как мы его
переместили, неочевидна, но очень важна. Когда мы пишем код вроде этого:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3];

let v2 = v;
#}</code></pre></pre>
<p>Первая строка создаёт некоторые данные для вектора в <a href="the-stack-and-the-heap.html">стеке</a>, <code>v</code>. Данные
самого вектора, однако, сохраняются в <a href="the-stack-and-the-heap.html">куче</a>, и поэтому стековые данные
содержат указатель на данные в куче. Когда мы перемещаем <code>v</code> в <code>v2</code>, то
создаётся копия стековых данных для <code>v2</code>. Что будет означать, что два указателя
ссылаются на расположенный в куче вектор. Такое поведение могло бы быть
проблемой: оно нарушало бы гарантии безопасности Rust, привнося гонки по данным.
Поэтому Rust запрещает использование <code>v</code> после того, как мы выполнили его
перемещение.</p>
<p>Важно также отметить, что оптимизация может удалить саму копию байтов на стеке,
в зависимости от обстоятельств. Так что это может быть не так уж неэффективно,
как выглядит на первый взгляд.</p>
<h2><a class="header" href="#Типы-реализующие-типаж-copy" id="Типы-реализующие-типаж-copy">Типы, реализующие типаж <code>Copy</code></a></h2>
<p>Мы установили, что как только владение передаётся другому имени, вы больше не
можете использовать исходное. Тем не менее, существует <a href="traits.html">типаж</a>, который
изменяет такое поведение, и он называется <code>Copy</code>. Мы ещё не обсуждали типажи, но
пока вы можете думать о них как об аннотациях к конкретному типу, которые
придают дополнительное поведение. Например:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = 1;

let v2 = v;

println!(&quot;v = {}&quot;, v);
#}</code></pre></pre>
<p>В этом примере <code>v</code> связан с типом <code>i32</code>. Этот тип реализует типаж <code>Copy</code>. Это
означает, что когда мы присваиваем значение <code>v</code> имени <code>v2</code>, будет создана копия
данных, как и при перемещении. Но, в отличие от перемещения, мы можем
использовать <code>v</code> в дальнейшем. Это происходит потому, что в <code>i32</code> нет указателей
на данные в каком-либо другом месте. При таком копировании создаётся полная
копия.</p>
<p>Мы будем обсуждать, как сделать свои собственные типы, реализующие типаж <code>Copy</code>
в разделе <a href="traits.html">Типажи</a>.</p>
<h1><a class="header" href="#Больше-чем-владение" id="Больше-чем-владение">Больше, чем владение</a></h1>
<p>Конечно, если бы нам нужно было вернуть владение обратно из функции, то мы бы
написали:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(v: Vec&lt;i32&gt;) -&gt; Vec&lt;i32&gt; {
    // делаем что-либо с v

    // возвращаем владение
    v
}
#}</code></pre></pre>
<p>Это сильно утомляет. Функция становится тем хуже, чем больше прав владения она
хочет забрать себе:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(v1: Vec&lt;i32&gt;, v2: Vec&lt;i32&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;i32&gt;, i32) {
    // делаем что-нибудь с v1 и v2

    // возвращаем владение и результат нашей функции
    (v1, v2, 42)
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let (v1, v2, answer) = foo(v1, v2);
#}</code></pre></pre>
<p>Брр! Возвращаемый тип, строка возврата, и вызов функции получается намного 
более сложным.</p>
<p>К счастью, Rust предлагает такую возможность, как заимствование, которая
помогает нам  решить эту проблему. Это тема следующего раздела!</p>
<p>% Ссылки и заимствование</p>
<p>Эта глава является одной из трёх, описывающих систему владения ресурсами Rust.
Эта система представляет собой наиболее уникальную и привлекательную особенность
Rust, о которой разработчики должны иметь полное представление. Владение — это
то, как Rust достигает своей главной цели — безопасности памяти. Система
владения включает в себя несколько различных концепций, каждая из которых
рассматривается в своей собственной главе:</p>
<ul>
<li><a href="ownership.html">владение</a>, ключевая концепция</li>
<li>заимствование, её вы читаете сейчас</li>
<li><a href="lifetimes.html">время жизни</a>, расширение понятия заимствования</li>
</ul>
<p>Эти три главы взаимосвязаны, и их порядок важен. Вы должны будете освоить все
три главы, чтобы полностью понять систему владения.</p>
<h1><a class="header" href="#Мета-1" id="Мета-1">Мета</a></h1>
<p>Прежде чем перейти к подробностям, отметим два важных момента в системе
владения.</p>
<p>Rust сфокусирован на безопасности и скорости. Это достигается за счёт
«абстракций с нулевой стоимостью» (zero-cost abstractions). Это значит, что в
Rust стоимость абстракций должна быть настолько малой, насколько это возможно
без ущерба для работоспособности. Система владения ресурсами — это яркий пример
абстракции с нулевой стоимостью. Весь анализ, о котором мы будем говорить в этом
руководстве, выполняется <em>во время компиляции</em>. Во время исполнения вы не
платите за какую-либо из возможностей ничего.</p>
<p>Тем не менее, эта система всё же имеет определённую стоимость: кривая обучения.
Многие новые пользователи Rust «борются с проверкой заимствования» — компилятор
Rust отказывается компилировать программу, которая по мнению автора является
абсолютно правильной. Это часто происходит потому, что мысленное представление
программиста о том, как должно работать владение, не совпадает с реальными
правилами, которыми оперирует Rust. Вы, наверное, поначалу также будете
испытывать подобные трудности. Однако существует и хорошая новость: более
опытные разработчики на Rust говорят, что чем больше они работают с правилами
системы владения, тем меньше они борются с компилятором.</p>
<p>Имея это в виду, давайте перейдём к изучению системы владения.</p>
<p><a name="borrowing"></a></p>
<h1><a class="header" href="#Заимствование" id="Заимствование">Заимствование</a></h1>
<p>В конце главы <a href="ownership.html">Владение</a> у нас была убогая функция, которая выглядела
так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(v1: Vec&lt;i32&gt;, v2: Vec&lt;i32&gt;) -&gt; (Vec&lt;i32&gt;, Vec&lt;i32&gt;, i32) {
    // делаем что-нибудь с v1 и v2

    // возвращаем владение и результат нашей функции
    (v1, v2, 42)
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let (v1, v2, answer) = foo(v1, v2);
#}</code></pre></pre>
<p>Однако, этот код не является идиоматичным с точки зрения Rust, так как он не
использует заимствование. Вот первый шаг:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(v1: &amp;Vec&lt;i32&gt;, v2: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    // делаем что-нибудь с v1 и v2

    // возвращаем ответ
    42
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let answer = foo(&amp;v1, &amp;v2);

// Мы можем и дальше использовать v1 и v2!
#}</code></pre></pre>
<p>Вместо того, чтобы принимать <code>Vec&lt;i32&gt;</code> в качестве аргументов, мы будем
принимать ссылки: <code>&amp;Vec&lt;i32&gt;</code>. И вместо передачи <code>v1</code> и <code>v2</code> напрямую, мы будем
передавать <code>&amp;v1</code> и <code>&amp;v2</code>. Мы называем тип <code>&amp;T</code> «ссылка», и вместо того, чтобы
забирать владение ресурсом, она его заимствует. Имена, которые заимствуют что-
то, не освобождают ресурс, когда они выходят из области видимости. Это означает,
что, после вызова <code>foo()</code>, мы снова можем использовать наши исходные имена.</p>
<p>Ссылки являются неизменяемыми, как и имена. Это означает, что внутри <code>foo()</code>
векторы не могут быть изменены:</p>
<pre><code class="language-rust ignore">fn foo(v: &amp;Vec&lt;i32&gt;) {
     v.push(5);
}

let v = vec![];

foo(&amp;v);
</code></pre>
<p>выдаёт ошибку:</p>
<pre><code class="language-text">error: cannot borrow immutable borrowed content `*v` as mutable
v.push(5);
^
</code></pre>
<p>Добавление значения изменяет вектор, и поэтому компилятор не позволил нам это
сделать.</p>
<h1><a class="header" href="#Ссылки-mut" id="Ссылки-mut">Ссылки &amp;mut</a></h1>
<p>Вот второй вид ссылок: <code>&amp;mut T</code>. Это «изменяемая ссылка», которая позволяет
изменять ресурс, который вы заимствуете. Например:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut x = 5;
{
    let y = &amp;mut x;
    *y += 1;
}
println!(&quot;{}&quot;, x);
#}</code></pre></pre>
<p>Этот код напечатает <code>6</code>. Мы создали <code>y</code>, изменяемую ссылку на <code>x</code>, а затем
добавили единицу к значению, на которое указывает <code>y</code>. Следует отметить, что <code>x</code>
также должно быть помечено как <code>mut</code>. Если бы этого не было, то мы не могли бы
получить изменяемую ссылку неизменяемого значения.</p>
<p>Вы также заметили что мы добавили звездочку (<code>*</code>) перед <code>y</code>. Это сделано из-за того, 
что <code>y</code> - это ссылка и сама данных не содержит. Вам нужно использовать (<code>*</code>), для того
чтобы получить доступ непосредственно к содержимому на которое указывает ссылка.</p>
<p>Во всем остальном изменяемые ссылки (<code>&amp;mut</code>) такие же, как и неизменяемые (<code>&amp;</code>).
Однако, существует большая разница между этими двумя концепциями, и тем, как они
взаимодействуют. Вы можете сказать, что в приведённом выше примере есть что-то
подозрительное, потому что нам зачем-то понадобилась дополнительная область
видимости, созданная с помощью <code>{</code> и <code>}</code>. Если мы уберем эти скобки, то получим
ошибку:</p>
<pre><code class="language-text">error: cannot borrow `x` as immutable because it is also borrowed as mutable
    println!(&quot;{}&quot;, x);
                   ^
note: previous borrow of `x` occurs here; the mutable borrow prevents
subsequent moves, borrows, or modification of `x` until the borrow ends
        let y = &amp;mut x;
                     ^
note: previous borrow ends here
fn main() {

}
^
</code></pre>
<p>Оказывается, есть определённые правила создания ссылок.</p>
<h1><a class="header" href="#Правила" id="Правила">Правила</a></h1>
<p>Вот правила заимствования в Rust.</p>
<p>Во-первых, область видимости любой ссылки должна находиться в пределах области
видимости владельца. Во-вторых, одновременно у вас может быть только один из
двух перечисленных ниже видов заимствования, но не оба сразу:</p>
<ul>
<li>одна или более неизменяемых ссылок (<code>&amp;T</code>) на ресурс;</li>
<li>ровно одна изменяемая ссылка (<code>&amp;mut T</code>) на ресурс.</li>
</ul>
<p>Вы можете заметить, что это похоже, хотя и не соответствует точно, определению
состояния гонки данных:</p>
<blockquote>
<p>Состояние «гонки данных» возникает, когда два или более указателей
осуществляют доступ к одной и той же области памяти одновременно, по крайней
мере один из них производит запись, и операции не синхронизированы.</p>
</blockquote>
<p>Что касается неизменяемых ссылок, то вы можете иметь их столько, сколько хотите,
так как ни одна из них не производит запись. Если же вы производите запись, и
вам нужно два или больше указателей на одну и ту же область памяти, то вы можете
иметь только одну <code>&amp;mut</code> одновременно. Так Rust предотвращает возникновение
состояния гонки данных во время компиляции: мы получим ошибку компиляции, если
нарушим эти правила.</p>
<p>Имея это в виду, давайте рассмотрим наш пример еще раз.</p>
<h2><a class="header" href="#Осмысливаем-области-видимости-thinking-in-scopes" id="Осмысливаем-области-видимости-thinking-in-scopes">Осмысливаем области видимости (Thinking in scopes)</a></h2>
<p>Вот код:</p>
<pre><code class="language-rust ignore">let mut x = 5;
let y = &amp;mut x;

*y += 1;

println!(&quot;{}&quot;, x);
</code></pre>
<p>Этот код выдает нам такую ошибку:</p>
<pre><code class="language-text">error: cannot borrow `x` as immutable because it is also borrowed as mutable
    println!(&quot;{}&quot;, x);
                   ^
</code></pre>
<p>Это потому, что мы нарушили правила: у нас есть изменяемая ссылка <code>&amp;mut T</code>,
указывающая на <code>x</code>, и поэтому мы не можем создать какую-либо <code>&amp;T</code>. Одно из двух.
Примечание подсказывает как следует рассматривать эту проблему:</p>
<pre><code class="language-text">note: previous borrow ends here
fn main() {

}
^
</code></pre>
<p>Другими словами, изменяемая ссылка сохраняется до конца нашего примера. А мы
хотим, чтобы изменяемое заимствование заканчивалось <em>до</em> того, как мы пытаемся
вызвать <code>println!</code> и создать неизменяемое заимствование. В Rust заимствование
привязано к области видимости, в которой оно является действительным. И эти
области видимости выглядят следующим образом:</p>
<pre><code class="language-rust ignore">let mut x = 5;

let y = &amp;mut x;    // -+ заимствование x через &amp;mut начинается здесь
                   //  |
*y += 1;           //  |
                   //  |
println!(&quot;{}&quot;, x); // -+ - пытаемся позаимствовать x здесь
                   // -+ заимствование x через &amp;mut заканчивается здесь
</code></pre>
<p>Конфликт областей видимости: мы не можем создать <code>&amp;x</code> до тех пор, пока <code>y</code>
находится в области видимости.</p>
<p>Поэтому, когда мы добавляем фигурные скобки:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut x = 5;

{                   
    let y = &amp;mut x; // -+ заимствование через &amp;mut начинается здесь
    *y += 1;        //  |
}                   // -+ ... и заканчивается здесь

println!(&quot;{}&quot;, x);  // &lt;- пытаемся позаимствовать x здесь
#}</code></pre></pre>
<p>Никаких проблем нет. Наша изменяемая ссылка выходит из области видимости до
создания неизменяемой. Но область видимости является ключом к определению того,
как долго длится заимствование.</p>
<h2><a class="header" href="#Проблемы-которые-предотвращает-заимствование" id="Проблемы-которые-предотвращает-заимствование">Проблемы, которые предотвращает заимствование</a></h2>
<p>Почему нужны эти ограничивающие правила? Ну, как мы уже отметили, эти правила
предотвращают гонки данных. Какие виды проблем могут привести к состоянию гонки
данных? Вот некоторые из них.</p>
<h3><a class="header" href="#Недействительный-итератор" id="Недействительный-итератор">Недействительный итератор</a></h3>
<p>Одним из примеров является «недействительный итератор». Такое может произойти,
когда вы пытаетесь изменить коллекцию, которую в данный момент обходите.
Проверка заимствования Rust предотвращает это:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut v = vec![1, 2, 3];

for i in &amp;v {
    println!(&quot;{}&quot;, i);
}
#}</code></pre></pre>
<p>Этот код печатает числа от одного до трёх. Когда мы обходим вектор, мы получаем
лишь ссылки на элементы. И сам <code>v</code> заимствован как неизменяемый, что означает,
что мы не можем изменить его в процессе обхода:</p>
<pre><code class="language-rust ignore">let mut v = vec![1, 2, 3];

for i in &amp;v {
    println!(&quot;{}&quot;, i);
    v.push(34);
}
</code></pre>
<p>Вот ошибка:</p>
<pre><code class="language-text">error: cannot borrow `v` as mutable because it is also borrowed as immutable
    v.push(34);
    ^
note: previous borrow of `v` occurs here; the immutable borrow prevents
subsequent moves or mutable borrows of `v` until the borrow ends
for i in &amp;v {
          ^
note: previous borrow ends here
for i in &amp;v {
    println!(“{}”, i);
    v.push(34);
}
^
</code></pre>
<p>Мы не можем изменить <code>v</code>, потому что он уже заимствован в цикле.</p>
<h3><a class="header" href="#Использование-после-освобождения-use-after-free" id="Использование-после-освобождения-use-after-free">Использование после освобождения (use after free)</a></h3>
<p>Ссылки не должны жить дольше, чем ресурс, на который они ссылаются. Rust
проверяет области видимости ваших ссылок, чтобы удостовериться, что это правда.</p>
<p>Если Rust не будет проверять это свойство, то мы можем случайно использовать
ссылку, которая будет недействительна. Например:</p>
<pre><code class="language-rust ignore">let y: &amp;i32;
{
    let x = 5;
    y = &amp;x;
}

println!(&quot;{}&quot;, y);
</code></pre>
<p>Мы получим следующую ошибку:</p>
<pre><code class="language-text">error: `x` does not live long enough
    y = &amp;x;
         ^
note: reference must be valid for the block suffix following statement 0 at
2:16...
let y: &amp;i32;
{
    let x = 5;
    y = &amp;x;
}

note: ...but borrowed value is only valid for the block suffix following
statement 0 at 4:18
    let x = 5;
    y = &amp;x;
}
</code></pre>
<p>Другими словами, <code>y</code> действителен только для той области видимости, где
существует <code>x</code>. Как только <code>x</code> выходит из области видимости, ссылка на него
становится недействительной. Таким образом, ошибка сообщает, что заимствование
«не живет достаточно долго» («does not live long enough»), потому что оно не
является действительным столько времени, сколько требуется.</p>
<p>Такая же проблема возникает, когда ссылка объявлена <em>перед</em> значением, на
которое она ссылается. Это происходит потому что ресурсы в одном блоке
освобождаются в порядке, противоположном порядку их объявления:</p>
<pre><code class="language-rust ignore">let y: &amp;i32;
let x = 5;
y = &amp;x;

println!(&quot;{}&quot;, y);
</code></pre>
<p>Мы получим такую ошибку:</p>
<pre><code class="language-text">error: `x` does not live long enough
y = &amp;x;
     ^
note: reference must be valid for the block suffix following statement 0 at
2:16...
    let y: &amp;i32;
    let x = 5;
    y = &amp;x;

    println!(&quot;{}&quot;, y);
}

note: ...but borrowed value is only valid for the block suffix following
statement 1 at 3:14
    let x = 5;
    y = &amp;x;

    println!(&quot;{}&quot;, y);
}
</code></pre>
<p>В примере выше <code>y</code> объявлена перед <code>x</code>, т.е. живёт дольше <code>x</code>, а это запрещено.</p>
<p>% Время жизни</p>
<p>Эта глава является одной из трёх, описывающих систему владения ресурсами Rust.
Эта система представляет собой наиболее уникальную и привлекательную особенность
Rust, о которой разработчики должны иметь полное представление. Владение — это
то, как Rust достигает своей главной цели — безопасности памяти. Система
владения включает в себя несколько различных концепций, каждая из которых
рассматривается в своей собственной главе:</p>
<ul>
<li><a href="ownership.html">владение</a>, ключевая концепция</li>
<li><a href="references-and-borrowing.html">заимствование</a>, и связанная с ним возможность «ссылки»</li>
<li>время жизни, её вы читаете сейчас</li>
</ul>
<p>Эти три главы взаимосвязаны, и их порядок важен. Вы должны будете освоить все
три главы, чтобы полностью понять систему владения.</p>
<h1><a class="header" href="#Мета-2" id="Мета-2">Мета</a></h1>
<p>Прежде чем перейти к подробностям, отметим два важных момента в системе
владения.</p>
<p>Rust сфокусирован на безопасности и скорости. Это достигается за счёт
«абстракций с нулевой стоимостью» (zero-cost abstractions). Это значит, что в
Rust стоимость абстракций должна быть настолько малой, насколько это возможно
без ущерба для работоспособности. Система владения ресурсами — это яркий пример
абстракции с нулевой стоимостью. Весь анализ, о котором мы будем говорить в этом
руководстве, выполняется <em>во время компиляции</em>. Во время исполнения вы не
платите за какую-либо из возможностей ничего.</p>
<p>Тем не менее, эта система всё же имеет определённую стоимость: кривая обучения.
Многие пользователи Rust занимаются тем, что мы зовём «борьбой с проверкой
заимствования» — компилятор Rust отказывается компилировать программу, которая
по мнению автора является абсолютно правильной. Это часто происходит потому, что
мысленное представление программиста о том, как должно работать владение, не
совпадает с реальными правилами, которыми оперирует Rust. Вы, наверное, поначалу
также будете испытывать подобные трудности. Однако существует и хорошая новость:
более опытные разработчики на Rust говорят, что чем больше они работают с
правилами системы владения, тем меньше они борются с компилятором.</p>
<p>Имея это в виду, давайте перейдём к изучению системы владения.</p>
<h1><a class="header" href="#Время-жизни" id="Время-жизни">Время жизни</a></h1>
<p>Одалживание ссылки на ресурс, которым кто-то владеет, может быть довольно
сложным. Например, представьте себе следующую последовательность операций:</p>
<ul>
<li>Мы получаем абстрактную ссылку на какой-то ресурс.</li>
<li>Мы одалживаем вам ссылку на этот ресурс.</li>
<li>Мы решаем, что ресурс нам больше не требуется, и освобождаем его, в то время
как у вас все еще есть на него ссылка.</li>
<li>Вы решаете использовать этот ресурс.</li>
</ul>
<p>Ой-ой! Ваша ссылка указывает на недопустимый ресурс. Это называется «висячий
указатель» или «использование после освобождения», когда ресурсом является
память.</p>
<p>Чтобы исправить это, мы должны убедиться, что четвертый шаг никогда не
произойдет после третьего. Система владения в Rust делает это через понятие
времени жизни, которое описывает область видимости, на протяжении которой ссылка
будет действительна.</p>
<p>Когда у нас есть функция, которая принимает ссылку в качестве аргумента, мы
можем явно или неявно указать время жизни ссылки:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// неявно
fn foo(x: &amp;i32) {
}

// явно
fn bar&lt;'a&gt;(x: &amp;'a i32) {
}
#}</code></pre></pre>
<p>Читается <code>'a</code> как «время жизни a». Технически, все ссылки имеют некоторое время
жизни, связанное с ними, но компилятор позволяет опускать его в общих случаях.
Прежде чем мы перейдем к этому, давайте разберем пример ниже, с явным указанием
времени жизни:</p>
<pre><code class="language-rust ignore">fn bar&lt;'a&gt;(...)
</code></pre>
<p>Эта часть объявляет параметры времени жизни. Она говорит, что <code>bar</code> имеет один
параметр времени жизни, <code>'a</code>. Если бы в качестве параметров функции у нас было
две ссылки, то это выглядело бы так:</p>
<pre><code class="language-rust ignore">fn bar&lt;'a, 'b&gt;(...)
</code></pre>
<p>Затем в списке параметров функции мы используем заданные параметры времени
жизни:</p>
<pre><code class="language-rust ignore">...(x: &amp;'a i32)
</code></pre>
<p>Если бы мы хотели <code>&amp;mut</code> ссылку, то сделали бы так:</p>
<pre><code class="language-rust ignore">...(x: &amp;'a mut i32)
</code></pre>
<p>Если вы сравните <code>&amp;mut i32</code> с <code>&amp;'a mut i32</code>, то увидите, что они отличаются
только определением времени жизни <code>'a</code>, написанным между <code>&amp;</code> и <code>mut i32</code>. <code>&amp;mut i32</code> читается как «изменяемая ссылка на i32», а <code>&amp;'a mut i32</code> — как «изменяемая
ссылка на i32 со временем жизни 'a».</p>
<h2><a class="header" href="#Внутри-a-hrefstructshtmlstructaов" id="Внутри-a-hrefstructshtmlstructaов">Внутри <a href="structs.html"><code>struct</code></a>'ов</a></h2>
<p>Вы также должны будете явно указать время жизни при работе со
<a href="structs.html"><code>struct</code></a>'ми:</p>
<pre><pre class="playpen"><code class="language-rust">struct Foo&lt;'a&gt; {
    x: &amp;'a i32,
}

fn main() {
    let y = &amp;5; // то же самое, что и `let _y = 5; let y = &amp;_y;`
    let f = Foo { x: y };

    println!(&quot;{}&quot;, f.x);
}
</code></pre></pre>
<p>Как вы можете заметить, структуры также могут иметь время жизни. Так же как и
функции,</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Foo&lt;'a&gt; {
# x: &amp;'a i32,
# }
#}</code></pre></pre>
<p>объявляет время жизни и</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Foo&lt;'a&gt; {
x: &amp;'a i32,
# }
#}</code></pre></pre>
<p>использует его. Почему же мы должны определять время жизни здесь? Мы должны
убедиться, что ссылка на <code>Foo</code> не может жить дольше, чем ссылка на <code>i32</code>,
содержащаяся в нем.</p>
<h2><a class="header" href="#Блоки-impl" id="Блоки-impl">Блоки <code>impl</code></a></h2>
<p>Давайте реализуем метод для <code>Foo</code>:</p>
<pre><pre class="playpen"><code class="language-rust">struct Foo&lt;'a&gt; {
    x: &amp;'a i32,
}

impl&lt;'a&gt; Foo&lt;'a&gt; {
    fn x(&amp;self) -&gt; &amp;'a i32 { self.x }
}

fn main() {
    let y = &amp;5; // то же самое, что и `let _y = 5; let y = &amp;_y;`
    let f = Foo { x: y };

    println!(&quot;x is: {}&quot;, f.x());
}
</code></pre></pre>
<p>Как вы можете видеть, нам нужно объявить время жизни для <code>Foo</code> в строке с
<code>impl</code>. Мы повторяем <code>'a</code> дважды, как в функциях: <code>impl&lt;'a&gt;</code> определяет  время
жизни <code>'a</code>, и <code>Foo&lt;'a&gt;</code> использует его.</p>
<h2><a class="header" href="#Несколько-времён-жизни-multiple-lifetimes" id="Несколько-времён-жизни-multiple-lifetimes">Несколько времён жизни (Multiple lifetimes)</a></h2>
<p>Если вы имеете несколько ссылок, вы можете использовать одно и то же время
жизни несколько раз:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn x_or_y&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
#}</code></pre></pre>
<p>Этот код говорит, что <code>x</code> и <code>y</code> находятся в одной области видимости друг с
другом, и что возвращаемое значение живо на протяжении той же области видимости.
Если вы хотите, чтобы <code>x</code> и <code>y</code> имели разные времена жизни, вы должны
использовать параметры нескольких времён жизни:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn x_or_y&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;'a str {
#}</code></pre></pre>
<p>В этом примере <code>x</code> и <code>y</code> имеют различные области видимости, но возвращаемое
значение имеет то же время жизни, что и <code>x</code>.</p>
<h2><a class="header" href="#Осмысливаем-области-видимости-thinking-in-scopes-1" id="Осмысливаем-области-видимости-thinking-in-scopes-1">Осмысливаем области видимости (Thinking in scopes)</a></h2>
<p>Один из способов понять, что же такое время жизни — это визуализировать область,
в которой ссылка является действительной. Например:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let y = &amp;5;     // -+ y входит в область видимости
                    //  |
    // что-то       //  |
                    //  |
}                   // -+ y выходит из области видимости
</code></pre></pre>
<p>Добавим нашу структуру <code>Foo</code>:</p>
<pre><pre class="playpen"><code class="language-rust">struct Foo&lt;'a&gt; {
    x: &amp;'a i32,
}

fn main() {
    let y = &amp;5;           // -+ y входит в область видимости
    let f = Foo { x: y }; // -+ f входит в область видимости
    // что-то             //  |
                          //  |
}                         // -+ f и y выходят из области видимости
</code></pre></pre>
<p>Наша <code>f</code> живет в области видимости <code>y</code>, поэтому все работает. Что же произойдёт,
если это будет не так? Этот код не будет работать:</p>
<pre><code class="language-rust ignore">struct Foo&lt;'a&gt; {
    x: &amp;'a i32,
}

fn main() {
    let x;                    // -+ x входит в область видимости
                              //  |
    {                         //  |
        let y = &amp;5;           // ---+ y входит в область видимости
        let f = Foo { x: y }; // ---+ f входит в область видимости
        x = &amp;f.x;             //  | | здесь ошибка
    }                         // ---+ f и y выходят из области видимости
                              //  |
    println!(&quot;{}&quot;, x);        //  |
}                             // -+ x выходит из области видимости
</code></pre>
<p>Уф! Как вы можете видеть здесь, области видимости <code>f</code> и <code>y</code> меньше, чем область
видимости <code>x</code>. Но когда мы выполняем <code>x = &amp;f.x</code>, мы присваиваем <code>x</code> ссылку на
что-то, что вот-вот выйдет из области видимости.</p>
<p>Присвоение имени времени жизни — это способ задать имя области видимости. Чтобы
думать о чём-то, нужно иметь название для этого.</p>
<h2><a class="header" href="#static" id="static">'static</a></h2>
<p>Время жизни с именем «static» — особенное. Оно обозначает, что что-то имеет
время жизни, равное времени жизни всей программы. Большинство программистов на
Rust впервые сталкиваются с <code>'static</code>, когда имеют дело со строками:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x: &amp;'static str = &quot;Привет, мир.&quot;;
#}</code></pre></pre>
<p>Строковые литералы имеют тип <code>&amp;'static str</code>, потому что ссылка всегда
действительна: строки располагаются в сегменте данных конечного двоичного файла.
Другой пример — глобальные переменные:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
static FOO: i32 = 5;
let x: &amp;'static i32 = &amp;FOO;
#}</code></pre></pre>
<p>В этом примере <code>i32</code> добавляется в сегмент данных двоичного файла, а <code>x</code>
ссылается на него.</p>
<h2><a class="header" href="#Опускание-времени-жизни" id="Опускание-времени-жизни">Опускание времени жизни</a></h2>
<p>В Rust есть мощный локальный вывод типов. Однако, сигнатуры объявлений верхнего
уровня не выводятся, чтобы можно было рассуждать о типах на основании одних лишь
сигнатур. Из соображений удобства, введён ограниченный механизм вывода типов
сигнатур функций, называемый «опускание времени жизни» («lifetime elision»). Он
выводит типы на основании только элементов сигнатуры — тело функции при этом не
учитывается. При этом его назначение — это вывести лишь параметры времени жизни
аргументов. Для этого он реализует три простых правила. Таким образом, опускание
времени жизни упрощает написание сигнатур, одновременно не скрывая реальные типы
аргументов.</p>
<p>Когда речь идет о неявном времени жизни, мы используем термины <em>входное время
жизни</em> (<em>input lifetime</em>) и <em>выходное время жизни</em> (<em>output lifetime</em>). <em>Входное
время жизни</em> связано с передаваемыми в функцию параметрами, а <em>выходное время
жизни</em> связано с возвращаемым функцией значением. Например, эта функция имеет
входное время жизни:</p>
<pre><code class="language-rust ignore">fn foo&lt;'a&gt;(bar: &amp;'a str)
</code></pre>
<p>А эта имеет выходное время жизни:</p>
<pre><code class="language-rust ignore">fn foo&lt;'a&gt;() -&gt; &amp;'a str
</code></pre>
<p>Эта же имеет как входное, так и выходное время жизни:</p>
<pre><code class="language-rust ignore">fn foo&lt;'a&gt;(bar: &amp;'a str) -&gt; &amp;'a str
</code></pre>
<p>Ниже представлены три правила:</p>
<ul>
<li>
<p>Каждое неявное время жизни в аргументах функции становится отдельным
временем жизни.</p>
</li>
<li>
<p>Если есть ровно одно входное время жизни, явное или неявное, то это время
жизни назначается всем неявным выходным временам жизни.</p>
</li>
<li>
<p>Если есть несколько входных времён жизни, но одно из них это <code>&amp;self</code> или <code>&amp;mut self</code>, то всем неявным выходным временам жизни назначается время жизни <code>self</code>.</p>
</li>
</ul>
<p>В противном случае, неявное задание выходного времени жизни является ошибкой.</p>
<h3><a class="header" href="#Примеры" id="Примеры">Примеры</a></h3>
<p>Вот некоторые примеры функций, представленные в двух видах: с явно и неявно
заданным временем жизни:</p>
<pre><code class="language-rust ignore">fn print(s: &amp;str); // неявно
fn print&lt;'a&gt;(s: &amp;'a str); // явно

fn debug(lvl: u32, s: &amp;str); // неявно
fn debug&lt;'a&gt;(lvl: u32, s: &amp;'a str); // явно

// В предыдущем примере для `lvl` не требуется указывать время жизни, потому что
// это не ссылка (`&amp;`). Только элементы, связанные с ссылками (например, такие
// как структура, содержащая ссылку) требуют указания времени жизни.

fn substr(s: &amp;str, until: u32) -&gt; &amp;str; // неявно
fn substr&lt;'a&gt;(s: &amp;'a str, until: u32) -&gt; &amp;'a str; // явно

fn get_str() -&gt; &amp;str; // НЕКОРРЕКТНО, нет входных параметров

fn frob(s: &amp;str, t: &amp;str) -&gt; &amp;str; // НЕКОРРЕКТНО, два входных параметра
fn frob&lt;'a, 'b&gt;(s: &amp;'a str, t: &amp;'b str) -&gt; &amp;str; // Развёрнуто: Выходное время жизни неясно

fn get_mut(&amp;mut self) -&gt; &amp;mut T; // неявно
fn get_mut&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a mut T; // явно

fn args&lt;T:ToCStr&gt;(&amp;mut self, args: &amp;[T]) -&gt; &amp;mut Command // неявно
fn args&lt;'a, 'b, T:ToCStr&gt;(&amp;'a mut self, args: &amp;'b [T]) -&gt; &amp;'a mut Command // явно

fn new(buf: &amp;mut [u8]) -&gt; BufWriter; // неявно
fn new&lt;'a&gt;(buf: &amp;'a mut [u8]) -&gt; BufWriter&lt;'a&gt; // явно
</code></pre>
<p>% Изменяемость (mutability)</p>
<p>Изменяемость, то есть возможность изменить что-то, работает в Rust несколько
иначе, чем в других языках. Во-первых, по умолчанию связанные имена не
изменяемы:</p>
<pre><code class="language-rust ignore">let x = 5;
x = 6; // ошибка!
</code></pre>
<p>Изменяемость можно добавить с помощью ключевого слова <code>mut</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut x = 5;

x = 6; // нет проблем!
#}</code></pre></pre>
<p>Это изменяемое <a href="variable-bindings.html">связанное имя</a>. Когда связанное имя изменяемо, это означает,
что мы можем поменять связанное с ним значение. В примере выше не то, чтобы само
значение <code>x</code> менялось, просто имя <code>x</code> связывается с другим значением типа <code>i32</code>.</p>
<p>Если же вы хотите изменить само связанное значение, вам понадобится
<a href="references-and-borrowing.html">изменяемая ссылка</a>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut x = 5;
let y = &amp;mut x;
#}</code></pre></pre>
<p><code>y</code> — это неизменяемое имя для изменяемой ссылки. Это значит, что <code>y</code> нельзя
связать ещё с чем-то (<code>y = &amp;mut z</code>), но можно изменить то, на что указывает
связанная ссылка (<code>*y = 5</code>). Тонкая разница.</p>
<p>Конечно, вы можете объявить и изменяемое имя для изменяемой ссылки:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut x = 5;
let mut y = &amp;mut x;
#}</code></pre></pre>
<p>Теперь <code>y</code> можно связать с другим значением, и само это значение тоже можно
менять.</p>
<p>Стоит отметить, что <code>mut</code> — это часть <a href="patterns.html">шаблона</a>, поэтому можно делать
такие вещи:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let (mut x, y) = (5, 6);

fn foo(mut x: i32) {
# }
#}</code></pre></pre>
<h1><a class="header" href="#Внутренняя-interior-и-внешняя-exterior-изменяемость" id="Внутренняя-interior-и-внешняя-exterior-изменяемость">Внутренняя (interior) и внешняя (exterior) изменяемость</a></h1>
<p>Однако, когда мы говорим, что что-либо «неизменяемо» в Rust, это не означает,
что оно совсем не может измениться. Мы говорим о «внешней изменяемости». Для
примера рассмотрим <a href="http://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::sync::Arc;

let x = Arc::new(5);
let y = x.clone();
#}</code></pre></pre>
<p>Когда мы вызываем метод <code>clone()</code>, <code>Arc&lt;T&gt;</code> должна обновить счётчик ссылок. Мы
не использовали модификатор <code>mut</code>, а значит <code>x</code> — неизменяемое имя. Мы не можем
получить ссылку (<code>&amp;mut 5</code>) или сделать что-то подобное. И что же?</p>
<p>Для того чтобы понять это, мы должны вернуться назад к основам философии Rust,
к сохранности памяти и механизму, гарантирующему это, к системе
<a href="ownership.html">владения</a>, и, в частности, к <a href="references-and-borrowing.html#borrowing">заимствованию</a>:</p>
<blockquote>
<p>Одновременно у вас может быть только один из двух перечисленных ниже видов
заимствования, но не оба сразу:</p>
<ul>
<li>одна или более неизменяемых ссылок (<code>&amp;T</code>) на ресурс,</li>
<li>ровно одна изменяемая ссылка (<code>&amp;mut T</code>) на ресурс.</li>
</ul>
</blockquote>
<p>Итак, что же здесь на самом деле является «неизменяемым»? Безопасно ли иметь два
указателя на один объект? В случае с <code>Arc&lt;T&gt;</code>, да: изменяемый объект полностью
находится внутри самой структуры. По этой причине, метод <code>clone()</code> возвращает
неизменяемую ссылку (<code>&amp;T</code>). Если бы он возвращал изменяемую ссылку (<code>&amp;mut T</code>),
то у нас были бы проблемы. Таким образом, <code>let mut z = Arc::new(5);</code> объявляет
атомарный счётчик ссылок с внешней изменяемостью.</p>
<p>Другие типы, например те, что определены в модуле <a href="http://doc.rust-lang.org/std/cell/index.html"><code>std::cell</code></a>,
напротив, имеют «внутреннюю изменяемость». Например:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::cell::RefCell;

let x = RefCell::new(42);

let y = x.borrow_mut();
#}</code></pre></pre>
<p>RefCell возвращает изменяемую ссылку <code>&amp;mut</code> при помощи метода <code>borrow_mut()</code>. А
не опасно ли это? Что, если мы сделаем так:</p>
<pre><code class="language-rust ignore">use std::cell::RefCell;

let x = RefCell::new(42);

let y = x.borrow_mut();
let z = x.borrow_mut();
# (y, z);
</code></pre>
<p>Это приведёт к панике во время исполнения. Вот что делает <code>RefCell</code>: он
принудительно выполняет проверку правил заимствования во время исполнения и
вызывает <code>panic!</code>, если они были нарушены.</p>
<p>Стоит отметить, что тип изменяемости — внутренняя или внешняя — определяется
самим типом. Нет способа волшебно превратить значение с внутренней изменяемостью
в значение со внешней, и наоборот.</p>
<p>Всё это подводит нас к другим аспектам правил изменяемости Rust. Давайте
поговорим о них.</p>
<h2><a class="header" href="#Изменяемость-на-уровне-полей" id="Изменяемость-на-уровне-полей">Изменяемость на уровне полей</a></h2>
<p>Изменяемость — это свойство либо ссылки (<code>&amp;mut</code>), либо имени (<code>let mut</code>). Это
значит, что, например, у вас не может быть <a href="structs.html">структуры</a>, часть полей
которой изменяется, а другая часть — нет:</p>
<pre><code class="language-rust ignore">struct Point {
    x: i32,
    mut y: i32, // нельзя
}
</code></pre>
<p>Изменяемость структуры определяется при её связывании:</p>
<pre><code class="language-rust ignore">struct Point {
    x: i32,
    y: i32,
}

let mut a = Point { x: 5, y: 6 };

a.x = 10;

let b = Point { x: 5, y: 6};

b.x = 10; // error: cannot assign to immutable field `b.x`
</code></pre>
<p>Однако, используя <a href="http://doc.rust-lang.org/std/cell/struct.Cell.html"><code>Cell&lt;T&gt;</code></a>, вы можете эмулировать изменяемость на
уровне полей:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::cell::Cell;

struct Point {
    x: i32,
    y: Cell&lt;i32&gt;,
}

let point = Point { x: 5, y: Cell::new(6) };

point.y.set(7);

println!(&quot;y: {:?}&quot;, point.y);
#}</code></pre></pre>
<p>Это выведет на экран <code>y: Cell { value: 7 }</code>. Мы успешно изменили значение <code>y</code>.</p>
<p>% Структуры</p>
<p>Структуры (<code>struct</code>) — это один из способов создания более сложных типов данных.
Например, если мы рассчитываем что-то с использованием координат 2D пространства,
то нам понадобятся оба значения — <code>x</code> и <code>y</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let origin_x = 0;
let origin_y = 0;
#}</code></pre></pre>
<p>Структура позволяет нам объединить эти два значения в один тип с <code>x</code> и <code>y</code> в
качестве имен полей:</p>
<pre><pre class="playpen"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let origin = Point { x: 0, y: 0 }; // origin: Point

    println!(&quot;Начало координат находится в ({}, {})&quot;, origin.x, origin.y);
}
</code></pre></pre>
<p>Этот код делает много разных вещей, поэтому давайте разберём его по порядку. Мы
объявляем структуру с помощью ключевого слова <code>struct</code>, за которым следует имя
объявляемой структуры. Обычно, имена типов-структур начинаются с заглавной буквы
и используют чередующийся регистр букв: название <code>PointInSpace</code> выглядит
привычно, а <code>Point_In_Space</code> — нет.</p>
<p>Как всегда, мы можем создать экземпляр нашей структуры с помощью оператора
<code>let</code>. Однако в данном случае мы используем синтаксис вида <code>ключ: значение</code> для
установки значения каждого поля. Порядок инициализации полей не обязательно
должен совпадать с порядком их объявления.</p>
<p>Наконец, поскольку у полей есть имена, мы можем получить к ним доступ с помощью
операции <code>точка</code>: <code>origin.x</code>.</p>
<p>Значения, хранимые в структурах, неизменяемы по умолчанию. В этом плане они не
отличаются от других именованных сущностей. Чтобы они стали изменяемы,
используйте ключевое слово <code>mut</code>:</p>
<pre><pre class="playpen"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let mut point = Point { x: 0, y: 0 };

    point.x = 5;

    println!(&quot;Точка находится в ({}, {})&quot;, point.x, point.y);
}
</code></pre></pre>
<p>Этот код напечатает <code>Точка находится в (5, 0)</code>.</p>
<p>Rust не поддерживает изменяемость отдельных полей, поэтому вы не можете написать
что-то вроде такого:</p>
<pre><code class="language-rust ignore">struct Point {
    mut x: i32,
    y: i32,
}
</code></pre>
<p>Изменяемость — это свойство имени, а не самой структуры. Если вы привыкли к
управлению изменяемостью на уровне полей, сначала это может показаться
непривычным, но на самом деле такое решение сильно упрощает вещи. Оно даже
позволяет вам делать имена изменяемыми только на короткое время:</p>
<pre><code class="language-rust ignore">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let mut point = Point { x: 0, y: 0 };

    point.x = 5;

    let point = point; // это новое имя неизменяемо

    point.y = 6; // это вызывает ошибку
}
</code></pre>
<p>Структуры так же могут содержать <code>&amp;mut</code> ссылки, это позволяет вам производить
подобные преобразования:</p>
<pre><pre class="playpen"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

struct PointRef&lt;'a&gt; {
    x: &amp;'a mut i32,
    y: &amp;'a mut i32,
}

fn main() {
    let mut point = Point { x: 0, y: 0 };

    {
        let r = PointRef { x: &amp;mut point.x, y: &amp;mut point.y };

        *r.x = 5;
        *r.y = 6;
    }

    assert_eq!(5, point.x);
    assert_eq!(6, point.y);
}
</code></pre></pre>
<h1><a class="header" href="#Синтаксис-обновления-update-syntax" id="Синтаксис-обновления-update-syntax">Синтаксис обновления (update syntax)</a></h1>
<p>Вы можете включить в описание структуры <code>..</code> чтобы показать, что вы хотите
использовать значения полей какой-то другой структуры. Например:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Point3d {
    x: i32,
    y: i32,
    z: i32,
}

let mut point = Point3d { x: 0, y: 0, z: 0 };
point = Point3d { y: 1, .. point };
#}</code></pre></pre>
<p>Этот код присваивает <code>point</code> новое <code>y</code>, но оставляет старые <code>x</code> и <code>z</code>. Это не
обязательно должна быть та же самая структура — вы можете использовать этот
синтаксис когда создаёте новые структуры, чтобы скопировать значения неуказанных
полей:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Point3d {
#     x: i32,
#     y: i32,
#     z: i32,
# }
let origin = Point3d { x: 0, y: 0, z: 0 };
let point = Point3d { z: 1, x: 2, .. origin };
#}</code></pre></pre>
<h1><a class="header" href="#Кортежные-структуры" id="Кортежные-структуры">Кортежные структуры</a></h1>
<p>В Rust есть ещё один тип данных, который представляет собой нечто среднее между
<a href="primitive-types.html#tuples">кортежем</a> и структурой. Он называется <em>кортежной структурой</em>. Кортежные
структуры именуются, а вот у их полей имён нет:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
#}</code></pre></pre>
<p>Эти два объекта различны, несмотря на то, что у них одинаковые значения.</p>
<p>Почти всегда, вместо кортежной структуры лучше использовать обычную структуру.
Мы бы скорее объявили типы <code>Color</code> и <code>Point</code> вот так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Color {
    red: i32,
    blue: i32,
    green: i32,
}

struct Point {
    x: i32,
    y: i32,
    z: i32,
}
#}</code></pre></pre>
<p>Хорошие имена важны, и хотя значения в кортежной структуре могут быть так же
получены с помощью операции <code>точка</code>, структуры дают нам настоящее имя, а не
позицию.</p>
<p>Однако, <em>есть</em> один случай, когда кортежные структуры очень полезны. Это
кортежная структура с всего одним элементом. Такое использование называется
<em>новым типом</em>, потому что оно позволяет создать новый тип, отличный от типа
значения, содержащегося в кортежной структуре. При этом новый тип обозначает
что-то другое:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Inches(i32);

let length = Inches(10);

let Inches(integer_length) = length;
println!(&quot;Длина в дюймах: {}&quot;, integer_length);
#}</code></pre></pre>
<p>Как вы можете видеть в данном примере, извлечь вложенный целый тип можно с
помощью деконструирующего <code>let</code>. Мы обсуждали это выше, в разделе «кортежи». В
данном случае, оператор <code>let Inches(integer_length)</code> присваивает <code>10</code> имени
<code>integer_length</code>.</p>
<h1><a class="header" href="#unit-подобные-структуры" id="unit-подобные-структуры">Unit-подобные структуры</a></h1>
<p>Вы можете объявить структуру без полей вообще:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Electron;

let x = Electron;
#}</code></pre></pre>
<p>Такие структуры называют «unit-подобные» («unit-like»), потому что они похожи
на пустой кортеж <code>()</code>, иногда называемый «unit». Как и кортежные структуры, их
называют новым типом.</p>
<p>Сами по себе они редко бывают полезны (хотя иногда их используют в качестве
меток), но в сочетании с другими возможностями их использование имеет смысл.
Например, для использования библиотеки может быть необходимо создать структуру,
которая реализует определенный <a href="traits.html">типаж</a> для обработки событий. Если у вас
нет данных, которые нужно поместить в структуру, то можно просто создать
unit-подобную структуру.</p>
<p>% Перечисления</p>
<p>В Rust <em>перечисление</em> (<code>enum</code>) — это тип данных, который представляет собой один
из нескольких возможных вариантов. Каждый вариант в перечислении может быть
также связан с другими данными:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Message {
    Quit,
    ChangeColor(i32, i32, i32),
    Move { x: i32, y: i32 },
    Write(String),
}
#}</code></pre></pre>
<p>Синтаксис для объявления вариантов схож с синтаксисом для объявления структур:
у вас могут быть варианты без данных (как unit-подобные структуры), варианты с
именованными данными и варианты с безымянными данными (подобно кортежным
структурам). Варианты перечисления имеют один и тот же тип, и в отличии от
структур не являются определением отдельных типов. Значение перечисления может
соответствовать любому из вариантов. Из-за этого перечисления иногда называют
<em>тип-сумма</em> (<em>sum-type</em>): множество возможных значений перечисления — это сумма
множеств возможных значений каждого варианта.</p>
<p>Мы используем синтаксис <code>::</code> чтобы использовать имя каждого из вариантов. Их
область видимости ограничена именем самого перечисления. Это позволяет
использовать оба варианта из примера ниже совместно:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum Message {
#     Move { x: i32, y: i32 },
# }
let x: Message = Message::Move { x: 3, y: 4 };

enum BoardGameTurn {
    Move { squares: i32 },
    Pass,
}

let y: BoardGameTurn = BoardGameTurn::Move { squares: 1 };
#}</code></pre></pre>
<p>Оба варианта имеют одинаковое имя <code>Move</code>, но поскольку область видимости
каждого из них ограничена именем соответствующего перечисления, они могут быть
использованы без конфликтов.</p>
<p>Значение перечисления, в дополнение к любым данным, которые связаны с ним,
содержит информацию о том, какой именно это вариант. Это иногда называют
<em>размеченное объединение</em> (<em>tagged union</em>), поскольку данные включают в себя
метку, обозначающую что это за тип.</p>
<pre><code class="language-rust ignore">fn process_color_change(msg: Message) {
    let Message::ChangeColor(r, g, b) = msg; // ошибка времени компиляции
}
</code></pre>
<p>То, что пользовательские типы по умолчанию не поддерживают операции, может
показаться довольно ограниченным. Но это ограничение, которое мы всегда можем
преодолеть. Есть два способа: реализовать операцию самостоятельно, или
воспользоваться сопоставлением с образцом с помощью <a href="match.html"><code>match</code></a>, о котором
вы узнаете в следующем разделе. Пока мы еще недостаточно знаем Rust, чтобы
реализовывать операции, но мы научимся делать это в разделе <a href="traits.html"><code>traits</code></a>.</p>
<h1><a class="header" href="#Конструкторы-как-функции" id="Конструкторы-как-функции">Конструкторы как функции</a></h1>
<p>Конструктор перечисления может быть также использован как обычная функция.
Например:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum Message {
# Write(String),
# }
let m = Message::Write(&quot;Hello, world&quot;.to_string());
#}</code></pre></pre>
<p>тоже самое, что и</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum Message {
# Write(String),
# }
fn foo(x: String) -&gt; Message {
    Message::Write(x)
}

let x = foo(&quot;Hello, world&quot;.to_string());
#}</code></pre></pre>
<p>На данный момент это не так уж и полезно для нас, но когда мы перейдем к
<a href="closures.html">замыканиям</a>, мы поговорим о передаче функций в роли аргумента другой
функции. Например, с помощью <a href="iterators.html">итераторов</a> мы можем преобразовывать
вектор строк в вектор состоящий из <code>Message::Write</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum Message {
# Write(String),
# }

let v = vec![&quot;Hello&quot;.to_string(), &quot;World&quot;.to_string()];

let v1: Vec&lt;Message&gt; = v.into_iter().map(Message::Write).collect();
#}</code></pre></pre>
<p>% Конструкция <code>match</code></p>
<p>Простого <code>if</code>/<code>else</code> часто недостаточно, потому что нужно проверить больше, чем
два возможных варианта. Да и к тому же условия в <code>else</code> часто становятся очень
сложными. Как же решить эту проблему?</p>
<p>В Rust есть ключевое слово <code>match</code>, позволяющее заменить группы операторов
<code>if</code>/<code>else</code> чем-то более удобным. Смотрите:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;

match x {
    1 =&gt; println!(&quot;один&quot;),
    2 =&gt; println!(&quot;два&quot;),
    3 =&gt; println!(&quot;три&quot;),
    4 =&gt; println!(&quot;четыре&quot;),
    5 =&gt; println!(&quot;пять&quot;),
    _ =&gt; println!(&quot;что-то ещё&quot;),
}
#}</code></pre></pre>
<p><code>match</code> принимает выражение и выбирает одну из ветвей исполнения согласно его
значению. Каждая <em>ветвь</em> имеет форму <code>значение =&gt; выражение</code>. Выражение ветви
вычисляется, когда значение данной ветви совпадает со значением, принятым
оператором <code>match</code> (в данном случае, <code>x</code>). Эта конструкция называется <code>match</code>
(сопоставление), потому что она выполняет сопоставление значения неким
«шаблонам». Глава «<a href="patterns.html">Шаблоны</a>» описывает все шаблоны, которые можно
использовать в <code>match</code>.</p>
<p>Так в чём же преимущества данной конструкции? Их несколько. Во-первых, ветви
<code>match</code> <em>проверяются на полноту</em>. Видите последнюю ветвь, со знаком
подчёркивания (<code>_</code>)? Если мы удалим её, Rust выдаст ошибку:</p>
<pre><code class="language-text">error: non-exhaustive patterns: `_` not covered
</code></pre>
<p>Другими словами, компилятор сообщает нам, что мы забыли сопоставить какие-то
значения. Поскольку <code>x</code> — это целое число, оно может принимать разные значения —
например, <code>6</code>. Однако, если мы убираем ветвь <code>_</code>, ни одна ветвь не совпадёт,
поэтому такой код не скомпилируется. <code>_</code> — это «совпадение с любым значением».
Если ни одна другая ветвь не совпала, совпадёт ветвь с <code>_</code>. Поскольку в примере
выше есть ветвь с <code>_</code>, мы покрываем всё множество значений <code>x</code>, и наша программа
скомпилируется.</p>
<p><code>match</code> также является выражением. Это значит, что мы можем использовать его в
правой части оператора <code>let</code> или непосредственно как выражение:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;

let numer = match x {
    1 =&gt; &quot;one&quot;,
    2 =&gt; &quot;two&quot;,
    3 =&gt; &quot;three&quot;,
    4 =&gt; &quot;four&quot;,
    5 =&gt; &quot;five&quot;,
    _ =&gt; &quot;something else&quot;,
};
#}</code></pre></pre>
<p>Иногда с помощью <code>match</code> можно удобно преобразовать значения одного типа в
другой.</p>
<h1><a class="header" href="#Сопоставление-с-образцом-для-перечислений" id="Сопоставление-с-образцом-для-перечислений">Сопоставление с образцом для перечислений</a></h1>
<p>Другой полезный способ использования <code>match</code> — обработка возможных вариантов
перечисления:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Message {
    Quit,
    ChangeColor(i32, i32, i32),
    Move { x: i32, y: i32 },
    Write(String),
}

fn quit() { /* ... */ }
fn change_color(r: i32, g: i32, b: i32) { /* ... */ }
fn move_cursor(x: i32, y: i32) { /* ... */ }

fn process_message(msg: Message) {
    match msg {
        Message::Quit =&gt; quit(),
        Message::ChangeColor(r, g, b) =&gt; change_color(r, g, b),
        Message::Move { x: x, y: y } =&gt; move_cursor(x, y),
        Message::Write(s) =&gt; println!(&quot;{}&quot;, s),
    };
}
#}</code></pre></pre>
<p>Как обычно, компилятор Rust проверяет полноту, поэтому в <code>match</code> должна быть
ветвь для каждого варианта перечисления. Если какой-то вариант отсутствует,
программа не скомпилируется и вам придётся использовать <code>_</code>.</p>
<p>Здесь мы не можем использовать обычный <code>if</code> вместо <code>match</code>, в отличие от кода,
который мы видели раньше. Но мы могли бы использовать <a href="if-let.html"><code>if let</code></a> — его
можно воспринимать как сокращённую форму записи <code>match</code>.</p>
<p>% Шаблоны сопоставления <code>match</code></p>
<p>Шаблоны достаточно часто используются в Rust. Мы уже использовали их в разделе
<a href="variable-bindings.html">Связывание переменных</a>, в разделе <a href="match.html">Конструкция <code>match</code></a>, а
также в некоторых других местах. Давайте коротко пробежимся по всем
возможностям, которые можно реализовать с помощью шаблонов!</p>
<p>Быстро освежим в памяти: сопоставлять с шаблоном литералы можно либо напрямую,
либо с использованием символа <code>_</code>, который означает <em>любой</em> случай:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 1;

match x {
    1 =&gt; println!(&quot;один&quot;),
    2 =&gt; println!(&quot;два&quot;),
    3 =&gt; println!(&quot;три&quot;),
    _ =&gt; println!(&quot;что угодно&quot;),
}
#}</code></pre></pre>
<p>Этот код напечатает <code>один</code>.</p>
<h1><a class="header" href="#Сопоставление-с-несколькими-шаблонами" id="Сопоставление-с-несколькими-шаблонами">Сопоставление с несколькими шаблонами</a></h1>
<p>Вы можете сопоставлять с несколькими шаблонами, используя <code>|</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 1;

match x {
    1 | 2 =&gt; println!(&quot;один или два&quot;),
    3 =&gt; println!(&quot;три&quot;),
    _ =&gt; println!(&quot;что угодно&quot;),
}
#}</code></pre></pre>
<p>Этот код напечатает <code>один или два</code>.</p>
<h1><a class="header" href="#Деструктуризация" id="Деструктуризация">Деструктуризация</a></h1>
<p>Если вы работаете с составным типом данных, вроде <a href="structs.html"><code>struct</code></a>, вы можете
разобрать его на части («деструктурировать») внутри шаблона:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x, y } =&gt; println!(&quot;({},{})&quot;, x, y),
}
#}</code></pre></pre>
<p>Мы можем использовать <code>:</code>, чтобы привязать значение к новому имени.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x: x1, y: y1 } =&gt; println!(&quot;({},{})&quot;, x1, y1),
}
#}</code></pre></pre>
<p>Если нас интересуют только некоторые значения, мы можем не давать имена всем
составляющим:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { x, .. } =&gt; println!(&quot;x равен {}&quot;, x),
}
#}</code></pre></pre>
<p>Этот код напечатает <code>x равен 0</code>.</p>
<p>Вы можете использовать это в любом сопоставлении: не обязательно игнорировать
именно первый элемент:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

match origin {
    Point { y, .. } =&gt; println!(&quot;y равен {}&quot;, y),
}
#}</code></pre></pre>
<p>Этот код напечатает <code>y равен 0</code>.</p>
<p>Можно произвести деструктуризацию любого составного типа данных — например,
<a href="primitive-types.html#tuples">кортежей</a> и <a href="enums.html">перечислений</a>.</p>
<h1><a class="header" href="#Игнорирование-связывания" id="Игнорирование-связывания">Игнорирование связывания</a></h1>
<p>Вы можете использовать в шаблоне <code>_</code>, чтобы проигнорировать соответствующее
значение. Например, вот сопоставление <code>Result&lt;T, E&gt;</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let some_value: Result&lt;i32, &amp;'static str&gt; = Err(&quot;Здесь была какая-то ошибка&quot;);
match some_value {
    Ok(value) =&gt; println!(&quot;получили значение: {}&quot;, value),
    Err(_) =&gt; println!(&quot;произошла ошибка&quot;),
}
#}</code></pre></pre>
<p>В первой ветви мы привязываем значение варианта <code>Ok</code> к имени <code>value</code>. А в ветви
обработки варианта <code>Err</code> мы используем <code>_</code>, чтобы проигнорировать конкретную
ошибку, и просто печатаем общее сообщение.</p>
<p><code>_</code> допустим в любом шаблоне, который связывает имена. Это можно использовать,
чтобы проигнорировать части большой структуры:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn coordinate() -&gt; (i32, i32, i32) {
    // создаём и возвращаем какой-то кортеж из трёх элементов
# (1, 2, 3)
}

let (x, _, z) = coordinate();
#}</code></pre></pre>
<p>Здесь мы связываем первый и последний элемент кортежа с именами <code>x</code> и <code>z</code>
соответственно, а второй элемент игнорируем.</p>
<p>Похожим образом, в шаблоне можно использовать <code>..</code>, чтобы проигнорировать
несколько значений.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum OptionalTuple {
    Value(i32, i32, i32),
    Missing,
}

let x = OptionalTuple::Value(5, -2, 3);

match x {
    OptionalTuple::Value(..) =&gt; println!(&quot;Получили кортеж!&quot;),
    OptionalTuple::Missing =&gt; println!(&quot;Вот неудача.&quot;),
}
#}</code></pre></pre>
<p>Этот код печатает <code>Получили кортеж!</code>.</p>
<h1><a class="header" href="#ref-и-ref-mut" id="ref-и-ref-mut">ref и ref mut</a></h1>
<p>Если вы хотите получить <a href="references-and-borrowing.html">ссылку</a>, то используйте ключевое слово <code>ref</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;

match x {
    ref r =&gt; println!(&quot;Получили ссылку на {}&quot;, r),
}
#}</code></pre></pre>
<p>Этот код напечатает <code>Получили ссылку на 5</code>.</p>
<p>Здесь <code>r</code> внутри <code>match</code> имеет тип <code>&amp;i32</code>. Другими словами, ключевое слово <code>ref</code>
<em>создает</em> ссылку, для использования в шаблоне. Если вам нужна изменяемая ссылка,
то <code>ref mut</code> будет работать аналогичным образом:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut x = 5;

match x {
    ref mut mr =&gt; println!(&quot;Получили изменяемую ссылку на {}&quot;, mr),
}
#}</code></pre></pre>
<h1><a class="header" href="#Сопоставление-с-диапазоном" id="Сопоставление-с-диапазоном">Сопоставление с диапазоном</a></h1>
<p>Вы можете сопоставлять с диапазоном значений, используя <code>...</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 1;

match x {
    1 ... 5 =&gt; println!(&quot;от одного до пяти&quot;),
    _ =&gt; println!(&quot;что угодно&quot;),
}
#}</code></pre></pre>
<p>Этот код напечатает <code>от одного до пяти</code>.</p>
<p>Диапазоны в основном используются с числами или одиночными символами (<code>char</code>).</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = '💅';

match x {
    'а' ... 'и' =&gt; println!(&quot;ранняя буква&quot;),
    'к' ... 'я' =&gt; println!(&quot;поздняя буква&quot;),
    _ =&gt; println!(&quot;что-то ещё&quot;),
}
#}</code></pre></pre>
<p>Этот код напечатает <code>что-то ещё</code>.</p>
<h1><a class="header" href="#Связывание" id="Связывание">Связывание</a></h1>
<p>Вы можете связать значение с именем с помощью символа <code>@</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 1;

match x {
    e @ 1 ... 5 =&gt; println!(&quot;получили элемент диапазона {}&quot;, e),
    _ =&gt; println!(&quot;что угодно&quot;),
}
#}</code></pre></pre>
<p>Этот код напечатает <code>получили элемент диапазона 1</code>. Это полезно, когда вы хотите
сделать сложное сопоставление для части структуры данных:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Debug)]
struct Person {
    name: Option&lt;String&gt;,
}

let name = &quot;Steve&quot;.to_string();
let mut x: Option&lt;Person&gt; = Some(Person { name: Some(name) });
match x {
    Some(Person { name: ref a @ Some(_), .. }) =&gt; println!(&quot;{:?}&quot;, a),
    _ =&gt; {}
}
#}</code></pre></pre>
<p>Этот код напечатает <code>Some(&quot;Steve&quot;)</code>: мы связали внутреннюю <code>name</code> с <code>a</code>.</p>
<p>Если вы используете <code>@</code> совместно с <code>|</code>, то вы должны убедиться, что имя
связывается в каждой из частей шаблона:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;

match x {
    e @ 1 ... 5 | e @ 8 ... 10 =&gt; println!(&quot;получили элемент диапазона {}&quot;, e),
    _ =&gt; println!(&quot;что угодно&quot;),
}
#}</code></pre></pre>
<h1><a class="header" href="#Ограничители-шаблонов" id="Ограничители-шаблонов">Ограничители шаблонов</a></h1>
<p>Вы можете ввести <em>ограничители шаблонов</em> (<em>match guards</em>) с помощью <code>if</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum OptionalInt {
    Value(i32),
    Missing,
}

let x = OptionalInt::Value(5);

match x {
    OptionalInt::Value(i) if i &gt; 5 =&gt; println!(&quot;Получили целое больше пяти!&quot;),
    OptionalInt::Value(..) =&gt; println!(&quot;Получили целое!&quot;),
    OptionalInt::Missing =&gt; println!(&quot;Неудача.&quot;),
}
#}</code></pre></pre>
<p>Этот код напечатает <code>Получили целое!</code>.</p>
<p>Если вы используете <code>if</code> с несколькими шаблонами, он применяется к обеим частям:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 4;
let y = false;

match x {
    4 | 5 if y =&gt; println!(&quot;да&quot;),
    _ =&gt; println!(&quot;нет&quot;),
}
#}</code></pre></pre>
<p>Этот код печатает <code>нет</code>, потому что <code>if</code> применяется ко всему <code>4 | 5</code>, а не
только к <code>5</code>. Другими словами, приоритет <code>if</code> выглядит так:</p>
<pre><code class="language-text">(4 | 5) if y =&gt; ...
</code></pre>
<p>а не так:</p>
<pre><code class="language-text">4 | (5 if y) =&gt; ...
</code></pre>
<h1><a class="header" href="#Заключение-2" id="Заключение-2">Заключение</a></h1>
<p>Вот так! Существует много разных способов использования конструкции
сопоставления с шаблоном, и все они могут быть смешаны и состыкованы, в
зависимости от того, что вы хотите сделать:</p>
<pre><code class="language-rust ignore">match x {
    Foo { x: Some(ref name), y: None } =&gt; ...
}
</code></pre>
<p>Шаблоны — это очень мощный инструмент. Используйте их.</p>
<p>% Синтаксис методов</p>
<p>Функции — это хорошо, но если вы хотите вызвать несколько связных функций для
каких-либо данных, то это может быть неудобно. Рассмотрим этот код:</p>
<pre><code class="language-rust ignore">baz(bar(foo));
</code></pre>
<p>Читать данную строку кода следует слева направо, поэтому мы наблюдаем такой
порядок: «baz bar foo». Но он противоположен порядку, в котором функции будут
вызываться: «foo bar baz». Было бы классно записать вызовы в том порядке, в
котором они происходят, не так ли?</p>
<pre><code class="language-rust ignore">foo.bar().baz();
</code></pre>
<p>К счастью, это возможно! Rust предоставляет возможность использовать такой
<em>синтаксис вызова метода</em> с помощью ключевого слова <code>impl</code>.</p>
<h1><a class="header" href="#Вызов-методов" id="Вызов-методов">Вызов методов</a></h1>
<p>Вот как это работает:</p>
<pre><pre class="playpen"><code class="language-rust">struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

fn main() {
    let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };
    println!(&quot;{}&quot;, c.area());
}
</code></pre></pre>
<p>Этот код напечатает <code>12.566371</code>.</p>
<p>Мы создали структуру, которая представляет собой круг. Затем мы написали блок
<code>impl</code> и определили метод <code>area</code> внутри него.</p>
<p>Методы принимают специальный первый параметр, <code>&amp;self</code>. Есть три возможных
варианта: <code>self</code>, <code>&amp;self</code> и <code>&amp;mut self</code>. Вы можете думать об этом специальном
параметре как о <code>x</code> в <code>x.foo()</code>. Три варианта соответствуют трем возможным видам
элемента <code>x</code>: <code>self</code> — если это просто значение в стеке, <code>&amp;self</code> — если это
ссылка и <code>&amp;mut self</code> — если это изменяемая ссылка. Мы передаем параметр <code>&amp;self</code>
в метод <code>area</code>, поэтому мы можем использовать его так же, как и любой другой
параметр. Так как мы знаем, что это <code>Circle</code>, мы можем получить доступ к полю
<code>radius</code> так же, как если бы это была любая другая структура.</p>
<p>По умолчанию следует использовать <code>&amp;self</code>, также как следует предпочитать
заимствование владению, а неизменные ссылки изменяемым. Вот пример, включающий
все три варианта:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn reference(&amp;self) {
       println!(&quot;принимаем self по ссылке!&quot;);
    }

    fn mutable_reference(&amp;mut self) {
       println!(&quot;принимаем self по изменяемой ссылке!&quot;);
    }

    fn takes_ownership(self) {
       println!(&quot;принимаем владение self!&quot;);
    }
}
#}</code></pre></pre>
<h1><a class="header" href="#Цепочка-вызовов-методов" id="Цепочка-вызовов-методов">Цепочка вызовов методов</a></h1>
<p>Итак, теперь мы знаем, как вызвать метод, например <code>foo.bar()</code>. Но что насчет
нашего первоначального примера, <code>foo.bar().baz()</code>? Это называется «цепочка
вызовов», и мы можем сделать это, вернув <code>self</code>.</p>
<pre><pre class="playpen"><code class="language-rust">struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }

    fn grow(&amp;self, increment: f64) -&gt; Circle {
        Circle { x: self.x, y: self.y, radius: self.radius + increment }
    }
}

fn main() {
    let c = Circle { x: 0.0, y: 0.0, radius: 2.0 };
    println!(&quot;{}&quot;, c.area());

    let d = c.grow(2.0).area();
    println!(&quot;{}&quot;, d);
}
</code></pre></pre>
<p>Проверьте тип возвращаемого значения:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Circle;
# impl Circle {
fn grow(&amp;self) -&gt; Circle {
# Circle } }
#}</code></pre></pre>
<p>Мы просто указываем, что возвращается <code>Circle</code>. С помощью этого метода мы можем
создать новый круг, площадь которого будет в 100 раз больше, чем у старого.</p>
<h1><a class="header" href="#Статические-методы" id="Статические-методы">Статические методы</a></h1>
<p>Вы также можете определить методы, которые не принимают параметр <code>self</code>. Вот
шаблон программирования, который очень распространен в коде на Rust:</p>
<pre><pre class="playpen"><code class="language-rust">struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn new(x: f64, y: f64, radius: f64) -&gt; Circle {
        Circle {
            x: x,
            y: y,
            radius: radius,
        }
    }
}

fn main() {
    let c = Circle::new(0.0, 0.0, 2.0);
}
</code></pre></pre>
<p>Этот <em>статический метод</em>, который создает новый <code>Circle</code>. Обратите внимание, что
статические методы вызываются с помощью синтаксиса: <code>Struct::method()</code>, а не
<code>ref.method()</code>.</p>
<h1><a class="header" href="#Шаблон-строитель-builder-pattern" id="Шаблон-строитель-builder-pattern">Шаблон «строитель» (Builder Pattern)</a></h1>
<p>Давайте предположим, что нам нужно, чтобы наши пользователи могли создавать
круги и чтобы у них была возможность задавать только те свойства, которые им
нужны. В противном случае, атрибуты <code>x</code> и <code>y</code> будут <code>0.0</code>, а <code>radius</code> будет
<code>1.0</code>. Rust не поддерживает перегрузку методов, именованные аргументы или
переменное количество аргументов. Вместо этого мы используем шаблон «строитель».
Он выглядит следующим образом:</p>
<pre><pre class="playpen"><code class="language-rust">struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

struct CircleBuilder {
    x: f64,
    y: f64,
    radius: f64,
}

impl CircleBuilder {
    fn new() -&gt; CircleBuilder {
        CircleBuilder { x: 0.0, y: 0.0, radius: 1.0, }
    }

    fn x(&amp;mut self, coordinate: f64) -&gt; &amp;mut CircleBuilder {
        self.x = coordinate;
        self
    }

    fn y(&amp;mut self, coordinate: f64) -&gt; &amp;mut CircleBuilder {
        self.y = coordinate;
        self
    }

    fn radius(&amp;mut self, radius: f64) -&gt; &amp;mut CircleBuilder {
        self.radius = radius;
        self
    }

    fn finalize(&amp;self) -&gt; Circle {
        Circle { x: self.x, y: self.y, radius: self.radius }
    }
}

fn main() {
    let c = CircleBuilder::new()
                .x(1.0)
                .y(2.0)
                .radius(2.0)
                .finalize();

    println!(&quot;площадь: {}&quot;, c.area());
    println!(&quot;x: {}&quot;, c.x);
    println!(&quot;y: {}&quot;, c.y);
}
</code></pre></pre>
<p>Всё, что мы сделали здесь, — это создали ещё одну структуру, <code>CircleBuilder</code>. В
ней мы определили методы строителя. Также мы определили метод <code>area()</code> в
<code>Circle</code>. Мы также сделали еще один метод в <code>CircleBuilder</code>: <code>finalize()</code>. Этот
метод создаёт наш окончательный <code>Circle</code> из строителя. Таким образом, мы можем
использовать методы <code>CircleBuilder</code>, чтобы уточнить создание <code>Circle</code>.</p>
<p>% Вектора</p>
<p>«Вектор» — это динамический или, по-другому, «растущий» массив, реализованный в
виде стандартного библиотечного типа <a href="http://doc.rust-lang.org/std/vec/index.html"><code>Vec&lt;T&gt;</code></a> (где <code>&lt;T&gt;</code> является
<a href="generics.html">обобщённым типом</a>). Вектора всегда размещают данные в куче. Вы можете
создавать их с помощью макроса <code>vec!</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5]; // v: Vec&lt;i32&gt;
#}</code></pre></pre>
<p>(Заметьте, что, в отличие от макроса <code>println!</code>, который мы использовали ранее,
с <code>vec!</code> используются квадратные скобки <code>[]</code>. Rust разрешает использование и
круглых, и квадратных скобок в обеих ситуациях — это просто стилистическое
соглашение.)</p>
<p>Для создания вектора из повторяющихся значений есть другая форма <code>vec!</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![0; 10]; // десять нулей
#}</code></pre></pre>
<h2><a class="header" href="#Доступ-к-элементам" id="Доступ-к-элементам">Доступ к элементам</a></h2>
<p>Чтобы получить значение по определенному индексу в векторе, мы используем <code>[]</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5];

println!(&quot;Третий элемент вектора v равен {}&quot;, v[2]);
#}</code></pre></pre>
<p>Индексы отсчитываются от <code>0</code>, так что третьим элементом является <code>v[2]</code>.</p>
<h2><a class="header" href="#Обход" id="Обход">Обход</a></h2>
<p>Вы можете обойти элементы вектора с помощью <code>for</code>. Есть три варианта:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut v = vec![1, 2, 3, 4, 5];

for i in &amp;v {
    println!(&quot;Ссылка {}&quot;, i);
}

for i in &amp;mut v {
    println!(&quot;Изменяемая ссылка {}&quot;, i);
}

for i in v {
    println!(&quot;Владение вектором и его элементами {}&quot;, i);
}
#}</code></pre></pre>
<p>У векторов есть много других полезных методов, о которых вы можете прочитать в
<a href="http://doc.rust-lang.org/std/vec/index.html">документации API</a>.</p>
<p>% Строки</p>
<p>Строки — важное понятие для любого программиста. Система обработки строк в Rust
немного отличается от других языков, потому что это язык системного
программирования. Работать со структурами данных с переменным размером довольно
сложно, и строки — как раз такая структура данных. Кроме того, работа со
строками в Rust также отличается и от некоторых системных языков, таких как C.</p>
<p>Давайте разбираться в деталях. <em>string</em> — это последовательность скалярных
значений юникод, закодированных в виде потока байт UTF-8. Все строки должны быть
гарантированно валидными UTF-8 последовательностями. Кроме того, строки не
оканчиваются нулём и могут содержать нулевые байты.</p>
<p>В Rust есть два основных типа строк: <code>&amp;str</code> и <code>String</code>. Сперва поговорим о
<code>&amp;str</code> — это «строковый срез». Строковые срезы имеют фиксированный размер и
не могут быть изменены. Они представляют собой ссылку на последовательность
байт UTF-8:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let greeting = &quot;Всем привет.&quot;; // greeting: &amp;'static str
#}</code></pre></pre>
<p><code>&quot;Всем привет.&quot;</code> — это строковый литерал, его тип — <code>&amp;'static str</code>.
Строковые литералы являются статически размещенными строковыми срезами. Это
означает, что они сохраняются внутри нашей скомпилированной программы и
существуют в течение всего периода ее выполнения. Имя <code>greeting</code> представляет
собой ссылку на эту статически размещенную строку. Любая функция, ожидающая
строковый срез, может также принять в качестве аргумента строковый литерал.</p>
<p>Строковые литералы могут состоять из нескольких строк. Такие литералы можно
записывать в двух разных формах. Первая будет включать в себя перевод на новую
строку и ведущие пробелы:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = &quot;foo
    bar&quot;;

assert_eq!(&quot;foo\n        bar&quot;, s);
#}</code></pre></pre>
<p>Вторая форма, включающая в себя <code></code>, вырезает пробелы и перевод на новую строку:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = &quot;foo\
    bar&quot;; 

assert_eq!(&quot;foobar&quot;, s);
#}</code></pre></pre>
<p>Но в Rust есть не только <code>&amp;str</code>. Тип <code>String</code> представляет собой строку, 
размещенную в куче. Эта строка расширяема, и она также гарантированно является 
последовательностью UTF-8. <code>String</code> обычно создаётся путем преобразования из 
строкового среза с использованием метода <code>to_string</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut s = &quot;Привет&quot;.to_string(); // mut s: String
println!(&quot;{}&quot;, s);

s.push_str(&quot;, мир.&quot;);
println!(&quot;{}&quot;, s);
#}</code></pre></pre>
<p><code>String</code> преобразуются в <code>&amp;str</code> с помощью <code>&amp;</code>:</p>
<pre><pre class="playpen"><code class="language-rust">fn takes_slice(slice: &amp;str) {
    println!(&quot;Получили: {}&quot;, slice);
}

fn main() {
    let s = &quot;Привет&quot;.to_string();
    takes_slice(&amp;s);
}
</code></pre></pre>
<p>Это преобразование не происходит в случае функций, которые принимают какой-то
типаж <code>&amp;str</code>, а не сам <code>&amp;str</code>. Например, у метода
<a href="https://doc.rust-lang.org/stable/std/net/struct.TcpStream.html#method.connect"><code>TcpStream::connect</code></a> есть параметр типа <code>ToSocketAddrs</code>. Сюда можно
передать <code>&amp;str</code>, но <code>String</code> нужно явно преобразовать с помощью <code>&amp;*</code>.</p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
use std::net::TcpStream;

TcpStream::connect(&quot;192.168.0.1:3000&quot;); // параметр &amp;str

let addr_string = &quot;192.168.0.1:3000&quot;.to_string();
TcpStream::connect(&amp;*addr_string); // преобразуем addr_string в &amp;str
#}</code></pre></pre>
<p>Представление <code>String</code> как <code>&amp;str</code> — дешёвая операция, но преобразование <code>&amp;str</code>
в <code>String</code> предполагает выделение памяти. Не стоит делать это без необходимости!</p>
<h2><a class="header" href="#Индексация" id="Индексация">Индексация</a></h2>
<p>Поскольку строки являются валидными UTF-8 последовательностями, то они не
поддерживают индексацию:</p>
<pre><code class="language-rust ignore">let s = &quot;привет&quot;;

println!(&quot;Первая буква s — {}&quot;, s[0]); // ОШИБКА!!!
</code></pre>
<p>Как правило, доступ к вектору с помощью <code>[]</code> является очень быстрой операцией.
Но поскольку каждый символ в строке, закодированной UTF-8, может быть
представлен несколькими байтами, то при поиске вы должны перебрать n-ое
количество литер в строке. Это значительно более дорогая операция, а мы не хотим
вводить в заблуждение. Кроме того, «литера» — это не совсем то, что определено в
Unicode. Мы можем выбрать как рассматривать строку: как отдельные байты или как
кодовые единицы (codepoints):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let hachiko = &quot;忠犬ハチ公&quot;;

for b in hachiko.as_bytes() {
    print!(&quot;{}, &quot;, b);
}

println!(&quot;&quot;);

for c in hachiko.chars() {
    print!(&quot;{}, &quot;, c);
}

println!(&quot;&quot;);
#}</code></pre></pre>
<p>Этот код напечатает:</p>
<pre><code class="language-text">229, 191, 160, 231, 138, 172, 227, 131, 143, 227, 131, 129, 229, 133, 172, 
忠, 犬, ハ, チ, 公, 
</code></pre>
<p>Как вы можете видеть, количество байт больше, чем количество символов (<code>char</code>).</p>
<p>Вы можете получить что-то наподобие индекса, как показано ниже:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let hachiko = &quot;忠犬ハチ公&quot;;
let dog = hachiko.chars().nth(1); // что-то вроде hachiko[1]
#}</code></pre></pre>
<p>Это подчеркивает, что мы должны пройти по списку <code>chars</code> от его начала.</p>
<h2><a class="header" href="#Срезы-1" id="Срезы-1">Срезы</a></h2>
<p>Вы можете получить срез строки с помощью синтаксиса срезов:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let dog = &quot;hachiko&quot;;
let hachi = &amp;dog[0..5];
#}</code></pre></pre>
<p>Но заметьте, что это индексы <em>байтов</em>, а не <em>символов</em>. Поэтому этот код
запаникует:</p>
<pre><pre class="playpen"><code class="language-rust should_panic">
# #![allow(unused_variables)]
#fn main() {
let dog = &quot;忠犬ハチ公&quot;;
let hachi = &amp;dog[0..2];
#}</code></pre></pre>
<p>с такой ошибкой:</p>
<pre><code class="language-text">thread '&lt;main&gt;' panicked at 'index 0 and/or 2 in `忠犬ハチ公` do not lie on
character boundary'
</code></pre>
<h2><a class="header" href="#Конкатенация" id="Конкатенация">Конкатенация</a></h2>
<p>Если у вас есть <code>String</code>, то вы можете присоединить к нему в конец <code>&amp;str</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let hello = &quot;Hello &quot;.to_string();
let world = &quot;world!&quot;;

let hello_world = hello + world;
#}</code></pre></pre>
<p>Но если у вас есть две <code>String</code>, то необходимо использовать <code>&amp;</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let hello = &quot;Hello &quot;.to_string();
let world = &quot;world!&quot;.to_string();

let hello_world = hello + &amp;world;
#}</code></pre></pre>
<p>Это потому, что <code>&amp;String</code> может быть автоматически приведен к <code>&amp;str</code>. Эта
возможность называется «<a href="deref-coercions.html">Приведение при разыменовании</a>».</p>
<p>% Обобщённое программирование</p>
<p>Иногда, при написании функции или типа данных, мы можем захотеть, чтобы они
работали для нескольких типов аргументов. К счастью, у Rust есть возможность,
которая даёт нам лучший способ реализовать это: обобщённое программирование.
Обобщённое программирование называется «параметрическим полиморфизмом» в
теории типов. Это означает, что типы или функции имеют несколько форм (poly —
кратно, morph — форма) по данному параметру («параметрический»).</p>
<p>В любом случае, хватит о теории типов; давайте рассмотрим какой-нибудь
обобщённый код. Стандартная библиотека Rust предоставляет тип <code>Option&lt;T&gt;</code>,
который является обобщённым типом:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    Some(T),
    None,
}
#}</code></pre></pre>
<p>Часть <code>&lt;T&gt;</code>, которую вы раньше уже видели несколько раз, указывает, что это
обобщённый тип данных. Внутри перечисления, везде, где мы видим <code>T</code>, мы
подставляем вместо этого абстрактного типа тот, который используется в
обобщении. Вот пример использования <code>Option&lt;T&gt;</code> с некоторыми дополнительными
аннотациями типов:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x: Option&lt;i32&gt; = Some(5);
#}</code></pre></pre>
<p>В определении типа мы используем <code>Option&lt;i32&gt;</code>. Обратите внимание, что это очень
похоже на <code>Option&lt;T&gt;</code>. С той лишь разницей, что, в данном конкретном <code>Option</code>,
<code>T</code> имеет значение <code>i32</code>. В правой стороне выражения мы используем <code>Some(T)</code>,
где <code>T</code> равно <code>5</code>. Так как <code>5</code> является представителем типа <code>i32</code>, то типы по
обе стороны совпадают, поэтому компилятор счастлив. Если же они не совпадают, то
мы получим ошибку:</p>
<pre><code class="language-rust ignore">let x: Option&lt;f64&gt; = Some(5);
// error: mismatched types: expected `core::option::Option&lt;f64&gt;`,
// found `core::option::Option&lt;_&gt;` (expected f64 but found integral variable)
</code></pre>
<p>Но это не значит, что мы не можем сделать <code>Option&lt;T&gt;</code>, который содержит <code>f64</code>!
Просто типы должны совпадать:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x: Option&lt;i32&gt; = Some(5);
let y: Option&lt;f64&gt; = Some(5.0f64);
#}</code></pre></pre>
<p>Это просто прекрасно. Одно определение — многостороннее использование.</p>
<p>Обобщать можно более, чем по одному параметру. Рассмотрим другой обобщённый тип
из стандартной библиотеки Rust — <code>Result&lt;T, E&gt;</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
#}</code></pre></pre>
<p>Этот тип является обобщённым сразу для <em>двух</em> типов: <code>T</code> и <code>E</code>. Кстати,
заглавные буквы могут быть любыми. Мы могли бы определить <code>Result&lt;T, E&gt;</code> как:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Result&lt;A, Z&gt; {
    Ok(A),
    Err(Z),
}
#}</code></pre></pre>
<p>если бы захотели. Соглашение гласит, что первый обобщённый параметр для 'типа'
должен быть <code>T</code>, и что для 'ошибки' используется <code>E</code>. Но Rust не проверяет
этого.</p>
<p>Тип <code>Result&lt;T, E&gt;</code> предназначен для того, чтобы возвращать результат вычисления,
и имеет возможность вернуть ошибку, если произойдёт какой-либо сбой.</p>
<h2><a class="header" href="#Обобщённые-функции" id="Обобщённые-функции">Обобщённые функции</a></h2>
<p>Мы можем задавать функции, которые принимают обобщённые типы, с помощью
аналогичного синтаксиса:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn takes_anything&lt;T&gt;(x: T) {
    // делаем что-то с x
}
#}</code></pre></pre>
<p>Синтаксис состоит из двух частей: <code>&lt;T&gt;</code> говорит о том, что «эта функция является
обобщённой по одному типу, <code>T</code>», а <code>x: T</code> говорит о том, что «х имеет тип <code>T</code>».</p>
<p>Несколько аргументов могут иметь один и тот же обобщённый тип:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn takes_two_of_the_same_things&lt;T&gt;(x: T, y: T) {
    // ...
}
#}</code></pre></pre>
<p>Мы можем написать версию, которая принимает несколько типов:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn takes_two_things&lt;T, U&gt;(x: T, y: U) {
    // ...
}
#}</code></pre></pre>
<p>Обобщённые функции наиболее полезны в связке с «ограничениями по типажам», о
которых мы расскажем в главе <a href="traits.html">Типажи</a>.</p>
<h2><a class="header" href="#Обобщённые-структуры" id="Обобщённые-структуры">Обобщённые структуры</a></h2>
<p>Вы также можете задать обобщённый тип для <code>struct</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Point&lt;T&gt; {
    x: T,
    y: T,
}

let int_origin = Point { x: 0, y: 0 };
let float_origin = Point { x: 0.0, y: 0.0 };
#}</code></pre></pre>
<p>Аналогично функциям, мы также объявляем обобщённые параметры в <code>&lt;T&gt;</code>, а затем
используем их в объявлении типа <code>x: T</code>.</p>
<p>% Типажи</p>
<p>Типаж --- это возможность объяснить компилятору, что данный тип должен
предоставлять определённую функциональность.</p>
<p>Вы помните ключевое слово <code>impl</code>, используемое для вызова функции через
синтаксис метода?</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #![feature(core)]
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}
#}</code></pre></pre>
<p>Типажи схожи, за исключением того, что мы определяем типаж, содержащий лишь
сигнатуру метода, а затем реализуем этот типаж для нужной структуры. Например,
как показано ниже:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #![feature(core)]
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

impl HasArea for Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}
#}</code></pre></pre>
<p>Как вы можете видеть, блок <code>trait</code> очень похож на блок <code>impl</code>. Различие состоит
лишь в том, что тело метода не определяется, а определяется только его
сигнатура. Когда мы реализуем типаж, мы используем <code>impl Trait for Item</code>, а не
просто <code>impl Item</code>.</p>
<p>Мы можем использовать типажи для ограничения обобщённых типов. Рассмотрим
похожую функцию, которая также не компилируется, и выводит ошибку:</p>
<pre><code class="language-rust ignore">fn print_area&lt;T&gt;(shape: T) {
    println!(&quot;This shape has an area of {}&quot;, shape.area());
}
</code></pre>
<p>Rust выводит:</p>
<pre><code class="language-text">error: type `T` does not implement any method in scope named `area`
</code></pre>
<p>Поскольку <code>T</code> может быть любого типа, мы не можем быть уверены, что он реализует
метод <code>area</code>. Но мы можем добавить «ограничение по типажу» к нашему обобщённому
типу <code>T</code>, гарантируя, что он будет соответствовать требованиям:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait HasArea {
#     fn area(&amp;self) -&gt; f64;
# }
fn print_area&lt;T: HasArea&gt;(shape: T) {
    println!(&quot;This shape has an area of {}&quot;, shape.area());
}
#}</code></pre></pre>
<p>Синтаксис <code>&lt;T: HasArea&gt;</code> означает «любой тип, реализующий типаж <code>HasArea</code>».
Так как типажи определяют сигнатуры типов функций, мы можем быть уверены, что
любой тип, который реализует <code>HasArea</code>, будет иметь метод <code>.area()</code>.</p>
<p>Вот расширенный пример того, как это работает:</p>
<pre><pre class="playpen"><code class="language-rust"># #![feature(core)]
trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl HasArea for Circle {
    fn area(&amp;self) -&gt; f64 {
        std::f64::consts::PI * (self.radius * self.radius)
    }
}

struct Square {
    x: f64,
    y: f64,
    side: f64,
}

impl HasArea for Square {
    fn area(&amp;self) -&gt; f64 {
        self.side * self.side
    }
}

fn print_area&lt;T: HasArea&gt;(shape: T) {
    println!(&quot;Площадь этой фигуры равна {}&quot;, shape.area());
}

fn main() {
    let c = Circle {
        x: 0.0f64,
        y: 0.0f64,
        radius: 1.0f64,
    };

    let s = Square {
        x: 0.0f64,
        y: 0.0f64,
        side: 1.0f64,
    };

    print_area(c);
    print_area(s);
}
</code></pre></pre>
<p>Ниже показан вывод программы:</p>
<pre><code class="language-text">Площадь этой фигуры равна 3.141593
Площадь этой фигуры равна 1
</code></pre>
<p>Как вы можете видеть, теперь <code>print_area</code> не только является обобщённой
функцией, но и гарантирует, что будет получен корректный тип. Если же мы
передадим некорректный тип:</p>
<pre><code class="language-rust ignore">print_area(5);
</code></pre>
<p>Мы получим ошибку времени компиляции:</p>
<pre><code class="language-text">error: the trait `HasArea` is not implemented for the type `_` [E0277]
</code></pre>
<p>До сих пор мы добавляли реализации типажей лишь для структур, но реализовать
типаж можно для любого типа. Технически, мы <em>могли бы</em> реализовать <code>HasArea</code> для
<code>i32</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

impl HasArea for i32 {
    fn area(&amp;self) -&gt; f64 {
        println!(&quot;это нелепо&quot;);

        *self as f64
    }
}

5.area();
#}</code></pre></pre>
<p>Хотя технически это возможно, реализация методов для примитивных типов считается
плохим стилем программирования.</p>
<p>Может показаться, что такой подход легко приводит к бардаку в коде, однако
есть два ограничения, связанные с реализацией типажей, которые мешают коду выйти
из-под контроля. Во-первых, если типаж не определён в нашей области видимости,
он не применяется. Например, стандартная библиотека предоставляет типаж
<a href="https://doc.rust-lang.org/stable/std/io/trait.Write.html"><code>Write</code></a>, который добавляет типу <code>File</code> функциональность ввода-вывода.
По умолчанию у <code>File</code> не будет этих методов:</p>
<pre><code class="language-rust ignore">let mut f = std::fs::File::open(&quot;foo.txt&quot;).ok().expect(&quot;Не могу открыть foo.txt&quot;);
let buf = b&quot;whatever&quot;; // литерал строки байт. buf: &amp;[u8; 8]
let result = f.write(buf);
# result.unwrap(); // игнорируем ошибку
</code></pre>
<p>Вот ошибка:</p>
<pre><code class="language-text">error: type `std::fs::File` does not implement any method in scope named `write`
let result = f.write(buf);
               ^~~~~~~~~~
</code></pre>
<p>Сначала мы должны сделать <code>use</code> для типажа <code>Write</code>:</p>
<pre><code class="language-rust ignore">use std::io::Write;

let mut f = std::fs::File::open(&quot;foo.txt&quot;).ok().expect(&quot;Не могу открыть foo.txt&quot;);
let buf = b&quot;whatever&quot;;
let result = f.write(buf);
# result.unwrap(); // игнорируем ошибку
</code></pre>
<p>Это скомпилируется без ошибки.</p>
<p>Благодаря такой логике работы, даже если кто-то сделает что-то страшное —
например, добавит методы <code>i32</code>, это не коснётся вас, пока вы не импортируете
типаж.</p>
<p>Второе ограничение реализации типажей --- это то, что или типаж, или тип, для
которого вы реализуете типаж, должен быть реализован вами. Мы могли бы
определить <code>HasArea</code> для <code>i32</code>, потому что <code>HasArea</code> — это наш код. Но если бы
мы попробовали реализовать для <code>i32</code> <code>ToString</code> — типаж, предоставляемый Rust —
мы бы не смогли сделать это, потому что ни типаж, ни тип не реализован нами.</p>
<p>Последнее, что нужно сказать о типажах: обобщённые функции с ограничением по
типажам используют <em>мономорфизацию</em> (<em>mono</em>: один, <em>morph</em>: форма), поэтому они
диспетчеризуются статически. Что это значит? Посмотрите главу
<a href="trait-objects.html">Типажи-объекты</a>, чтобы получить больше информации.</p>
<h1><a class="header" href="#Множественные-ограничения-по-типажам" id="Множественные-ограничения-по-типажам">Множественные ограничения по типажам</a></h1>
<p>Вы уже видели, как можно ограничить обобщённый параметр типа определённым
типажом:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo&lt;T: Clone&gt;(x: T) {
    x.clone();
}
#}</code></pre></pre>
<p>Если вам нужно больше одного ограничения, вы можете использовать <code>+</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::Debug;

fn foo&lt;T: Clone + Debug&gt;(x: T) {
    x.clone();
    println!(&quot;{:?}&quot;, x);
}
#}</code></pre></pre>
<p>Теперь тип <code>T</code> должен реализовавать как типаж <code>Clone</code>, так и типаж <code>Debug</code>.</p>
<h1><a class="header" href="#Утверждение-where" id="Утверждение-where">Утверждение where</a></h1>
<p>Написание функций с несколькими обобщёнными типами и небольшим количеством
ограничений по типажам выглядит не так уж плохо, но, с увеличением количества
зависимостей, синтаксис получается более неуклюжим:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::Debug;

fn foo&lt;T: Clone, K: Clone + Debug&gt;(x: T, y: K) {
    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}
#}</code></pre></pre>
<p>Имя функции находится слева, а список параметров — далеко справа. Ограничения
загромождают место.</p>
<p>Есть решение и для этой проблемы, и оно называется «утверждение <code>where</code>»:</p>
<pre><pre class="playpen"><code class="language-rust">use std::fmt::Debug;

fn foo&lt;T: Clone, K: Clone + Debug&gt;(x: T, y: K) {
    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}

fn bar&lt;T, K&gt;(x: T, y: K) where T: Clone, K: Clone + Debug {
    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}

fn main() {
    foo(&quot;Привет&quot;, &quot;мир&quot;);
    bar(&quot;Привет&quot;, &quot;мир&quot;);
}
</code></pre></pre>
<p><code>foo()</code> использует синтаксис, показанный ранее, а <code>bar()</code> использует утверждение
<code>where</code>. Все, что нам нужно сделать, это убрать ограничения при определении
типов параметров, а затем добавить <code>where</code> после списка параметров. В более
длинных списках можно использовать пробелы:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::Debug;

fn bar&lt;T, K&gt;(x: T, y: K)
    where T: Clone,
          K: Clone + Debug {

    x.clone();
    y.clone();
    println!(&quot;{:?}&quot;, y);
}
#}</code></pre></pre>
<p>Такая гибкость может добавить ясности в сложных ситуациях.</p>
<p>На самом деле <code>where</code> это больше, чем просто упрощение синтаксиса. Например:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait ConvertTo&lt;Output&gt; {
    fn convert(&amp;self) -&gt; Output;
}

impl ConvertTo&lt;i64&gt; for i32 {
    fn convert(&amp;self) -&gt; i64 { *self as i64 }
}

// может быть вызван с T == i32
fn normal&lt;T: ConvertTo&lt;i64&gt;&gt;(x: &amp;T) -&gt; i64 {
    x.convert()
}

// может быть вызван с T == i64
fn inverse&lt;T&gt;() -&gt; T
        // использует ConvertTo как если бы это было «ConvertTo&lt;i64&gt;»
        where i32: ConvertTo&lt;T&gt; {
    1i32.convert()
}
#}</code></pre></pre>
<p>Этот код демонстрирует дополнительные преимущества использования утверждения
<code>where</code>: оно позволяет задавать ограничение, где с левой стороны располагается
произвольный тип (в данном случае <code>i32</code>), а не только простой параметр типа
(вроде <code>T</code>).</p>
<h1><a class="header" href="#Методы-по-умолчанию" id="Методы-по-умолчанию">Методы по умолчанию</a></h1>
<p>Есть еще одна особенность типажей, о которой стоит поговорить: методы по
умолчанию. Проще всего показать это на примере:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Foo {
    fn is_valid(&amp;self) -&gt; bool;

    fn is_invalid(&amp;self) -&gt; bool { !self.is_valid() }
}
#}</code></pre></pre>
<p>В типах, реализующих типаж <code>Foo</code>, нужно реализовать метод <code>is_valid()</code>, а
<code>is_invalid()</code> будет реализован по-умолчанию. Его поведение можно
переопределить:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait Foo {
#     fn is_valid(&amp;self) -&gt; bool;
#
#     fn is_invalid(&amp;self) -&gt; bool { !self.is_valid() }
# }
struct UseDefault;

impl Foo for UseDefault {
    fn is_valid(&amp;self) -&gt; bool {
        println!(&quot;Вызван UseDefault.is_valid.&quot;);
        true
    }
}

struct OverrideDefault;

impl Foo for OverrideDefault {
    fn is_valid(&amp;self) -&gt; bool {
        println!(&quot;Вызван OverrideDefault.is_valid.&quot;);
        true
    }

    fn is_invalid(&amp;self) -&gt; bool {
        println!(&quot;Вызван OverrideDefault.is_invalid!&quot;);
        true // эта реализация противоречит сама себе!
    }
}

let default = UseDefault;
assert!(!default.is_invalid()); // печатает «Вызван UseDefault.is_valid.»

let over = OverrideDefault;
assert!(over.is_invalid()); // печатает «Вызван OverrideDefault.is_invalid!»
#}</code></pre></pre>
<h1><a class="header" href="#Наследование" id="Наследование">Наследование</a></h1>
<p>Иногда чтобы реализовать один типаж, нужно реализовать типажи, от которых он
зависит:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Foo {
    fn foo(&amp;self);
}

trait FooBar : Foo {
    fn foobar(&amp;self);
}
#}</code></pre></pre>
<p>Типы, реализующие <code>FooBar</code>, должны реализовывать <code>Foo</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait Foo {
#     fn foo(&amp;self);
# }
# trait FooBar : Foo {
#     fn foobar(&amp;self);
# }
struct Baz;

impl Foo for Baz {
    fn foo(&amp;self) { println!(&quot;foo&quot;); }
}

impl FooBar for Baz {
    fn foobar(&amp;self) { println!(&quot;foobar&quot;); }
}
#}</code></pre></pre>
<p>Если мы забудем реализовать <code>Foo</code>, компилятор скажет нам об этом:</p>
<pre><code class="language-text">error: the trait `main::Foo` is not implemented for the type `main::Baz` [E0277]
</code></pre>
<p>% Типаж <code>Drop</code> (сброс)</p>
<p>Мы обсудили типажи. Теперь давайте поговорим о конкретном типаже,
предоставляемом стандартной библиотекой Rust. Этот типаж — <a href="http://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>
(сброс) — позволяет выполнить некоторый код, когда значение выходит из области
видимости. Например:</p>
<pre><pre class="playpen"><code class="language-rust">struct HasDrop;

impl Drop for HasDrop {
    fn drop(&amp;mut self) {
        println!(&quot;Сбрасываем!&quot;);
    }
}

fn main() {
    let x = HasDrop;

    // сделаем что-то

} // тут x выходит из области видимости
</code></pre></pre>
<p>Когда <code>x</code> выходит из области видимости в конце <code>main()</code>, исполнится код
реализации типажа <code>Drop</code>. У него один метод, который тоже называется <code>drop()</code>.
Он принимает изменяемую ссылку на себя (<code>self</code>).</p>
<p>Вот и всё! Работа <code>Drop</code> достаточно проста, но есть несколько
тонкостей. Например, значения сбрасываются в порядке, обратном порядку их
объявления. Вот ещё пример:</p>
<pre><pre class="playpen"><code class="language-rust">struct Firework {
    strength: i32,
}

impl Drop for Firework {
    fn drop(&amp;mut self) {
        println!(&quot;БАБАХ силой {}!!!&quot;, self.strength);
    }
}

fn main() {
    let firecracker = Firework { strength: 1 };
    let tnt = Firework { strength: 100 };
}
</code></pre></pre>
<p>Этот код выведет следующее:</p>
<pre><code class="language-text">БАБАХ силой 100!!!
БАБАХ силой 1!!!
</code></pre>
<p>Сначала взрывается тринитротолуоловая бомба (<code>tnt</code>), потому что она была
объявлена последней. За ней взрывается шутиха (<code>firecracker</code>). Первым вошёл,
последним вышел.</p>
<p>Так зачем нужен <code>Drop</code>? Часто <code>Drop</code> используют, чтобы освободить ресурсы,
представленные структурой (<code>struct</code>). Например, счётчик ссылок <a href="http://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a>
уменьшает число активных ссылок в <code>drop()</code>, и когда оно достигает нуля,
освобождает хранимое значение.</p>
<p>% Конструкция <code>if let</code></p>
<p>Иногда хочется сделать определённые вещи менее неуклюже. Например,
скомбинировать <code>if</code> и <code>let</code> чтобы более удобно сделать сопоставление с образцом.
Для этого есть <code>if let</code>.</p>
<p>В качестве примера рассмотрим <code>Option&lt;T&gt;</code>. Если это <code>Some&lt;T&gt;</code>, мы хотим вызвать
функцию на этом значении, а если это <code>None</code> — не делать ничего. Вроде такого:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let option = Some(5);
# fn foo(x: i32) { }
match option {
    Some(x) =&gt; { foo(x) },
    None =&gt; {},
}
#}</code></pre></pre>
<p>Здесь необязательно использовать <code>match</code>. <code>if</code> тоже подойдёт:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let option = Some(5);
# fn foo(x: i32) { }
if option.is_some() {
    let x = option.unwrap();
    foo(x);
}
#}</code></pre></pre>
<p>Но оба этих варианта выглядят странно. Мы можем исправить это с помощью <code>if let</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let option = Some(5);
# fn foo(x: i32) { }
if let Some(x) = option {
    foo(x);
}
#}</code></pre></pre>
<p>Если <a href="patterns.html">сопоставление с образцом</a> успешно, имена в образце связываются с
соответствующими частями разбираемого значения, и блок исполняется. Если
значение не соответствует образцу, ничего не происходит.</p>
<p>Если вы хотите делать что-то ещё при несовпадении с образцом, используйте
<code>else</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let option = Some(5);
# fn foo(x: i32) { }
# fn bar() { }
if let Some(x) = option {
    foo(x);
} else {
    bar();
}
#}</code></pre></pre>
<h2><a class="header" href="#while-let" id="while-let"><code>while let</code></a></h2>
<p>Похожим образом, <code>while let</code> можно использовать для перебора значений, пока
они соответствуют образцу. Код вроде такого:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let option: Option&lt;i32&gt; = None;
loop {
    match option {
        Some(x) =&gt; println!(&quot;{}&quot;, x),
        _ =&gt; break,
    }
}
#}</code></pre></pre>
<p>Превращается в такой:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let option: Option&lt;i32&gt; = None;
while let Some(x) = option {
    println!(&quot;{}&quot;, x);
}
#}</code></pre></pre>
<p>% Типажи-объекты</p>
<p>Когда код включает в себя полиморфизм, то должен быть механизм, чтобы
определить, какая конкретная версия будет фактически вызвана. Это называется
'диспетчеризация.' Есть две основные формы диспетчеризации: статическая и
динамическая. Хотя Rust и отдает предпочтение статической диспетчеризации, он
также поддерживает динамическую диспетчеризацию через механизм, называемый
'типажи-объекты.'</p>
<h2><a class="header" href="#Подготовка" id="Подготовка">Подготовка</a></h2>
<p>Для остальной части этой главы нам потребуется типаж и несколько его реализаций.
Давайте создадим простой типаж <code>Foo</code>. Он содержит один метод, который возвращает
<code>String</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Foo {
    fn method(&amp;self) -&gt; String;
}
#}</code></pre></pre>
<p>Также мы реализуем этот типаж для <code>u8</code> и <code>String</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait Foo { fn method(&amp;self) -&gt; String; }
impl Foo for u8 {
    fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) }
}

impl Foo for String {
    fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) }
}
#}</code></pre></pre>
<h2><a class="header" href="#Статическая-диспетчеризация" id="Статическая-диспетчеризация">Статическая диспетчеризация</a></h2>
<p>Мы можем использовать этот типаж для выполнения статической диспетчеризации с
помощью ограничения типажом:</p>
<pre><pre class="playpen"><code class="language-rust"># trait Foo { fn method(&amp;self) -&gt; String; }
# impl Foo for u8 { fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) } }
# impl Foo for String { fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) } }
fn do_something&lt;T: Foo&gt;(x: T) {
    x.method();
}

fn main() {
    let x = 5u8;
    let y = &quot;Hello&quot;.to_string();

    do_something(x);
    do_something(y);
}
</code></pre></pre>
<p>Здесь Rust использует 'мономорфизацию' для статической диспетчеризации. Это
означает, что Rust создаст специальную версию <code>do_something()</code> для каждого из
типов: <code>u8</code> и <code>String</code>, а затем заменит все места вызовов на вызовы этих
специализированных функций. Другими словами, Rust сгенерирует нечто вроде этого:</p>
<pre><pre class="playpen"><code class="language-rust"># trait Foo { fn method(&amp;self) -&gt; String; }
# impl Foo for u8 { fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) } }
# impl Foo for String { fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) } }
fn do_something_u8(x: u8) {
    x.method();
}

fn do_something_string(x: String) {
    x.method();
}

fn main() {
    let x = 5u8;
    let y = &quot;Hello&quot;.to_string();

    do_something_u8(x);
    do_something_string(y);
}
</code></pre></pre>
<p>Статическая диспетчеризация имеет большой потенциал: она позволяет вызывать
функцию, которая будет встроена, потому что вызываемая версия этой функции
известна на этапе компиляции, а встраивание — это ключ к хорошей оптимизации.
Статическая диспетчеризация быстра, но это достигается путем компромисса:
происходит 'раздувание кода' в связи с большим количеством копий одной и той же
функции, по одной для каждого типа, расположенных в бинарном файле.</p>
<p>Кроме того, компиляторы не совершенны и могут «оптимизировать» код так, что он
станет медленнее. Например, встроенные функции будут слишком охотно раздувать
кэш команд (правила кэширования все вокруг нас). Это одна из причин, по которой
<code>#[inline]</code> и <code>#[inline(always)]</code> следует использовать осторожно, и почему
использование динамической диспетчеризации иногда более эффективно.</p>
<p>Тем не менее, в общем случае более эффективно использовать статическую
диспетчеризацию. Кроме того, всегда можно иметь тонкую статически-
диспетчеризуемую обертку для функции, которая выполняет динамическую
диспетчеризацию, но не наоборот. То есть статические вызовы являются более
гибкими. По этой причине стандартная библиотека старается быть статически
диспетчеризуемой везде, где это возможно.</p>
<h2><a class="header" href="#Динамическая-диспетчеризация" id="Динамическая-диспетчеризация">Динамическая диспетчеризация</a></h2>
<p>Rust обеспечивает динамическую диспетчеризацию через механизм под названием
'типажи-объекты'. Типажи-объекты, такие как <code>&amp;Foo</code> или <code>Box&lt;Foo&gt;</code>, это обычные
переменные, хранящие значения <em>любого</em> типа, реализующего данный типаж.
Конкретный тип типажа-объекта может быть определен только на этапе выполнения.</p>
<p>Типаж-объект может быть получен из указателя на конкретный тип, который
реализует этот типаж, путем его <code>явного приведения</code> (например, <code>&amp;x as &amp;Foo</code>) или
<code>неявного приведения</code> (например, используя <code>&amp;x</code> в качестве аргумента функции,
которая принимает <code>&amp;Foo</code>).</p>
<p>Явное и неявное приведение типажа-объекта также работает для таких указателей,
как <code>&amp;mut T</code> в <code>&amp;mut Foo</code> и <code>Box&lt;T&gt;</code> в <code>Box&lt;Foo&gt;</code>, но это все на данный момент.
Явное и неявное приведение идентичны.</p>
<p>Эта операция может рассматриваться как «затирание» знания компилятора о
конкретном типе указателя, поэтому типажи-объекты иногда называют «затиранием
типов».</p>
<p>Возвращаясь к примеру выше, мы можем использовать тот же самый типаж для
выполнения динамической диспетчеризации с типажами-объектами путем явного
приведения типа:</p>
<pre><pre class="playpen"><code class="language-rust"># trait Foo { fn method(&amp;self) -&gt; String; }
# impl Foo for u8 { fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) } }
# impl Foo for String { fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) } }

fn do_something(x: &amp;Foo) {
    x.method();
}

fn main() {
    let x = 5u8;
    do_something(&amp;x as &amp;Foo);
}
</code></pre></pre>
<p>или неявного приведения типа:</p>
<pre><pre class="playpen"><code class="language-rust"># trait Foo { fn method(&amp;self) -&gt; String; }
# impl Foo for u8 { fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) } }
# impl Foo for String { fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) } }

fn do_something(x: &amp;Foo) {
    x.method();
}

fn main() {
    let x = &quot;Hello&quot;.to_string();
    do_something(&amp;x);
}
</code></pre></pre>
<p>Функция, которая принимает типаж-объект, не обладает специализированными копиями
для каждого из типов, которые реализуют типаж <code>Foo</code>: генерируется только одна
копия. Часто (но не всегда), в результате происходит уменьшение раздувания кода.
Тем не менее, это происходит за счет более медленного вызова виртуальных
функций, и, по существу, блокирования любой возможности встраивания и связанных
с этим оптимизаций.</p>
<h3><a class="header" href="#Почему-указатели" id="Почему-указатели">Почему указатели?</a></h3>
<p>В отличие от многих управляемых языков, Rust по умолчанию не размещает значения
по указателю, так как типы могут иметь различные размеры. Знать размер значения
во время компиляции важно прежде всего для выполнения таких задач, как передача
значения в качестве аргумента в функцию, что вызывает помещение переданного
значения в стек, и выделение (и освобождение) места на куче для сохранения
значения там.</p>
<p>Для <code>Foo</code> допускается иметь значение, которое может быть либо <code>String</code> (24
байт), либо <code>u8</code> (1 байт), либо любой другой тип, для которого в соответствующих
крейтах может быть реализован <code>Foo</code> (возможно абсолютно любое число байт). Так
как этот другой тип может быть сколь угодно большими, то нет никакого способа,
гарантирующего, что последний вариант будет работать, если значения сохраняются
без указателя.</p>
<p>Размещение значения по указателю означает, что, когда мы имеем дело с типажом-
объектом, размер самого значения не важен, а важен лишь размер указателя.</p>
<h3><a class="header" href="#Представление" id="Представление">Представление</a></h3>
<p>Методы типажа можно вызвать для типажа-объекта с помощью специальной записи
указателей на функции, традиционно называемой 'виртуальная таблица' ('vtable')
(создается и управляется компилятором).</p>
<p>Типажи-объекты являются одновременно и простыми и сложными: их основное
представление и устройство довольно прямолинейно, но есть некоторые тонкости
относительно обнаружения сообщений об ошибках и странного поведения.</p>
<p>Давайте начнем с простого, с рантайм представления типажа-объекта. Модуль
<code>std::raw</code> содержит структуры с макетами, которые являются такими же, как и
сложные встроенные типы, <a href="http://doc.rust-lang.org/std/raw/struct.TraitObject.html">в том числе типажи-объекты</a>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# mod foo {
pub struct TraitObject {
    pub data: *mut (),
    pub vtable: *mut (),
}
# }
#}</code></pre></pre>
<p>То есть типаж-объект, такой как <code>&amp;Foo</code>, состоит из указателя на «данные» и
указателя на «виртуальную таблицу».</p>
<p>Указатель <code>data</code> адресует данные (какого-то неизвестного типа <code>T</code>), которые
хранит типаж-объект, а указатель <code>vtable</code> указывает на виртуальную таблицу
(«таблица виртуальных методов»), которая соответствует реализации <code>Foo</code> для <code>T</code>.</p>
<p>По существу, виртуальная таблица — это структура указателей на функции,
указывающих на конкретный кусок машинного кода для каждого метода в реализации.
Вызов метода наподобие <code>trait_object.method()</code> возвращает правильный указатель
из виртуальной таблицы, а затем динамически вызывает метод по этому указателю.
Например:</p>
<pre><code class="language-rust ignore">struct FooVtable {
    destructor: fn(*mut ()),
    size: usize,
    align: usize,
    method: fn(*const ()) -&gt; String,
}

// u8:

fn call_method_on_u8(x: *const ()) -&gt; String {
    // компилятор гарантирует, что эта функция вызывается только
    // с `x`, указывающим на u8
    let byte: &amp;u8 = unsafe { &amp;*(x as *const u8) };

    byte.method()
}

static Foo_for_u8_vtable: FooVtable = FooVtable {
    destructor: /* магия компилятора */,
    size: 1,
    align: 1,

    // преобразование в указатель на функцию
    method: call_method_on_u8 as fn(*const ()) -&gt; String,
};


// String:

fn call_method_on_String(x: *const ()) -&gt; String {
    // компилятор гарантирует, что эта функция вызывается только
    // с `x`, указывающим на String
    let string: &amp;String = unsafe { &amp;*(x as *const String) };

    string.method()
}

static Foo_for_String_vtable: FooVtable = FooVtable {
    destructor: /* магия компилятора */,
    // значения для 64-битного компьютера, для 32-битного они в 2 раза меньше
    size: 24,
    align: 8,

    method: call_method_on_String as fn(*const ()) -&gt; String,
};
</code></pre>
<p>Поле <code>destructor</code> в каждой виртуальной таблице указывает на функцию, которая
будет очищать любые ресурсы типа этой виртуальной таблицы, для <code>u8</code> она
тривиальна, но для <code>String</code> она будет освобождать память. Это необходимо для
владельцев типажей-объектов, таких как <code>Box&lt;Foo&gt;</code>, для которых необходимо
очищать выделенную память как для <code>Box</code>, так и для внутреннего типа, когда они
выходят из области видимости. Поля <code>size</code> и <code>align</code> хранят размер затёртого
типа, и его требования к выравниванию; по существу, они не использовался в
момент, так как информация встроенного в деструктор, но будет использоваться в
будущем, так как объекты отличительным признакам постепенно становится более
гибким.</p>
<p>Предположим, у нас есть несколько значений, которые реализуют <code>Foo</code>, тогда явный
вид создания и использования типажей-объектов <code>Foo</code> может выглядеть примерно как
(игнорируются несоответствия типов: в любом случае, они всего лишь указатели):</p>
<pre><code class="language-rust ignore">let a: String = &quot;foo&quot;.to_string();
let x: u8 = 1;

// let b: &amp;Foo = &amp;a;
let b = TraitObject {
    // store the data
    data: &amp;a,
    // store the methods
    vtable: &amp;Foo_for_String_vtable
};

// let y: &amp;Foo = x;
let y = TraitObject {
    // store the data
    data: &amp;x,
    // store the methods
    vtable: &amp;Foo_for_u8_vtable
};

// b.method();
(b.vtable.method)(b.data);

// y.method();
(y.vtable.method)(y.data);
</code></pre>
<p>% Замыкания</p>
<p>Помимо именованных функций Rust предоставляет еще и анонимные функции. Анонимные
функции, которые имеют связанное окружение, называются 'замыкания'. Они так
называются потому что они замыкают свое окружение. Как мы увидим далее, Rust
имеет реально крутую реализацию замыканий.</p>
<h1><a class="header" href="#Синтаксис" id="Синтаксис">Синтаксис</a></h1>
<p>Замыкания выглядят следующим образом:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let plus_one = |x: i32| x + 1;

assert_eq!(2, plus_one(1));
#}</code></pre></pre>
<p>Мы создаем связывание, <code>plus_one</code>, и присваиваем ему замыкание. Аргументы
замыкания располагаются между двумя символами <code>|</code>, а телом замыкания является
выражение, в данном случае: <code>x + 1</code>. Помните, что <code>{ }</code> также является
выражением, поэтому тело замыкания может содержать много строк:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let plus_two = |x| {
    let mut result: i32 = x;

    result += 1;
    result += 1;

    result
};

assert_eq!(4, plus_two(2));
#}</code></pre></pre>
<p>Обратите внимание, что есть несколько небольших различий между замыканиями и
обычными функциями, определенными с помощью <code>fn</code>. Первое отличие состоит в том,
что для замыкания мы не должны указывать ни типы аргументов, которые оно
принимает, ни тип возвращаемого им значения. Мы можем:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let plus_one = |x: i32| -&gt; i32 { x + 1 };

assert_eq!(2, plus_one(1));
#}</code></pre></pre>
<p>Но мы не должны. Почему так? В основном, это было сделано из эргономических
соображений (соображений удобства). В то время как для именованных функций явное
указание типа является полезным для таких аспектов как документация и вывод
типа, типы замыканий редко документируют, поскольку они анонимны. К тому же, они
не вызывают «ошибок на расстоянии» (error-at-a-distance), которые могут вызывать
именованные функции. Такие ошибки могут возникать, когда локальное изменение
(например, в теле одной из функций) вызывает изменение вывода типов. Компилятор
пытается подобрать типы в окружающей программе под уже другие типы в изменённой
функции, и часто оказывается, что имена имеют другие типы, нежели мы ожидали. В
результате происходит ошибка «на расстоянии» — возможно, в другой функции,
использующей изменённую.</p>
<p>Второе отличие — синтаксис очень похож, но все же немного отличается. Мы
добавили пробелы здесь, чтобы было нагляднее:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn  plus_one_v1   (x: i32 ) -&gt; i32 { x + 1 }
let plus_one_v2 = |x: i32 | -&gt; i32 { x + 1 };
let plus_one_v3 = |x: i32 |          x + 1  ;
#}</code></pre></pre>
<p>Есть небольшие различия, но принцип аналогичен.</p>
<h1><a class="header" href="#Замыкания-и-их-окружение" id="Замыкания-и-их-окружение">Замыкания и их окружение</a></h1>
<p>Замыкания называются так потому, что они 'замыкают свое окружение.' Это выглядит
следующим образом:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let num = 5;
let plus_num = |x: i32| x + num;

assert_eq!(10, plus_num(5));
#}</code></pre></pre>
<p>Это замыкание, <code>plus_num</code>, ссылается на связанную с помощью оператора <code>let</code>
переменную <code>num</code>, расположенную в своей области видимости. Если говорить более
конкретно, то оно заимствует связывание. Если мы сделаем что-то, что
противоречило бы связыванию, то получим ошибку. Например этот код:</p>
<pre><code class="language-rust ignore">let mut num = 5;
let plus_num = |x: i32| x + num;

let y = &amp;mut num;
</code></pre>
<p>Который выдаст следующие ошибки:</p>
<pre><code class="language-text">error: cannot borrow `num` as mutable because it is also borrowed as immutable
    let y = &amp;mut num;
                 ^~~
note: previous borrow of `num` occurs here due to use in closure; the immutable
  borrow prevents subsequent moves or mutable borrows of `num` until the borrow
  ends
    let plus_num = |x| x + num;
                   ^~~~~~~~~~~
note: previous borrow ends here
fn main() {
    let mut num = 5;
    let plus_num = |x| x + num;
    
    let y = &amp;mut num;
}
^
</code></pre>
<p>Подробное и к тому же полезное сообщение об ошибке! Как говорится в этом
сообщении, мы не можем получить изменяемый заем переменной <code>num</code> потому что
замыкание уже заимствует его. Если же мы обеспечим выход замыкания из области
видимости, то мы сможем:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut num = 5;
{
    let plus_num = |x: i32| x + num;

} // plus_num goes out of scope, borrow of num ends

let y = &amp;mut num;
#}</code></pre></pre>
<p>Однако, Rust также может забирать право владения и перемещать свое окружение,
если этого требует замыкание:</p>
<pre><code class="language-rust ignore">let nums = vec![1, 2, 3];

let takes_nums = || nums;

println!(&quot;{:?}&quot;, nums);
</code></pre>
<p>Этот код выдаст:</p>
<pre><code class="language-text">note: `nums` moved into closure environment here because it has type
  `[closure(()) -&gt; collections::vec::Vec&lt;i32&gt;]`, which is non-copyable
let takes_nums = || nums;
                    ^~~~~~~
</code></pre>
<p><code>Vec&lt;T&gt;</code> обладает правом владения на свое содержимое, и поэтому, когда мы
ссылаемся на него в нашем замыкании, мы должны забрать право владения на <code>nums</code>.
Это тоже самое, как если бы мы передавали <code>nums</code> в функцию, которая забирала бы
право владения на него.</p>
<h2><a class="header" href="#Перемещающие-замыкания-move-closures" id="Перемещающие-замыкания-move-closures">Перемещающие замыкания (<code>move</code> closures)</a></h2>
<p>Мы можем заставить наше замыкание забирать право владения на свое окружение с
помощью ключевого слова <code>move</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let num = 5;

let owns_num = move |x: i32| x + num;
#}</code></pre></pre>
<p>Теперь, когда указано ключевое слово <code>move</code>, переменные следуют нормальной
семантике перемещения. В данном примере <code>5</code> реализует <code>Copy</code>, поэтому <code>owns_num</code>
становится владельцем копии <code>num</code>. Так в чем же разница?</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut num = 5;

{
    let mut add_num = |x: i32| num += x;

    add_num(5);
}

assert_eq!(10, num);
#}</code></pre></pre>
<p>Итак, в этом примере наше замыкание принимает изменяемую ссылку на <code>num</code>. Затем,
когда мы вызываем замыкание <code>add_num</code>, то, как мы и ожидали, оно изменяет
значение внутри. Нам также необходимо объявить <code>add_num</code> как <code>mut</code>, потому что
оно изменяет свое окружение.</p>
<p>Если же мы будем использовать <code>move</code> замыкание, то получим следующие отличия:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut num = 5;

{
    let mut add_num = move |x: i32| num += x;

    add_num(5);
}

assert_eq!(5, num);
#}</code></pre></pre>
<p>Мы всего лишь получаем <code>5</code>. Вместо того, чтобы получать изменяемый заем на
<code>num</code>, мы получаем право владения на копию.</p>
<p>Вот еще один способ думать о <code>move</code> замыканиях: они предоставляют замыкание со
своим собственным фреймом стека. Без <code>move</code> замыкание может быть связано с
фреймом стека, который его создал, в то время как <code>move</code> замыкание содержит свой
собственный фрейм стека. Это означает, например, что вы не можете вернуть не
<code>move</code> замыкание из функции.</p>
<p>Но прежде чем говорить о получении в качестве аргумента и возвращении замыкания,
мы должны поговорить о том, как реализуются замыкания. Как системный язык
программирования, Rust дает вам кучу контроля над тем, что делает ваш код, и
замыкания не являются исключением.</p>
<h1><a class="header" href="#Реализация-замыканий" id="Реализация-замыканий">Реализация замыканий</a></h1>
<p>Реализация замыканий в Rust немного отличается от других языков. Фактически, она
представляет из себя просто синтаксический сахар для типажей. Перед тем как
читать дальше, настоятельно рекомендуем изучить главу <a href="traits.html">Типажи</a>, а также
главу <a href="trait-objects.html">Типажи-объекты</a>, в которой говорится о типажах-объектах.</p>
<p>Изучили? Хорошо.</p>
<p>Ключ к пониманию того, как замыкания работают изнутри звучит немного странно:
использование <code>()</code> для вызова функции, как например <code>foo()</code>, представляет собой
перегружаемую операцию. Исходя из этого, все остальное встает на свои места. В
Rust мы используем систему типажей для перегрузки операций. Вызов функций не
является исключением. Существуют три отдельных типажа для их перегрузки:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# mod foo {
pub trait Fn&lt;Args&gt; : FnMut&lt;Args&gt; {
    extern &quot;rust-call&quot; fn call(&amp;self, args: Args) -&gt; Self::Output;
}

pub trait FnMut&lt;Args&gt; : FnOnce&lt;Args&gt; {
    extern &quot;rust-call&quot; fn call_mut(&amp;mut self, args: Args) -&gt; Self::Output;
}

pub trait FnOnce&lt;Args&gt; {
    type Output;

    extern &quot;rust-call&quot; fn call_once(self, args: Args) -&gt; Self::Output;
}
# }
#}</code></pre></pre>
<p>Вы можете заметить некоторые различия между этими типажами, но есть одно главное
различие — <code>self</code>: <code>Fn</code> принимает <code>&amp;self</code>, <code>FnMut</code> принимает <code>&amp;mut self</code>,
<code>FnOnce</code> принимает <code>self</code>. Это покрывает все три вида <code>self</code> с помощью обычного
синтаксиса вызова методов. Мы разделили их на три типажа, вместо того, чтобы
иметь один. Это дает нам большее количество контроля над тем, какого вида
замыкания мы можем принять.</p>
<p>Использование <code>|| {}</code> при создании замыканий является синтаксическим сахаром для
этих трех типажей. Rust будет генерировать структуру для окружения, реализующую
(<code>impl</code>) соответствующий типаж, а затем использовать его.</p>
<h1><a class="header" href="#Передача-замыканий-в-качестве-аргументов" id="Передача-замыканий-в-качестве-аргументов">Передача замыканий в качестве аргументов</a></h1>
<p>Теперь, когда мы знаем, что замыкания являются типажами, получается, что мы уже
знаем, как принимать и возвращать замыкания: как и любой другой типаж!</p>
<p>Это также означает, что мы можем выбирать между статической и динамической
диспетчеризацией. Во-первых, давайте напишем функцию, которая принимает что-то
вызываемое, вызывает это что-то и возвращает результат:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn call_with_one&lt;F&gt;(some_closure: F) -&gt; i32
    where F : Fn(i32) -&gt; i32 {

    some_closure(1)
}

let answer = call_with_one(|x| x + 2);

assert_eq!(3, answer);
#}</code></pre></pre>
<p>Мы передаем наше замыкание <code>|x| x + 2</code>, в функцию <code>call_with_one</code>. Она же
делает то, о чем говорит ее название: вызывает замыкание, передавая ему <code>1</code> в
качестве аргумента.</p>
<p>Давайте рассмотрим сигнатуру функции <code>call_with_one</code> более подробно:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn call_with_one&lt;F&gt;(some_closure: F) -&gt; i32
#    where F : Fn(i32) -&gt; i32 {
#    some_closure(1) }
#}</code></pre></pre>
<p>Мы принимаем один параметр, который имеет тип <code>F</code>. Мы также возвращаем <code>i32</code>.
Эта часть не интересна. Следующим важным моментом является:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn call_with_one&lt;F&gt;(some_closure: F) -&gt; i32
    where F : Fn(i32) -&gt; i32 {
#   some_closure(1) }
#}</code></pre></pre>
<p>Так как <code>Fn</code> является типажом, мы можем связать с ним наш обобщенный параметр. В
этом примере, замыкание принимает <code>i32</code> в качестве аргумента и возвращает <code>i32</code>,
поэтому связывание, которое мы используем, выглядит так: <code>Fn(i32) -&gt; i32</code>.</p>
<p>Здесь есть еще один ключевой момент: так как мы ограничиваем обобщённый параметр
с помощью типажа, то будет применена мономорфизация, и поэтому в замыкании будет
использоваться статическая диспетчеризация. Это довольно лаконично (аккуратно).
Во многих языках для замыканий по существу используется выделение памяти в куче,
и поэтому всегда будет использоваться динамическая диспетчеризация. В Rust мы
можем выделить память для окружения замыкания в стеке и использовать статическую
диспетчеризацию вызова. Это случается довольно часто с итераторами и их
адаптерами, которые нередко принимают замыкания в качестве аргументов.</p>
<p>Конечно, если нам нужна динамическая диспетчеризация, мы также можем
использовать и ее. Обычно для этого случая используется типаж-объект:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn call_with_one(some_closure: &amp;Fn(i32) -&gt; i32) -&gt; i32 {
    some_closure(1)
}

let answer = call_with_one(&amp;|x| x + 2);

assert_eq!(3, answer);
#}</code></pre></pre>
<p>Теперь наша функция в качетве аргумента принимает типаж-объект <code>&amp;Fn</code>. Поэтому мы
должны создать ссылку на замыкание, а затем передать ее в функцию
<code>call_with_one</code>, для этого мы используем <code>&amp;||</code>.</p>
<h1><a class="header" href="#Возврат-замыканий" id="Возврат-замыканий">Возврат замыканий</a></h1>
<p>Что очень характерно для кода в функциональном стиле — возвращать замыкания в
различных ситуациях. Если вы попытаетесь вернуть замыкание, то можете
столкнуться с ошибкой. Сперва это может показаться странным, но мы с этим
разберемся. Вот как вы, наверное, попытаетесь вернуть замыкание из функции:</p>
<pre><code class="language-rust ignore">fn factory() -&gt; (Fn(i32) -&gt; i32) {
    let num = 5;

    |x| x + num
}

let f = factory();

let answer = f(1);
assert_eq!(6, answer);
</code></pre>
<p>Это выдаст следующие длинные, взаимосвязанные ошибки:</p>
<pre><code class="language-text">error: the trait `core::marker::Sized` is not implemented for the type
`core::ops::Fn(i32) -&gt; i32` [E0277]
fn factory() -&gt; (Fn(i32) -&gt; i32) {
                ^~~~~~~~~~~~~~~~
note: `core::ops::Fn(i32) -&gt; i32` does not have a constant size known at compile-time
fn factory() -&gt; (Fn(i32) -&gt; i32) {
                ^~~~~~~~~~~~~~~~
error: the trait `core::marker::Sized` is not implemented for the type `core::ops::Fn(i32) -&gt; i32` [E0277]
let f = factory();
    ^
note: `core::ops::Fn(i32) -&gt; i32` does not have a constant size known at compile-time
let f = factory();
    ^
</code></pre>
<p>Для того чтобы вернуть что-то из функции, Rust должен знать, какой размер имеет
тип возвращаемого значения. Но так как <code>Fn</code> является типажом, то в качестве него
могут выступать совершенно разные объекты, с разными размерами: много различных
типов могут реализовать <code>Fn</code>. Самый простой способ передать что-то
неопределенного размера — передать ссылку на это что-то, так как ссылки имеют
известный размер. Таким образом, следовало бы написать так:</p>
<pre><code class="language-rust ignore">fn factory() -&gt; &amp;(Fn(i32) -&gt; i32) {
    let num = 5;

    |x| x + num
}

let f = factory();

let answer = f(1);
assert_eq!(6, answer);
</code></pre>
<p>Но тогда мы получим другую ошибку:</p>
<pre><code class="language-text">error: missing lifetime specifier [E0106]
fn factory() -&gt; &amp;(Fn(i32) -&gt; i32) {
                ^~~~~~~~~~~~~~~~~
</code></pre>
<p>Верно. Так как у нас используется ссылка, то мы должны задать ее время жизни.
Так наша функция <code>factory()</code> не принимает никаких аргументов, то элизия
(сокрытие) здесь не уместна. Какое время жизни мы должны выбрать? <code>'static</code>:</p>
<pre><code class="language-rust ignore">fn factory() -&gt; &amp;'static (Fn(i32) -&gt; i32) {
    let num = 5;

    |x| x + num
}

let f = factory();

let answer = f(1);
assert_eq!(6, answer);
</code></pre>
<p>Но мы получим еще ошибку:</p>
<pre><code class="language-text">error: mismatched types:
 expected `&amp;'static core::ops::Fn(i32) -&gt; i32`,
    found `[closure &lt;anon&gt;:7:9: 7:20]`
(expected &amp;-ptr,
    found closure) [E0308]
         |x| x + num
         ^~~~~~~~~~~

</code></pre>
<p>Эта ошибка сообщает нам, что ожидается использование <code>&amp;'static Fn(i32) -&gt; i32</code>,
а используется <code>[closure &lt;anon&gt;:7:9: 7:20]</code>. Подождите, что?</p>
<p>Поскольку каждое замыкание (в индивидуальном порядке) генерирует свою
собственную <code>struct</code> для окружения и реализует <code>Fn</code> и компанию, то эти типы
являются анонимными. Они существуют исключительно для этого замыкания. Поэтому
Rust показывает их как <code>closure &lt;anon&gt;</code>, а не в виде какого-то автоматически
сгенерированного имени.</p>
<p>Но почему же наше замыкание не реализует <code>&amp;'static Fn</code>? Как мы обсуждали ранее,
замыкание заимствует свое окружение. И в этом случае наше окружение представляет
собой выделенную в стеке память, содержащую значение связанной переменной <code>num</code> -
<code>5</code>. Из-за этого заем имеет срок жизни фрейма стека. Так что, когда мы вернем
это замыкание, то вызов функции будет завершен, а фрейм стека уйдет, и наше
замыкание захватит окружение, содержащее в памяти мусор!</p>
<p>Так что же делать? Этот код <em>почти</em> работает:</p>
<pre><code class="language-rust ignore">fn factory() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    let num = 5;

    Box::new(|x| x + num)
}
# fn main() {
let f = factory();

let answer = f(1);
assert_eq!(6, answer);
# }
</code></pre>
<p>Мы используем типаж-объект, полученный в результате упаковки (<code>Box</code>) типажа
<code>Fn</code>. И остаётся только одна, последняя проблема:</p>
<pre><code class="language-text">error: closure may outlive the current function, but it borrows `num`,
which is owned by the current function [E0373]
Box::new(|x| x + num)
         ^~~~~~~~~~~
</code></pre>
<p>Мы все еще по-прежнему ссылаемся на родительский фрейм стека. С этим последним
исправлением мы сможем наконец выполнить нашу задачу:</p>
<pre><pre class="playpen"><code class="language-rust">fn factory() -&gt; Box&lt;Fn(i32) -&gt; i32&gt; {
    let num = 5;

    Box::new(move |x| x + num)
}
# fn main() {
let f = factory();

let answer = f(1);
assert_eq!(6, answer);
# }
</code></pre></pre>
<p>Благодаря изменению внутреннего замыкания на <code>move Fn</code> будет создаваться новый
фрейм стека для нашего замыкания. А благодаря упаковке (<code>Box</code>) замыкания,
получается известный размер возвращаемого значения, и позволяет ему избежать
(быть независимым от) нашего фрейма стека.</p>
<p>% Универсальный синтаксис вызова функций (universal function call syntax)</p>
<p>Иногда, функции могут иметь одинаковые имена. Рассмотрим этот код:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Foo {
    fn f(&amp;self);
}

trait Bar {
    fn f(&amp;self);
}

struct Baz;

impl Foo for Baz {
    fn f(&amp;self) { println!(&quot;Baz’s impl of Foo&quot;); }
}

impl Bar for Baz {
    fn f(&amp;self) { println!(&quot;Baz’s impl of Bar&quot;); }
}

let b = Baz;
#}</code></pre></pre>
<p>Если мы попытаемся вызвать <code>b.f()</code>, то получим ошибку:</p>
<pre><code class="language-text">error: multiple applicable methods in scope [E0034]
b.f();
  ^~~
note: candidate #1 is defined in an impl of the trait `main::Foo` for the type
`main::Baz`
    fn f(&amp;self) { println!(&quot;Baz’s impl of Foo&quot;); }
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
note: candidate #2 is defined in an impl of the trait `main::Bar` for the type
`main::Baz`
    fn f(&amp;self) { println!(&quot;Baz’s impl of Bar&quot;); }
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

</code></pre>
<p>Нам нужен способ указать, какой конкретно метод нужен, чтобы устранить
неоднозначность. Эта возможность называется «универсальный синтаксис вызова
функций», и выглядит это так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait Foo {
#     fn f(&amp;self);
# }
# trait Bar {
#     fn f(&amp;self);
# }
# struct Baz;
# impl Foo for Baz {
#     fn f(&amp;self) { println!(&quot;Baz’s impl of Foo&quot;); }
# }
# impl Bar for Baz {
#     fn f(&amp;self) { println!(&quot;Baz’s impl of Bar&quot;); }
# }
# let b = Baz;
Foo::f(&amp;b);
Bar::f(&amp;b);
#}</code></pre></pre>
<p>Давайте разберемся.</p>
<pre><code class="language-rust ignore">Foo::
Bar::
</code></pre>
<p>Эти части вызова задают один из двух видов типажей: <code>Foo</code> и <code>Bar</code>. Это то, что
на самом деле устраняет неоднозначность между двумя методами: Rust вызывает
метод того типажа, имя которого вы используете.</p>
<pre><code class="language-rust ignore">f(&amp;b)
</code></pre>
<p>Когда мы вызываем метод, используя <a href="method-syntax.html">синтаксис вызова метода</a>, как
например <code>b.f()</code>, Rust автоматически заимствует <code>b</code>, если <code>f()</code> принимает в
качестве аргумента <code>&amp;self</code>. В этом же случае, Rust не будет использовать
автоматическое заимствование, и поэтому мы должны явно передать <code>&amp;b</code>.</p>
<h1><a class="header" href="#Форма-с-угловыми-скобками" id="Форма-с-угловыми-скобками">Форма с угловыми скобками</a></h1>
<p>Форма UFCS, о которой мы только что говорили:</p>
<pre><code class="language-rust ignore">Trait::method(args);
</code></pre>
<p>Это сокращенная форма записи. Ниже представлена расширенная форма записи,
которая требуется в некоторых ситуациях:</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::method(args);
</code></pre>
<p>Синтаксис <code>&lt;&gt;::</code> является средством предоставления подсказки типа. Тип
располагается внутри <code>&lt;&gt;</code>. В этом случае типом является <code>Type as Trait</code>,
указывающий, что мы хотим здесь вызвать <code>Trait</code> версию метода. Часть <code>as Trait</code>
является необязательной, если вызов не является неоднозначным. То же самое что с
угловыми скобками, отсюда и короткая форма.</p>
<p>Вот пример использования длинной формы записи.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Foo {
    fn clone(&amp;self);
}

#[derive(Clone)]
struct Bar;

impl Foo for Bar {
    fn clone(&amp;self) {
        println!(&quot;Making a clone of Bar&quot;);

        &lt;Bar as Clone&gt;::clone(self);
    }
}
#}</code></pre></pre>
<p>Этот код вызывает метод <code>clone()</code> типажа <code>Clone</code>, а не типажа <code>Foo</code>.</p>
<p>% Контейнеры (crates) и модули (modules)</p>
<p>Когда проект начинает разрастаться, то хорошей практикой разработки программного
обеспечения считается: разбить его на небольшие кусочки, а затем собрать их
вместе. Также важно иметь четко определенный интерфейс, так как часть вашей
функциональности является приватной, а часть — публичной. Для облегчения такого
рода вещей Rust обладает модульной системой.</p>
<h1><a class="header" href="#Основные-термины-контейнеры-и-модули" id="Основные-термины-контейнеры-и-модули">Основные термины: контейнеры и модули</a></h1>
<p>Rust имеет два различных термина, которые относятся к модульной системе:
<em>контейнер</em> и <em>модуль</em>. Контейнер — это синоним <em>библиотеки</em> или <em>пакета</em> на
других языках. Именно поэтому инструмент управления пакетами в Rust называется
Cargo: вы пересылаете ваши контейнеры другим с помощью Cargo. Контейнеры могут
производить исполняемый файл или библиотеку, в зависимости от проекта.</p>
<p>Каждый контейнер имеет неявный <em>корневой модуль</em>, содержащий код для этого
контейнера. В рамках этого базового модуля можно определить дерево суб-модулей.
Модули позволяют разделить ваш код внутри контейнера.</p>
<p>В качестве примера, давайте сделаем контейнер <em>phrases</em>, который выдает нам
различные фразы на разных языках. Чтобы не усложнять пример, мы будем
использовать два вида фраз: «greetings» и «farewells», и два языка для этих
фраз: английский и японский (日本語). Мы будем использовать следующий шаблон
модуля:</p>
<pre><code class="language-text">                                    +-----------+
                                +---| greetings |
                                |   +-----------+
                  +---------+   |
              +---| english |---+
              |   +---------+   |   +-----------+
              |                 +---| farewells |
+---------+   |                     +-----------+
| phrases |---+
+---------+   |                     +-----------+
              |                 +---| greetings |
              |   +----------+  |   +-----------+
              +---| japanese |--+
                  +----------+  |
                                |   +-----------+
                                +---| farewells |
                                    +-----------+
</code></pre>
<p>В этом примере, <code>phrases</code> — это название нашего контейнера. Все остальное -
модули. Вы можете видеть, что они образуют дерево, в основании которого
располагается <em>корень</em> контейнера — <code>phrases</code>.</p>
<p>Теперь, когда у нас есть схема, давайте определим модули в коде. Для начала
создайте новый контейнер с помощью Cargo:</p>
<pre><code class="language-bash">$ cargo new phrases
$ cd phrases
</code></pre>
<p>Если вы помните, то эта команда создает простой проект:</p>
<pre><code class="language-bash">$ tree .
.
├── Cargo.toml
└── src
    └── lib.rs

1 directory, 2 files
</code></pre>
<p><code>src/lib.rs</code> — корень нашего контейнера, соответствующий <code>phrases</code> в нашей
диаграмме выше.</p>
<h1><a class="header" href="#Объявление-модулей" id="Объявление-модулей">Объявление модулей</a></h1>
<p>Для объявления каждого из наших модулей, мы используем ключевое слово <code>mod</code>.
Давайте сделаем, чтобы наш <code>src/lib.rs</code> выглядел следующим образом:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod english {
    mod greetings {
    }

    mod farewells {
    }
}

mod japanese {
    mod greetings {
    }

    mod farewells {
    }
}
#}</code></pre></pre>
<p>После ключевого слова <code>mod</code>, вы задаете имя модуля. Имена модулей следуют
соглашениям, как и другие идентификаторы Rust: <code>lower_snake_case</code>. Содержание
каждого модуля обрамляется в фигурные скобки (<code>{}</code>).</p>
<p>Внутри <code>mod</code> вы можете объявить суб-<code>mod</code>. Мы можем обращаться к суб-модулям с
помощью нотации (<code>::</code>). Так выглядят обращения к нашим четырем вложенным
модулям: <code>english::greetings</code>, <code>english::farewells</code>, <code>japanese::greetings</code> и
<code>japanese::farewells</code>. Так как суб-модули располагаются в пространстве имен
своих родительских модулей, то суб-модули <code>english::greetings</code> и
<code>japanese::greetings</code> не конфликтуют, несмотря на то, что они имеют одинаковые
имена, <code>greetings</code>.</p>
<p>Так как в этом контейнере нет функции <code>main()</code>, и называется он <code>lib.rs</code>, Cargo
соберет этот контейнер в виде библиотеки:</p>
<pre><code class="language-bash">$ cargo build
   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
$ ls target/debug
build  deps  examples  libphrases-a7448e02a0468eaa.rlib  native
</code></pre>
<p><code>libphrase-hash.rlib</code> — это скомпилированный контейнер. Прежде чем мы
рассмотрим, как его можно использовать из другого контейнера, давайте
разобьем его на несколько файлов.</p>
<h1><a class="header" href="#Контейнеры-с-несколькими-файлами" id="Контейнеры-с-несколькими-файлами">Контейнеры с несколькими файлами</a></h1>
<p>Если бы каждый контейнер мог состоять только из одного файла, тогда этот файл
был бы очень большим. Зачастую легче разделить контейнер на несколько файлов, и
Rust поддерживает это двумя способами.</p>
<p>Вместо объявления модуля наподобие:</p>
<pre><code class="language-rust ignore">mod english {
    // contents of our module go here
}
</code></pre>
<p>Мы можем объявить наш модуль в виде:</p>
<pre><code class="language-rust ignore">mod english;
</code></pre>
<p>Если мы это сделаем, то Rust будет ожидать, что найдет либо файл <code>english.rs</code>,
либо файл <code>english/mod.rs</code> с содержимым нашего модуля.</p>
<p>Обратите внимание, что в этих файлах вам не требуется заново объявлять модуль:
это уже сделано при изначальном объявлении <code>mod</code>.</p>
<p>С помощью этих двух приемов мы можем разбить наш контейнер на две директории и
семь файлов:</p>
<pre><code class="language-bash">$ tree .
.
├── Cargo.lock
├── Cargo.toml
├── src
│   ├── english
│   │   ├── farewells.rs
│   │   ├── greetings.rs
│   │   └── mod.rs
│   ├── japanese
│   │   ├── farewells.rs
│   │   ├── greetings.rs
│   │   └── mod.rs
│   └── lib.rs
└── target
    └── debug
        ├── build
        ├── deps
        ├── examples
        ├── libphrases-a7448e02a0468eaa.rlib
        └── native
</code></pre>
<p><code>src/lib.rs</code> — корень нашего контейнера, и выглядит он следующим образом:</p>
<pre><code class="language-rust ignore">mod english;
mod japanese;
</code></pre>
<p>Эти два объявления информируют Rust, что следует искать: <code>src/english.rs</code> или
<code>src/english/mod.rs</code>, <code>src/japanese.rs</code> или <code>src/japanese/mod.rs</code>, в зависимости
от нашей структуры. В данном примере мы выбрали второй вариант из-за того, что
наши модули содержат суб-модули. И <code>src/english/mod.rs</code> и <code>src/japanese/mod.rs</code>
выглядят следующим образом:</p>
<pre><code class="language-rust ignore">mod greetings;
mod farewells;
</code></pre>
<p>В свою очередь, эти объявления информируют Rust, что следует искать:
<code>src/english/greetings.rs</code>, <code>src/japanese/greetings.rs</code>,
<code>src/english/farewells.rs</code>, <code>src/japanese/farewells.rs</code> или
<code>src/english/greetings/mod.rs</code>, <code>src/japanese/greetings/mod.rs</code>,
<code>src/english/farewells/mod.rs</code>, <code>src/japanese/farewells/mod.rs</code>. Так как эти
суб-модули не содержат свои собственные суб-модули, то мы выбрали
<code>src/english/greetings.rs</code> и <code>src/japanese/farewells.rs</code>. Вот так!</p>
<p>Содержание <code>src/english/greetings.rs</code> и <code>src/japanese/farewells.rs</code> являются
пустыми на данный момент. Давайте добавим несколько функций.</p>
<p>Поместите следующий код в <code>src/english/greetings.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn hello() -&gt; String {
    &quot;Hello!&quot;.to_string()
}
#}</code></pre></pre>
<p>Следующий код в <code>src/english/farewells.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn goodbye() -&gt; String {
    &quot;Goodbye.&quot;.to_string()
}
#}</code></pre></pre>
<p>Следующий код в <code>src/japanese/greetings.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn hello() -&gt; String {
    &quot;こんにちは&quot;.to_string()
}
#}</code></pre></pre>
<p>Конечно, вы можете скопировать и вставить этот код с этой страницы, или просто
напечатать что-нибудь еще. Вам совершенно не обязательно знать, что на японском
языке написано «Konnichiwa», чтобы понять как работает модульная система.</p>
<p>Поместите следующий код в <code>src/japanese/farewells.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn goodbye() -&gt; String {
    &quot;さようなら&quot;.to_string()
}
#}</code></pre></pre>
<p>(Это «Sayonara», если вам интересно.)</p>
<p>Теперь у нас есть некоторая функциональность в нашем контейнере, давайте
попробуем использовать его из другого контейнера.</p>
<h1><a class="header" href="#Импорт-внешних-контейнеров" id="Импорт-внешних-контейнеров">Импорт внешних контейнеров</a></h1>
<p>У нас есть библиотечный контейнер. Давайте создадим исполняемый контейнер,
который импортирует и использует нашу библиотеку.</p>
<p>Создайте файл <code>src/main.rs</code> и положите в него следующее: (при этом он не будет
компилироваться)</p>
<pre><code class="language-rust ignore">extern crate phrases;

fn main() {
    println!(&quot;Hello in English: {}&quot;, phrases::english::greetings::hello());
    println!(&quot;Goodbye in English: {}&quot;, phrases::english::farewells::goodbye());

    println!(&quot;Hello in Japanese: {}&quot;, phrases::japanese::greetings::hello());
    println!(&quot;Goodbye in Japanese: {}&quot;, phrases::japanese::farewells::goodbye());
}
</code></pre>
<p>Объявление <code>extern crate</code> информирует Rust о том, что для компиляции и компоновки
кода нам нужен контейнер <code>phrases</code>. После этого объявление мы можем использовать
модули контейнера <code>phrases</code>. Как мы уже упоминали ранее, вы можете использовать
два подряд идущих символа двоеточия для обращения к суб-модулям и функциям
внутри них.</p>
<p>Кроме того, Cargo предполагает, что <code>src/main.rs</code> — это корень бинарного, а не
библиотечного контейнера. Теперь наш пакет содержит два контейнера: <code>src/lib.rs</code>
и <code>src/main.rs</code>. Этот шаблон является довольно распространенным для исполняемых
контейнеров: основная функциональность сосредоточена в библиотечном контейнере,
а исполняемый контейнер использует эту библиотеку. Таким образом, другие
программы также могут использовать библиотечный контейнер, к тому же такой
подход обеспечивает отделение интереса (разделение функциональности).</p>
<p>Хотя этот код все еще не работает. Мы получаем четыре ошибки, которые выглядят
примерно так:</p>
<pre><code class="language-bash">$ cargo build
   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
src/main.rs:4:38: 4:72 error: function `hello` is private
src/main.rs:4     println!(&quot;Hello in English: {}&quot;, phrases::english::greetings::hello());
                                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
note: in expansion of format_args!
&lt;std macros&gt;:2:25: 2:58 note: expansion site
&lt;std macros&gt;:1:1: 2:62 note: in expansion of print!
&lt;std macros&gt;:3:1: 3:54 note: expansion site
&lt;std macros&gt;:1:1: 3:58 note: in expansion of println!
phrases/src/main.rs:4:5: 4:76 note: expansion site
</code></pre>
<p>По умолчанию все элементы в Rust являются приватными. Давайте поговорим об этом
более подробно.</p>
<h1><a class="header" href="#Экспорт-публичных-интерфейсов" id="Экспорт-публичных-интерфейсов">Экспорт публичных интерфейсов</a></h1>
<p>Rust позволяет точно контролировать, какие элементы вашего интерфейса являются
публичными, и поэтому по умолчанию все элементы являются приватными. Чтобы
сделать элементы публичными, вы используете ключевое слово <code>pub</code>. Давайте
сначала сосредоточимся на модуле <code>english</code>, для чего сократим файл <code>src/main.rs</code>
до этого:</p>
<pre><code class="language-rust ignore">extern crate phrases;

fn main() {
    println!(&quot;Hello in English: {}&quot;, phrases::english::greetings::hello());
    println!(&quot;Goodbye in English: {}&quot;, phrases::english::farewells::goodbye());
}
</code></pre>
<p>В файле <code>src/lib.rs</code> в объявлении модуля <code>english</code> давайте добавим модификатор
<code>pub</code>:</p>
<pre><code class="language-rust ignore">pub mod english;
mod japanese;
</code></pre>
<p>В файле <code>src/english/mod.rs</code> давайте сделаем оба модуля с модификатором <code>pub</code>:</p>
<pre><code class="language-rust ignore">pub mod greetings;
pub mod farewells;
</code></pre>
<p>В файле <code>src/english/greetings.rs</code> давайте добавим модификатор <code>pub</code> к
объявлению нашей функции <code>fn</code>:</p>
<pre><code class="language-rust ignore">pub fn hello() -&gt; String {
    &quot;Hello!&quot;.to_string()
}
</code></pre>
<p>А также в файле <code>src/english/farewells.rs</code>:</p>
<pre><code class="language-rust ignore">pub fn goodbye() -&gt; String {
    &quot;Goodbye.&quot;.to_string()
}
</code></pre>
<p>Теперь наши контейнеры компилируются, хотя и с предупреждениями о том, что
функции в модуле <code>japanese</code> не используются:</p>
<pre><code class="language-bash">$ cargo run
   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
src/japanese/greetings.rs:1:1: 3:2 warning: function is never used: `hello`, #[warn(dead_code)] on by default
src/japanese/greetings.rs:1 fn hello() -&gt; String {
src/japanese/greetings.rs:2     &quot;こんにちは&quot;.to_string()
src/japanese/greetings.rs:3 }
src/japanese/farewells.rs:1:1: 3:2 warning: function is never used: `goodbye`, #[warn(dead_code)] on by default
src/japanese/farewells.rs:1 fn goodbye() -&gt; String {
src/japanese/farewells.rs:2     &quot;さようなら&quot;.to_string()
src/japanese/farewells.rs:3 }
     Running `target/debug/phrases`
Hello in English: Hello!
Goodbye in English: Goodbye.
</code></pre>
<p>Теперь, когда функции являются публичными, мы можем их использовать. Отлично!
Тем не менее, написание <code>phrases::english::greetings::hello()</code> является очень
длинным и неудобным. Rust предоставляет другое ключевое слово, для импорта имен
в текущую область, чтобы для обращения можно было использовать короткие имена.
Давайте поговорим об этом ключевом слове, <code>use</code>.</p>
<h1><a class="header" href="#Импорт-модулей-с-помощью-use" id="Импорт-модулей-с-помощью-use">Импорт модулей с помощью <code>use</code></a></h1>
<p>Rust предоставляет ключевое слово <code>use</code>, которое позволяет импортировать имена в
нашу локальную область видимости. Давайте изменим файл <code>src/main.rs</code>, чтобы он
выглядел следующим образом:</p>
<pre><code class="language-rust ignore">extern crate phrases;

use phrases::english::greetings;
use phrases::english::farewells;

fn main() {
    println!(&quot;Hello in English: {}&quot;, greetings::hello());
    println!(&quot;Goodbye in English: {}&quot;, farewells::goodbye());
}
</code></pre>
<p>Две строки, начинающиеся с <code>use</code>, импортируют соответствующие модули в локальную
область видимости, поэтому мы можем обратиться к функциям по гораздо более
коротким именам. По соглашению, при импорте функции, лучшей практикой считается
импортировать модуль, а не функцию непосредственно. Другими словами, вы <em>могли
бы</em> сделать следующее:</p>
<pre><code class="language-rust ignore">extern crate phrases;

use phrases::english::greetings::hello;
use phrases::english::farewells::goodbye;

fn main() {
    println!(&quot;Hello in English: {}&quot;, hello());
    println!(&quot;Goodbye in English: {}&quot;, goodbye());
}
</code></pre>
<p>Но такой подход не является идиоматическим. Он значительно чаще приводит к
конфликту имен. Для нашей короткой программы это не так важно, но, как только
программа разрастается, это становится проблемой. Если у нас возникает конфликт
имен, то Rust выдает ошибку компиляции. Например, если мы сделаем функции
<code>japanese</code> публичными, и пытаемся скомпилировать этот код:</p>
<pre><code class="language-rust ignore">extern crate phrases;

use phrases::english::greetings::hello;
use phrases::japanese::greetings::hello;

fn main() {
    println!(&quot;Hello in English: {}&quot;, hello());
    println!(&quot;Hello in Japanese: {}&quot;, hello());
}
</code></pre>
<p>Rust выдаст нам сообщение об ошибке во время компиляции:</p>
<pre><code class="language-text">   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
src/main.rs:4:5: 4:40 error: a value named `hello` has already been imported in this module [E0252]
src/main.rs:4 use phrases::japanese::greetings::hello;
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
error: aborting due to previous error
Could not compile `phrases`.
</code></pre>
<p>Если мы импортируем несколько имен из одного модуля, то нам совсем не
обязательно писать одно и то же много раз. Вместо этого кода:</p>
<pre><code class="language-rust ignore">use phrases::english::greetings;
use phrases::english::farewells;
</code></pre>
<p>Вы можете использовать сокращение:</p>
<pre><code class="language-rust ignore">use phrases::english::{greetings, farewells};
</code></pre>
<h2><a class="header" href="#Реэкспорт-с-помощью-pub-use" id="Реэкспорт-с-помощью-pub-use">Реэкспорт с помощью <code>pub use</code></a></h2>
<p>Вы можете использовать <code>use</code> не просто для сокращения идентификаторов. Вы также
можете использовать его внутри вашего контейнера, чтобы реэкспортировать функцию
из другого модуля. Это позволяет представить внешний интерфейс, который может не
напрямую отображать внутреннюю организацию кода.</p>
<p>Давайте посмотрим на примере. Измените файл <code>src/main.rs</code> следующим образом:</p>
<pre><code class="language-rust ignore">extern crate phrases;

use phrases::english::{greetings,farewells};
use phrases::japanese;

fn main() {
    println!(&quot;Hello in English: {}&quot;, greetings::hello());
    println!(&quot;Goodbye in English: {}&quot;, farewells::goodbye());

    println!(&quot;Hello in Japanese: {}&quot;, japanese::hello());
    println!(&quot;Goodbye in Japanese: {}&quot;, japanese::goodbye());
}
</code></pre>
<p>Затем измените файл <code>src/lib.rs</code>, чтобы сделать модуль <code>japanese</code> с публичным:</p>
<pre><code class="language-rust ignore">pub mod english;
pub mod japanese;
</code></pre>
<p>Далее, убедитесь, что обе функции публичные, сперва в
<code>src/japanese/greetings.rs</code>:</p>
<pre><code class="language-rust ignore">pub fn hello() -&gt; String {
    &quot;こんにちは&quot;.to_string()
}
</code></pre>
<p>А затем в <code>src/japanese/farewells.rs</code>:</p>
<pre><code class="language-rust ignore">pub fn goodbye() -&gt; String {
    &quot;さようなら&quot;.to_string()
}
</code></pre>
<p>Наконец, измените файл <code>src/japanese/mod.rs</code> вот так:</p>
<pre><code class="language-rust ignore">pub use self::greetings::hello;
pub use self::farewells::goodbye;

mod greetings;
mod farewells;
</code></pre>
<p>Объявление <code>pub use</code> привносит указанную функцию в эту часть области видимости
нашей модульной иерархии. Так как мы использовали <code>pub use</code> внутри нашего модуля
<code>japanese</code>, то теперь мы можем вызывать функцию <code>phrases::japanese::hello()</code> и
функцию <code>phrases::japanese::goodbye()</code>, хотя код для них расположен в
<code>phrases::japanese::greetings::hello()</code> и
<code>phrases::japanese::farewells::goodbye()</code> соответственно. Наша внутренняя
организация не определяет наш внешний интерфейс.</p>
<p>В этом примере мы используем <code>pub use</code> отдельно для каждой функции, которую
хотим привнести в область <code>japanese</code>. В качестве альтернативы, мы могли бы
использовать шаблонный синтаксис, чтобы включать в себя все элементы из модуля
<code>greetings</code> в текущую область: <code>pub use self::greetings::*</code>.</p>
<p>Что можно сказать о <code>self</code>? По умолчанию объявления <code>use</code> используют абсолютные
пути, начинающиеся с корня контейнера. <code>self</code>, напротив, формирует эти пути
относительно текущего места в иерархии. У <code>use</code> есть еще одна особая форма: вы
можете использовать <code>use super::</code>, чтобы подняться по дереву на один уровень
вверх от вашего текущего местоположения. Некоторые предпочитают думать о <code>self</code>
как о <code>.</code>, а о <code>super</code> как о <code>..</code>, что для многих командных оболочек является
представлением для текущей директории и для родительской директории
соответственно.</p>
<p>Вне <code>use</code>, пути относительны: <code>foo::bar()</code> ссылаться на функцию внутри <code>foo</code>
относительно того, где мы находимся. Если же используется префикс <code>::</code>, то
<code>::foo::bar()</code> будет ссылаться на другой <code>foo</code>, абсолютный путь относительно
корня контейнера.</p>
<p>Кроме того, обратите внимание, что мы использовали <code>pub use</code> прежде, чем
объявили наши модули с помощью <code>mod</code>. Rust требует, чтобы объявления <code>use</code> шли в
первую очередь.</p>
<p>Следующий код собирается и работает:</p>
<pre><code class="language-bash">$ cargo run
   Compiling phrases v0.0.1 (file:///home/you/projects/phrases)
     Running `target/debug/phrases`
Hello in English: Hello!
Goodbye in English: Goodbye.
Hello in Japanese: こんにちは
Goodbye in Japanese: さようなら
</code></pre>
<p>% <code>const</code> и <code>static</code></p>
<p>В Rust можно определить постоянную с помощью ключевого слова <code>const</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
const N: i32 = 5;
#}</code></pre></pre>
<p>В отличие от обычных имён, объявляемых с помощью <a href="variable-bindings.html"><code>let</code></a>, тип постоянной
надо указывать всегда.</p>
<p>Постоянные живут в течение всего времени работы программы. А именно, у них
вообще нет определённого адреса в памяти. Это потому, что они встраиваются
(inline) в каждое место, где есть их использование. По этой причине ссылки на
одну и ту же постоянную не обязаны указывать на один и тот же адрес в памяти.</p>
<h1><a class="header" href="#static-1" id="static-1"><code>static</code></a></h1>
<p>В Rust также можно объявить что-то вроде «глобальной переменной», используя
статические значения. Они похожи на постоянные, но статические значения
не встраиваются в место их использования. Это значит, что каждое значение
существует в единственном экземпляре, и у него есть определённый адрес.</p>
<p>Вот пример:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
static N: i32 = 5;
#}</code></pre></pre>
<p>Так же, как и в случае с постоянными, тип статического значения надо указывать
всегда.</p>
<p>Статические значения живут в течение всего времени работы программы, и любая
ссылка на постоянную имеет <a href="lifetimes.html">статическое время жизни</a> (<code>static</code>
lifetime):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
static NAME: &amp;'static str = &quot;Steve&quot;;
#}</code></pre></pre>
<h2><a class="header" href="#Изменяемость-1" id="Изменяемость-1">Изменяемость</a></h2>
<p>Вы можете сделать статическое значение изменяемым с помощью ключевого слова
<code>mut</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
static mut N: i32 = 5;
#}</code></pre></pre>
<p>Поскольку <code>N</code> изменяемо, один поток может изменить его во время того, как другой
читает его значение. Это ситуация «гонки» по данным, и она считается
небезопасным поведением в Rust. Поэтому и чтение, и изменение статического
изменяемого значения (<code>static mut</code>) является <a href="unsafe.html">небезопасным</a> (unsafe), и
обе эти операции должны выполняться в небезопасных блоках (<code>unsafe</code> block):</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# static mut N: i32 = 5;

unsafe {
    N += 1;

    println!(&quot;N: {}&quot;, N);
}
#}</code></pre></pre>
<p>Более того, любой тип, хранимый в статической переменной, должен быть ограничен
<code>Sync</code> и не может иметь реализации <a href="drop.html"><code>Drop</code></a>.</p>
<h1><a class="header" href="#Инициализация" id="Инициализация">Инициализация</a></h1>
<p>И постоянные, и статические значения имеют определённые требования к тому, что
можно хранить в них. Они могут быть проинициализированы только выражением,
значение которого постоянно. Другими словами, вы не можете использовать вызов
функции или что-то, вычисляемое во время исполнения.</p>
<h1><a class="header" href="#Какую-конструкцию-стоит-использовать" id="Какую-конструкцию-стоит-использовать">Какую конструкцию стоит использовать?</a></h1>
<p>Почти всегда стоит предпочитать постоянные. Ситуация, когда вам нужно реальное
место в памяти и соответствующий ему адрес довольно редка. А использование
постоянных позволяет компилятору провести оптимизации вроде распространения
постоянных (constant propagation) не только в вашем контейнере, но и в тех,
которые зависят от него.</p>
<p>% Атрибуты</p>
<p>В Rust объявления могут быть аннотированы с помощью «атрибутов». Они выглядят
так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
# fn foo() {}
#}</code></pre></pre>
<p>или так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# mod foo {
#![test]
# }
#}</code></pre></pre>
<p>Разница между ними состоит в символе <code>!</code>, который изменяет его поведение,
определяющее к какому элементу применяется атрибут:</p>
<pre><code class="language-rust ignore">#[foo]
struct Foo;

mod bar {
    #![bar]
}
</code></pre>
<p>Атрибут <code>#[foo]</code> относится к следующему за ним элементу, который является
объявлением <code>struct</code>. Атрибут <code>#![bar]</code> относится к элементу охватывающему его,
который является объявлением <code>mod</code>. В остальном они одинаковы. Оба каким-то
образом изменяют значение элемента, к которому они прикреплены.</p>
<p>Например, рассмотрим такую функцию:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn check() {
    assert_eq!(2, 1 + 1);
}
#}</code></pre></pre>
<p>Функция помечена как <code>#[test]</code>. Это означает, что она особенная: эта функция
будет выполняться при запуске <a href="testing.html">тестов</a>. При компиляции, как правило, она
не будет включена. Теперь эта функция является функцией тестирования.</p>
<p>Атрибуты также могут иметь дополнительные данные:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[inline(always)]
fn super_fast_fn() {
# }
#}</code></pre></pre>
<p>Или даже ключи и значения:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(target_os = &quot;macos&quot;)]
mod macos_only {
# }
#}</code></pre></pre>
<p>Атрибуты в Rust используются для ряда различных вещей. Вот <a href="https://doc.rust-lang.org/stable/reference.html#attributes">ссылка</a>
на полный список атрибутов. В настоящее время вы не можете создавать свои
собственные атрибуты, компилятор Rust определяет их.</p>
<p>% Псевдонимы типов</p>
<p>Ключевое слово <code>type</code> позволяет объявить псевдоним другого типа:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type Name = String;
#}</code></pre></pre>
<p>Затем вы можете использовать этот псевдоним вместо реального типа:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type Name = String;

let x: Name = &quot;Hello&quot;.to_string();
#}</code></pre></pre>
<p>Однако, обратите внимание на то что <em>псевдоним</em> не объявляет новый тип. Rust
строго типизированный язык, например у вас не получится сравнить значения двух
различных типов:</p>
<pre><code class="language-rust ignore">let x: i32 = 5;
let y: i64 = 5;

if x == y {
   // ...
}
</code></pre>
<p>Вы получите ошибку при компиляции:</p>
<pre><code class="language-text">error: mismatched types:
 expected `i32`,
    found `i64`
(expected i32,
    found i64) [E0308]
     if x == y {
             ^
</code></pre>
<p>Но если мы используем псевдоним:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type Num = i32;

let x: i32 = 5;
let y: Num = 5;

if x == y {
   // ...
}
#}</code></pre></pre>
<p>То этот пример скомпилируется без ошибок. Значения типа <code>Num</code> всегда будут такие
же как и у типа <code>i32</code>.</p>
<p>Вы также можете использовать псевдонимы типов с обобщённым кодом:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::result;

enum ConcreteError {
    Foo,
    Bar,
}

type Result&lt;T&gt; = result::Result&lt;T, ConcreteError&gt;;
#}</code></pre></pre>
<p>В этом примере мы создаем свою версию типа <code>Result</code>, который всегда будет
использовать перечисление <code>ConcreteError</code> в <code>Result&lt;T, E&gt;</code> вместо типа <code>E</code>.
Псевдонимы типов часто используются в модулях стандартной библиотеки для
создания своих псевдонимов для <code>Result&lt;T, E&gt;</code>. Например, <a href="http://doc.rust-lang.org/std/io/type.Result.html">io::Result</a>.</p>
<p>% Приведение типов</p>
<p>Rust, со своим акцентом на безопасность, обеспечивает два различных способа
преобразования различных типов между собой. Первый — <code>as</code>, для безопасного
приведения. Второй — <code>transmute</code>, в отличие от первого, позволяет произвольное
приведение типов и является одной из самых опасных возможностей Rust!</p>
<h1><a class="header" href="#as" id="as"><code>as</code></a></h1>
<p>Ключевое слово <code>as</code> выполняет обычное приведение типов:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x: i32 = 5;

let y = x as i64;
#}</code></pre></pre>
<p>Оно допускает только определенные виды приведения типов:</p>
<pre><code class="language-rust ignore">let a = [0u8, 0u8, 0u8, 0u8];

let b = a as u32; // four eights makes 32
</code></pre>
<p>Это приведет к ошибке:</p>
<pre><code class="language-text">error: non-scalar cast: `[u8; 4]` as `u32`
let b = a as u32; // four eights makes 32
        ^~~~~~~~
</code></pre>
<p>Это «нескалярное преобразование», потому что у нас здесь преобразуются
множественные значения: четыре элемента массива. Такие виды преобразований очень
опасны, потому что они делают предположения о том, как реализованы множественные
нижележащие структуры. Поэтому нам нужно что-то более опасное.</p>
<h1><a class="header" href="#transmute" id="transmute"><code>transmute</code></a></h1>
<p>Функция <code>transmute</code> предоставляется [внутренними средствами компилятора]
<a href="intrinsics.html">intrinsics</a>, и то, что она делает, является очень простым, но в то же время
очень опасным. Она сообщает Rust, чтобы он воспринимал значение одного типа, как
будто это значение другого типа. Это делается независимо от системы проверки
типов, и поэтому полностью на ваш страх и риск.</p>
<p>В предыдущем примере, мы знаем, что массив из четырех <code>u8</code> отображается в массив
<code>u32</code> должным образом, и поэтому мы хотим выполнить приведение. Если вместо <code>as</code>
использовать <code>transmute</code>, то Rust позволит это сделать:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::mem;

unsafe {
    let a = [0u8, 0u8, 0u8, 0u8];

    let b = mem::transmute::&lt;[u8; 4], u32&gt;(a);
}
#}</code></pre></pre>
<p>Для того чтобы компиляция прошла успешно, мы должны обернуть эту операцию в
<code>unsafe</code> блок. Технически, только вызов <code>mem::transmute</code> должен быть выполнен в
небезопасном блоке, но в данном случае хорошо было бы поместить в этот блок все
необходимое, связаное с этим вызовом, чтобы было удобнее искать. В данном
примере связаной необходимой переменной является <code>a</code>, и поэтому она находится в
блоке. Код может быть в любом стиле, иногда контекст расположен слишком далеко,
и тогда упаковка всего кода в <code>unsafe</code> не будет такой уж хорошей идеей.</p>
<p>Хотя при использовании <code>transmute</code> и выполняется очень мало проверок, но как
минимум будет проверяться, что типы имеют одинаковый размер. Нижеприведенный код
завершится ошибкой:</p>
<pre><code class="language-rust ignore">use std::mem;

unsafe {
    let a = [0u8, 0u8, 0u8, 0u8];

    let b = mem::transmute::&lt;[u8; 4], u64&gt;(a);
}
</code></pre>
<p>со следующим описанием:</p>
<pre><code class="language-text">error: transmute called on types with different sizes: [u8; 4] (32 bits) to u64
(64 bits)
</code></pre>
<p>Все, кроме этой одной проверки, на ваш страх и риск!</p>
<p>% Ассоциированные типы</p>
<p>Ассоциированные (связанные) типы — это мощная часть системы типов в Rust. Они
связаны с идеей 'семейства типа', другими словами, группировки различных типов
вместе. Это описание немного абстрактно, так что давайте разберем на примере.
Если вы хотите написать типаж <code>Graph</code>, то нужны два обобщенных параметра типа:
тип узел и тип ребро. Исходя из этого, вы можете написать типаж <code>Graph&lt;N, E&gt;</code>,
который выглядит следующим образом:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Graph&lt;N, E&gt; {
    fn has_edge(&amp;self, &amp;N, &amp;N) -&gt; bool;
    fn edges(&amp;self, &amp;N) -&gt; Vec&lt;E&gt;;
    // etc
}
#}</code></pre></pre>
<p>Такое решение вроде бы достигает своей цели, но, в конечном счете, является
неудобным. Например, любая функция, которая принимает <code>Graph</code> в качестве
параметра, <em>также</em> должна быть обобщённой с параметрами <code>N</code> и <code>E</code>:</p>
<pre><code class="language-rust ignore">fn distance&lt;N, E, G: Graph&lt;N, E&gt;&gt;(graph: &amp;G, start: &amp;N, end: &amp;N) -&gt; u32 { 
    ... 
}
</code></pre>
<p>Наша функция расчета расстояния работает независимо от типа <code>Edge</code>, поэтому
параметр <code>E</code> в этой сигнатуре является лишним и только отвлекает.</p>
<p>Что действительно нужно заявить, это чтобы сформировать какого-либо вида
<code>Graph</code>, нужны соответствующие типы <code>E</code> и <code>N</code>, собранные вместе. Мы можем
сделать это с помощью ассоциированных типов:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Graph {
    type N;
    type E;

    fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
    fn edges(&amp;self, &amp;Self::N) -&gt; Vec&lt;Self::E&gt;;
    // etc
}
#}</code></pre></pre>
<p>Теперь наши клиенты могут абстрагироваться от определенного <code>Graph</code>:</p>
<pre><code class="language-rust ignore">fn distance&lt;G: Graph&gt;(graph: &amp;G, start: &amp;G::N, end: &amp;G::N) -&gt; u32 { ... }
</code></pre>
<p>Больше нет необходимости иметь дело с типом <code>E</code>!</p>
<p>Давайте поговорим обо всем этом более подробно.</p>
<h2><a class="header" href="#Определение-ассоциированных-типов" id="Определение-ассоциированных-типов">Определение ассоциированных типов</a></h2>
<p>Давайте построим наш типаж <code>Graph</code>. Вот его определение:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait Graph {
    type N;
    type E;

    fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
    fn edges(&amp;self, &amp;Self::N) -&gt; Vec&lt;Self::E&gt;;
}
#}</code></pre></pre>
<p>Достаточно просто. Ассоциированные типы используют ключевое слово <code>type</code>, и
расположены внутри тела типажа, наряду с функциями.</p>
<p>Эти объявления <code>type</code> могут иметь все то же самое, как и при работе с функциями.
Например, если бы мы хотели, чтобы тип <code>N</code> реализовывал <code>Display</code>, чтобы была
возможность печатать узлы, мы могли бы сделать следующее:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt;

trait Graph {
    type N: fmt::Display;
    type E;

    fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
    fn edges(&amp;self, &amp;Self::N) -&gt; Vec&lt;Self::E&gt;;
}
#}</code></pre></pre>
<h2><a class="header" href="#Реализация-ассоциированных-типов" id="Реализация-ассоциированных-типов">Реализация ассоциированных типов</a></h2>
<p>Типаж, который включает ассоциированные типы, как и любой другой типаж, для
реализации использует ключевое слово <code>impl</code>. Вот простая реализация <code>Graph</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait Graph {
#     type N;
#     type E;
#     fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
#     fn edges(&amp;self, &amp;Self::N) -&gt; Vec&lt;Self::E&gt;;
# }
struct Node;

struct Edge;

struct MyGraph;

impl Graph for MyGraph {
    type N = Node;
    type E = Edge;

    fn has_edge(&amp;self, n1: &amp;Node, n2: &amp;Node) -&gt; bool {
        true
    }

    fn edges(&amp;self, n: &amp;Node) -&gt; Vec&lt;Edge&gt; {
        Vec::new()
    }
}
#}</code></pre></pre>
<p>Это глупая реализация, которая всегда возвращает <code>true</code> и пустой <code>Vec&lt;Edge&gt;</code>, но
она дает вам общее представление о том, как реализуются такие ​​вещи. Для начала
нужны три <code>struct</code>, одна для графа, одна для узла и одна для ребра. В этой
реализации используются <code>struct</code> для всех трех сущностей, но вполне могли бы
использоваться и другие типы, которые работали бы так же хорошо, если бы
реализация была более продвинутой.</p>
<p>Затем идет строка с <code>impl</code>, которая является такой же, как и при реализации
любого другого типажа.</p>
<p>Далее мы используем знак <code>=</code>, чтобы определить наши ассоциированные типы. Имя
типажа идет слева от знака <code>=</code>, а конкретный тип, для которого мы <code>impl</code> этот
типаж, идет справа. Наконец, мы используем конкретные типы при объявлении
функций.</p>
<h2><a class="header" href="#Типажи-объекты-и-ассоциированные-типы" id="Типажи-объекты-и-ассоциированные-типы">Типажи-объекты и ассоциированные типы</a></h2>
<p>Вот еще немного синтаксиса, о котором следует упомянуть: типажи-объекты. Если вы
попытаетесь создать типаж-объект из ассоциированного типа, как в этом примере:</p>
<pre><code class="language-rust ignore"># trait Graph {
#     type N;
#     type E;
#     fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
#     fn edges(&amp;self, &amp;Self::N) -&gt; Vec&lt;Self::E&gt;;
# }
# struct Node;
# struct Edge;
# struct MyGraph;
# impl Graph for MyGraph {
#     type N = Node;
#     type E = Edge;
#     fn has_edge(&amp;self, n1: &amp;Node, n2: &amp;Node) -&gt; bool {
#         true
#     }
#     fn edges(&amp;self, n: &amp;Node) -&gt; Vec&lt;Edge&gt; {
#         Vec::new()
#     }
# }
let graph = MyGraph;
let obj = Box::new(graph) as Box&lt;Graph&gt;;
</code></pre>
<p>Вы получите две ошибки:</p>
<pre><code class="language-text">error: the value of the associated type `E` (from the trait `main::Graph`) must
be specified [E0191]
let obj = Box::new(graph) as Box&lt;Graph&gt;;
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
24:44 error: the value of the associated type `N` (from the trait
`main::Graph`) must be specified [E0191]
let obj = Box::new(graph) as Box&lt;Graph&gt;;
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>
<p>Мы не сможем создать типаж-объект, подобный этому, потому что у него нет
информации об ассоциированных типах. Вместо этого, мы можем написать так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# trait Graph {
#     type N;
#     type E;
#     fn has_edge(&amp;self, &amp;Self::N, &amp;Self::N) -&gt; bool;
#     fn edges(&amp;self, &amp;Self::N) -&gt; Vec&lt;Self::E&gt;;
# }
# struct Node;
# struct Edge;
# struct MyGraph;
# impl Graph for MyGraph {
#     type N = Node;
#     type E = Edge;
#     fn has_edge(&amp;self, n1: &amp;Node, n2: &amp;Node) -&gt; bool {
#         true
#     }
#     fn edges(&amp;self, n: &amp;Node) -&gt; Vec&lt;Edge&gt; {
#         Vec::new()
#     }
# }
let graph = MyGraph;
let obj = Box::new(graph) as Box&lt;Graph&lt;N=Node, E=Edge&gt;&gt;;
#}</code></pre></pre>
<p>Синтаксис <code>N=Node</code> позволяет нам предоставлять конкретный тип, <code>Node</code>, для
параметра типа <code>N</code>. То же самое и для <code>E=Edge</code>. Если бы мы не предоставляли это
ограничение, то не могли бы знать наверняка, какая <code>impl</code> соответствует этому
типажу-объекту.</p>
<p>% Безразмерные типы</p>
<p>Большинство типов имеют определённый размер в байтах. Этот размер обычно
известен во время компиляции. Например, <code>i32</code> — это 32 бита, или 4 байта.
Однако, существуют некоторые полезные типы, которые не имеют определённого
размера. Они называются «безразмерными» или «типами динамического размера». Один
из примеров таких типов — это <code>[T]</code>. Этот тип представляет собой
последовательность из определённого числа элементов <code>T</code>. Но мы не знаем, как
много этих элементов, поэтому размер неизвестен.</p>
<p>Rust понимает несколько таких типов, но их использование несколько ограничено.
Есть три ограничения:</p>
<ol>
<li>Мы можем работать с экземпляром безразмерного типа только с помощью
указателя. <code>&amp;[T]</code> будет работать, а <code>[T]</code> — нет.</li>
<li>Переменные и аргументы не могут иметь тип динамического размера.</li>
<li>Только последнее поле структуры может быть безразмерного типа; другие — нет.
Варианты перечислений не могут содержать типы динамического размера в
качестве данных.</li>
</ol>
<p>А зачем это всё? Поскольку мы можем использовать <code>[T]</code> только через указатель,
если бы язык не поддерживал безразмерные типы, мы бы не смогли написать такой
код:</p>
<pre><code class="language-rust ignore">impl Foo for str {
</code></pre>
<p>или</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Foo for [T] {
</code></pre>
<p>Вместо этого, вам бы пришлось написать:</p>
<pre><code class="language-rust ignore">impl Foo for &amp;str {
</code></pre>
<p>Таким образом, данная реализация работала бы только для <a href="references-and-borrowing.html">ссылок</a>, и не
поддерживала бы другие типы указателей. А реализацию для безразмерного типа
смогут использовать любые указатели, включая определённые пользователем умные
указатели (позже, когда будут исправлены некоторые ошибки).</p>
<h1><a class="header" href="#sized" id="sized">?Sized</a></h1>
<p>Если вы пишете функцию, принимающую тип динамического размера, вы можете
использовать специальное ограничение <code>?Sized</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Foo&lt;T: ?Sized&gt; {
    f: T,
}
#}</code></pre></pre>
<p>Этот <code>?</code> читается как «Т может быть размерным (<code>Sized</code>)». Он означает, что это
ограничение особенное: оно разрешает использование некоторых типов, которые не
могли бы быть использованы в его отсутствие. Таким образом, оно <em>расширяет</em>
множество подходящих типов, а не сужает его. Это можно представить себе как если
бы все типы <code>T</code> неявно были размерными (<code>T: Sized</code>), а <code>?</code> отменял это
ограничение по умолчанию.</p>
<p>% Перегрузка операций</p>
<p>Rust позволяет ограниченную форму перегрузки операций. Есть определенные
операции, которые могут быть перегружены. Есть специальные типажи, которые вы
можете реализовать для поддержки конкретной операции между типами. В результате
чего перегружается операция.</p>
<p>Например, операция <code>+</code> может быть перегружена с помощью типажа <code>Add</code>:</p>
<pre><pre class="playpen"><code class="language-rust">use std::ops::Add;

#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point { x: self.x + other.x, y: self.y + other.y }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 0 };
    let p2 = Point { x: 2, y: 3 };

    let p3 = p1 + p2;

    println!(&quot;{:?}&quot;, p3);
}
</code></pre></pre>
<p>В <code>main</code> мы можем использовать операцию <code>+</code> для двух <code>Point</code>, так как мы
реализовали типаж <code>Add&lt;Output=Point&gt;</code> для <code>Point</code>.</p>
<p>Есть целый ряд операций, которые могут быть перегружены таким образом, и все
связанные с этим типажи расположены в модуле <a href="http://doc.rust-lang.org/std/ops/index.html"><code>std::ops</code></a>. Проверьте эту
часть документации для получения полного списка.</p>
<p>Реализация этих типажей следует паттерну. Давайте посмотрим на типаж
<a href="http://doc.rust-lang.org/std/ops/trait.Add.html"><code>Add</code></a> более детально:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# mod foo {
pub trait Add&lt;RHS = Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}
# }
#}</code></pre></pre>
<p>В общей сложности здесь присутствуют три типа: тип <code>impl Add</code>, который мы
реализуем, тип <code>RHS</code>, который по умолчанию равен <code>Self</code> и тип <code>Output</code>. Для
выражения <code>let z = x + y</code>: <code>x</code> — это тип <code>Self</code>, <code>y</code> — это тип <code>RHS</code>, а <code>z</code> -
это тип <code>Self::Output</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct Point;
# use std::ops::Add;
impl Add&lt;i32&gt; for Point {
    type Output = f64;

    fn add(self, rhs: i32) -&gt; f64 {
        // add an i32 to a Point and get an f64
# 1.0
    }
}
#}</code></pre></pre>
<p>позволит вам сделать следующее:</p>
<pre><code class="language-rust ignore">let p: Point = // ...
let x: f64 = p + 2i32;
</code></pre>
<h1><a class="header" href="#Использование-типажей-операций-в-обобщённых-структурах" id="Использование-типажей-операций-в-обобщённых-структурах">Использование типажей операций в обобщённых структурах</a></h1>
<p>Теперь, когда мы знаем, как реализованы типажи операций, мы можем реализовать
наш типаж <code>HasArea</code> и структуру <code>Square</code> из <a href="traits.html">главы о типажах</a> более
общим образом:</p>
<pre><pre class="playpen"><code class="language-rust">use std::ops::Mul;

trait HasArea&lt;T&gt; {
    fn area(&amp;self) -&gt; T;
}

struct Square&lt;T&gt; {
    x: T,
    y: T,
    side: T,
}

impl&lt;T&gt; HasArea&lt;T&gt; for Square&lt;T&gt;
        where T: Mul&lt;Output=T&gt; + Copy {
    fn area(&amp;self) -&gt; T {
        self.side * self.side
    }
}

fn main() {
    let s = Square {
        x: 0.0f64,
        y: 0.0f64,
        side: 12.0f64,
    };

    println!(&quot;Площадь s: {}&quot;, s.area());
}
</code></pre></pre>
<p>Мы просто объявляем тип-параметр <code>T</code> и используем его вместо <code>f64</code> в определении
<code>HasArea</code> и <code>Square</code>. В реализации нужно сделать более хитрые изменения:</p>
<pre><code class="language-ignore">impl&lt;T&gt; HasArea&lt;T&gt; for Square&lt;T&gt;
        where T: Mul&lt;Output=T&gt; + Copy { ... }
</code></pre>
<p>Чтобы реализовать <code>area</code>, мы должны мочь умножить операнды друг на друга,
поэтому мы объявляем <code>T</code> как реализующий <code>std::ops::Mul</code>. Как и <code>Add</code>, <code>Mul</code>
принимает параметр <code>Output</code>: т.к. мы знаем, что числа не меняют своего типа,
когда их умножают, <code>Output</code> также объявлен как <code>T</code>. <code>T</code> также должен
поддерживать копирование, чтобы Rust не пытался переместить <code>self.side</code> в
возвращаемое значение.</p>
<p>% Преобразования при разыменовании (deref coercions)</p>
<p>Стандартная библиотека Rust реализует особый типаж, <a href="http://doc.rust-lang.org/std/ops/trait.Deref.html"><code>Deref</code></a>. Обычно его
используют, чтобы перегрузить <code>*</code>, операцию разыменования:</p>
<pre><pre class="playpen"><code class="language-rust">use std::ops::Deref;

struct DerefExample&lt;T&gt; {
    value: T,
}

impl&lt;T&gt; Deref for DerefExample&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.value
    }
}

fn main() {
    let x = DerefExample { value: 'a' };
    assert_eq!('a', *x);
}
</code></pre></pre>
<p>Это полезно при написании своих указательных типов. Однако, в языке есть
возможность, связанная с <code>Deref</code>: преобразования при разыменовании. Вот правило:
если есть тип <code>U</code>, и он реализует <code>Deref&lt;Target=T&gt;</code>, значения <code>&amp;U</code> будут
автоматически преобразованы в <code>&amp;T</code>, когда это необходимо. Вот пример:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(s: &amp;str) {
    // позаимствуем строку на секунду
}

// String реализует Deref&lt;Target=str&gt;
let owned = &quot;Hello&quot;.to_string();

// Поэтому, такой код работает:
foo(&amp;owned);
#}</code></pre></pre>
<p>Амперсанд перед значением означает, что мы берём ссылку на него. Поэтому <code>owned</code></p>
<ul>
<li>это <code>String</code>, а <code>&amp;owned</code> — <code>&amp;String</code>. Поскольку у нас есть реализация типажа
<code>impl Deref&lt;Target=str&gt; for String</code>, <code>&amp;String</code> разыменуется в <code>&amp;str</code>, что
устраивает <code>foo()</code>.</li>
</ul>
<p>Вот и всё. Это правило — одно из немногих мест в Rust, где типы преобразуются
автоматически. Оно позволяет писать гораздо более гибкий код. Например, тип
<code>Rc&lt;T&gt;</code> реализует <code>Deref&lt;Target=T&gt;</code>, поэтому такой код работает:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::rc::Rc;

fn foo(s: &amp;str) {
    // позаимствуем строку на секунду
}

// String реализует Deref&lt;Target=str&gt;
let owned = &quot;Hello&quot;.to_string();
let counted = Rc::new(owned);

// Поэтому, такой код работает:
foo(&amp;counted);
#}</code></pre></pre>
<p>Мы всего лишь обернули наш <code>String</code> в <code>Rc&lt;T&gt;</code>. Но теперь мы можем передать
<code>Rc&lt;String&gt;</code> везде, куда мы могли передать <code>String</code>. Сигнатура <code>foo</code> не
поменялась, и работает как с одним, так и с другим типом. Этот пример делает два
преобразования: сначала <code>Rc&lt;String</code> преобразуется в <code>String</code>, а потом <code>String</code> в
<code>&amp;str</code>. Rust сделает столько преобразований, сколько возможно, пока типы не
совпадут.</p>
<p>Другая известная реализация, предоставляемая стандартной библиотекой, это
<code>impl Deref&lt;Target=[T]&gt; for Vec&lt;T&gt;</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn foo(s: &amp;[i32]) {
    // позаимствуем срез на секунду
}

// Vec&lt;T&gt; реализует Deref&lt;Target=[T]&gt;
let owned = vec![1, 2, 3];

foo(&amp;owned);
#}</code></pre></pre>
<p>Вектора могут разыменовываться в срезы.</p>
<h2><a class="header" href="#Разыменование-и-вызов-методов" id="Разыменование-и-вызов-методов">Разыменование и вызов методов</a></h2>
<p><code>Deref</code> также будет работать при вызове метода. Другими словами, возможен такой
код:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
struct Foo;

impl Foo {
    fn foo(&amp;self) { println!(&quot;Foo&quot;); }
}

let f = Foo;

f.foo();
#}</code></pre></pre>
<p>Несмотря на то, что <code>f</code> — это не ссылка, а <code>foo</code> принимает <code>&amp;self</code>, это будет
работать. Более того, все примеры ниже делают одно и то же:</p>
<pre><code class="language-rust ignore">f.foo();
(&amp;f).foo();
(&amp;&amp;f).foo();
(&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;f).foo();
</code></pre>
<p>Методы <code>Foo</code> можно вызывать и на значении типа <code>&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;Foo</code>, потому что
компилятор сделает столько разыменований, сколько нужно для совпадения типов.
А разыменование использует <code>Deref</code>.</p>
<p>% Макросы</p>
<p>К этому моменту вы узнали о многих инструментах Rust, которые нацелены на
абстрагирование и повторное использование кода. Эти единицы повторно
использованного кода имеют богатую смысловую структуру. Например, функции имеют
сигнатуры типа, типы параметров могут имеют ограничения по типажам,
перегруженные функции также могут принадлежать к определенному типажу.</p>
<p>Эта структура означает, что ключевые абстракции Rust имеют мощный механизм
проверки времени компиляции. Но это достигается за счет снижения гибкости. Если
вы визуально определите структуру повторно используемого кода, то вы можете
найти трудным или громоздким выражение этой схемы в виде обобщённой функции,
типажа, или чего-то еще в семантике Rust.</p>
<p>Макросы позволяют абстрагироваться на <em>синтаксическом</em> уровне. Вызов макроса
является сокращением для «расширенной» синтаксической формы. Это расширение
происходит в начале компиляции, до начала статической проверки. В результате,
макросы могут охватить много шаблонов повторного использования кода, которые
невозможны при использовании лишь ключевых абстракций Rust.</p>
<p>Недостатком является то, что код, основанный на макросах, может быть трудным для
понимания, потому что к нему применяется меньше встроенных правил. Подобно
обычной функции, качественный макрос может быть использован без понимания его
реализации. Тем не менее, может быть трудно разработать качественный макрос!
Кроме того, ошибки компилятора в макро коде сложнее интерпретировать, потому что
они описывают проблемы в расширенной форме кода, а не в исходной сокращенной
форме кода, которую используют разработчики.</p>
<p>Эти недостатки делают макросы чем-то вроде «возможности последней инстанции».
Это не означает, что макросы это плохо; они являются частью Rust, потому что
иногда они все же нужны для по-настоящему краткой записи хорошо абстрагированной
части кода. Просто имейте этот компромисс в виду.</p>
<h1><a class="header" href="#Определение-макросов-Макроопределения" id="Определение-макросов-Макроопределения">Определение макросов (Макроопределения)</a></h1>
<p>Вы, возможно, видели макрос <code>vec!</code>, который используется для инициализации
<a href="vectors.html">вектора</a> с произвольным количеством элементов.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x: Vec&lt;u32&gt; = vec![1, 2, 3];
# assert_eq!(x, [1, 2, 3]);
#}</code></pre></pre>
<p>Его нельзя реализовать в виде обычной функции, так как он принимает любое
количество аргументов. Но мы можем представить его в виде синтаксического
сокращения для следующего кода</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x: Vec&lt;u32&gt; = {
    let mut temp_vec = Vec::new();
    temp_vec.push(1);
    temp_vec.push(2);
    temp_vec.push(3);
    temp_vec
};
# assert_eq!(x, [1, 2, 3]);
#}</code></pre></pre>
<p>Мы можем реализовать это сокращение, используя макрос: <sup class="footnote-reference"><a href="#actual">1</a></sup></p>
<div class="footnote-definition" id="actual"><sup class="footnote-definition-label">1</sup>
<p>Фактическое определение <code>vec!</code> в libcollections отличается от
представленного здесь по соображениям эффективности и повторного
использования.</p>
</div>
<pre><pre class="playpen"><code class="language-rust">macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
# fn main() {
#     assert_eq!(vec![1,2,3], [1, 2, 3]);
# }
</code></pre></pre>
<p>Ого, тут много нового синтаксиса! Давайте разберем его.</p>
<pre><code class="language-ignore">macro_rules! vec { ... }
</code></pre>
<p>Тут мы определяем макрос с именем <code>vec</code>, аналогично тому, как <code>fn vec</code>
определяло бы функцию с именем <code>vec</code>. При вызове мы неформально пишем имя
макроса с восклицательным знаком, например, <code>vec!</code>. Восклицательный знак
является частью синтаксиса вызова и служит для того, чтобы отличать макрос от
обычной функции.</p>
<h2><a class="header" href="#Сопоставление-matching-Синтаксис-вызова-макрокоманды" id="Сопоставление-matching-Синтаксис-вызова-макрокоманды">Сопоставление (Matching) (Синтаксис вызова макрокоманды)</a></h2>
<p>Макрос определяется с помощью ряда <em>правил</em>, которые представляют собой варианты
сопоставления с образцом. Выше у нас было</p>
<pre><code class="language-ignore">( $( $x:expr ),* ) =&gt; { ... };
</code></pre>
<p>Это очень похоже на конструкцию <code>match</code>, но сопоставление происходит на уровне
синтаксических деревьев Rust, на этапе компиляции. Точка с запятой не является
обязательной для последнего (только здесь) варианта. «Образец» слева от <code>=&gt;</code>
известен как <em>шаблон совпадений</em> (<em>образец</em>) (<em>обнаружитель совпадений</em>)
(<em>matcher</em>). Он имеет <a href="https://doc.rust-lang.org/stable/reference.html#macros">свою собственную грамматику</a> в
рамках языка.</p>
<p>Образец <code>$x:expr</code> будет соответствовать любому выражению Rust, связывая его
дерево синтаксиса с <em>метапеременной</em> <code>$x</code>. Идентификатор <code>expr</code> является
<em>спецификатором фрагмента</em>; полные возможности перечислены далее в этой главе.
Образец, окруженный <code>$(...),*</code>, будет соответствовать нулю или более выражениям,
разделенным запятыми.</p>
<p>За исключением специального синтаксиса сопоставления с образцом, любые другие
элементы Rust, которые появляются в образце, должны в точности совпадать.
Например,</p>
<pre><pre class="playpen"><code class="language-rust">macro_rules! foo {
    (x =&gt; $e:expr) =&gt; (println!(&quot;mode X: {}&quot;, $e));
    (y =&gt; $e:expr) =&gt; (println!(&quot;mode Y: {}&quot;, $e));
}

fn main() {
    foo!(y =&gt; 3);
}
</code></pre></pre>
<p>выведет</p>
<pre><code class="language-text">mode Y: 3
</code></pre>
<p>А с</p>
<pre><code class="language-rust ignore">foo!(z =&gt; 3);
</code></pre>
<p>мы получим ошибку компиляции</p>
<pre><code class="language-text">error: no rules expected the token `z`
</code></pre>
<h2><a class="header" href="#Развертывание-expansion-Синтаксис-преобразования-макрокоманды" id="Развертывание-expansion-Синтаксис-преобразования-макрокоманды">Развертывание (Expansion) (Синтаксис преобразования макрокоманды)</a></h2>
<p>С правой стороны макро правил используется, по большей части, обычный синтаксис
Rust. Но мы можем соединить кусочки раздробленного синтаксиса, захваченные при
сопоставлении с соответствующим образцом. Из предыдущего примера:</p>
<pre><code class="language-ignore">$(
    temp_vec.push($x);
)*
</code></pre>
<p>Каждое соответствующее выражение <code>$x</code> будет генерировать одиночный оператор
<code>push</code> в развернутой форме макроса. Повторение в развернутой форме происходит
синхронно с повторением в форме образца (более подробно об этом чуть позже).</p>
<p>Поскольку <code>$x</code> уже объявлен в образце как выражение, мы не повторяем <code>:expr</code> с
правой стороны. Кроме того, мы не включаем разделяющую запятую в качестве
части оператора повторения. Вместо этого, у нас есть точка с запятой в пределах
повторяемого блока.</p>
<p>Еще одна деталь: макрос <code>vec!</code> имеет <em>две</em> пары фигурных скобках правой части.
Они часто сочетаются таким образом:</p>
<pre><code class="language-ignore">macro_rules! foo {
    () =&gt; {{
        ...
    }}
}
</code></pre>
<p>Внешние скобки являются частью синтаксиса <code>macro_rules!</code>. На самом деле, вы
можете использовать <code>()</code> или <code>[]</code> вместо них. Они просто разграничивают правую
часть в целом.</p>
<p>Внутренние скобки являются частью расширенного синтаксиса. Помните, что макрос
<code>vec!</code> используется в контексте выражения. Мы используем блок, для записи
выражения с множественными операторами, в том числе включающее <code>let</code> привязки.
Если ваш макрос раскрывается в одно единственное выражение, то дополнительной
слой скобок не нужен.</p>
<p>Обратите внимание, что мы никогда не <em>говорили</em>, что макрос создает выражения.
На самом деле, это не определяется, пока мы не используем макрос в качестве
выражения. Если соблюдать осторожность, то можно написать макрос, развернутая
форма которого будет валидна сразу в нескольких контекстах. Например,
сокращенная форма для типа данных может быть валидной и как выражение, и как
шаблон.</p>
<h2><a class="header" href="#Повторение-repetition-Многовариантность" id="Повторение-repetition-Многовариантность">Повторение (Repetition) (Многовариантность)</a></h2>
<p>Операции повтора всегда сопутствуют два основных правила:</p>
<ol>
<li><code>$(...)*</code> проходит через один «слой» повторений, для всех <code>$name</code>, которые он
содержит, в ногу, и</li>
<li>каждое <code>$name</code> должно быть под, по крайней мере, стольким количеством
<code>$(...)*</code>, сколько было использовано при сопоставлении. Если оно под большим
числом <code>$(...)*</code>, <code>$name</code> будет дублироваться, при необходимости.</li>
</ol>
<p>Этот причудливый макрос иллюстрирует дублирования переменных из внешних уровней
повторения.</p>
<pre><pre class="playpen"><code class="language-rust">macro_rules! o_O {
    (
        $(
            $x:expr; [ $( $y:expr ),* ]
        );*
    ) =&gt; {
        &amp;[ $($( $x + $y ),*),* ]
    }
}

fn main() {
    let a: &amp;[i32]
        = o_O!(10; [1, 2, 3];
               20; [4, 5, 6]);

    assert_eq!(a, [11, 12, 13, 24, 25, 26]);
}
</code></pre></pre>
<p>Это наибольшая синтаксиса совпадений. Эти примеры используют конструкцию
<code>$(...)*</code>, которая означает «ноль или более» совпадений. Также вы можете
написать <code>$(...)+</code>, что будет означать «одно или более» совпадений. Обе формы
записи включают необязательный разделитель, располагающийся сразу за закрывающей
скобкой, который может быть любым символом, за исключением <code>+</code> или <code>*</code>.</p>
<p>Эта система повторений основана на
«<a href="http://www.cs.indiana.edu/ftp/techreports/TR206.pdf">Macro-by-Example</a>» (PDF
ссылка).</p>
<h1><a class="header" href="#Гигиена-hygiene" id="Гигиена-hygiene">Гигиена (Hygiene)</a></h1>
<p>Некоторые языки реализуют макросы с помощью простой текстовой замены, что
приводит к различным проблемам. Например, нижеприведенная C программа напечатает
<code>13</code> вместо ожидаемого <code>25</code>.</p>
<pre><code class="language-text">#define FIVE_TIMES(x) 5 * x

int main() {
    printf(&quot;%d\n&quot;, FIVE_TIMES(2 + 3));
    return 0;
}
</code></pre>
<p>После развертывания мы получаем <code>5 * 2 + 3</code>, но умножение имеет больший
приоритет чем сложение. Если вы часто использовали C макросы, вы, наверное,
знаете стандартные идиомы для устранения этой проблемы, а также пять или шесть
других проблем. В Rust мы можем не беспокоиться об этом.</p>
<pre><pre class="playpen"><code class="language-rust">macro_rules! five_times {
    ($x:expr) =&gt; (5 * $x);
}

fn main() {
    assert_eq!(25, five_times!(2 + 3));
}
</code></pre></pre>
<p>Метапеременная <code>$x</code> обрабатывается как единый узел выражения, и сохраняет свое
место в дереве синтаксиса даже после замены.</p>
<p>Другой распространенной проблемой в системе макросов является <em>захват
переменной</em> (<em>variable capture</em>). Вот C макрос, использующий <a href="https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html">GNU C расширение</a>,
который эмулирует блоки выражениий в Rust.</p>
<pre><code class="language-text">#define LOG(msg) ({ \
    int state = get_log_state(); \
    if (state &gt; 0) { \
        printf(&quot;log(%d): %s\n&quot;, state, msg); \
    } \
})
</code></pre>
<p>Вот простой случай использования, применение которого может плохо кончиться:</p>
<pre><code class="language-text">const char *state = &quot;reticulating splines&quot;;
LOG(state)
</code></pre>
<p>Он раскрывается в</p>
<pre><code class="language-text">const char *state = &quot;reticulating splines&quot;;
int state = get_log_state();
if (state &gt; 0) {
    printf(&quot;log(%d): %s\n&quot;, state, state);
}
</code></pre>
<p>Вторая переменная с именем <code>state</code> затеняет первую. Это проблема, потому что
команде печати требуется обращаться к ним обоим.</p>
<p>Эквивалентный макрос в Rust обладает требуемым поведением.</p>
<pre><pre class="playpen"><code class="language-rust"># fn get_log_state() -&gt; i32 { 3 }
macro_rules! log {
    ($msg:expr) =&gt; {{
        let state: i32 = get_log_state();
        if state &gt; 0 {
            println!(&quot;log({}): {}&quot;, state, $msg);
        }
    }};
}

fn main() {
    let state: &amp;str = &quot;reticulating splines&quot;;
    log!(state);
}
</code></pre></pre>
<p>Это работает, потому что Rust имеет <a href="http://en.wikipedia.org/wiki/Hygienic_macro">систему макросов с соблюдением
гигиены</a>. Раскрытие каждого макроса происходит в
отдельном <em>контексте синтаксиса</em>, и каждая переменная обладает меткой контекста
синтаксиса, где она была введена. Это как если бы переменная <code>state</code> внутри
<code>main</code> была бы окрашена в другой «цвет» в отличае от переменной <code>state</code> внутри
макроса, из-за чего они бы не конфликтовали.</p>
<p>Это также ограничивает возможности макросов для внедрения новых связываний
переменных на месте вызова. Код, приведенный ниже, не будет работать:</p>
<pre><code class="language-rust ignore">macro_rules! foo {
    () =&gt; (let x = 3);
}

fn main() {
    foo!();
    println!(&quot;{}&quot;, x);
}
</code></pre>
<p>Вместо этого вы должны передавать имя переменной при вызове, тогда она будет
обладать меткой правильного контекста синтаксиса.</p>
<pre><pre class="playpen"><code class="language-rust">macro_rules! foo {
    ($v:ident) =&gt; (let $v = 3);
}

fn main() {
    foo!(x);
    println!(&quot;{}&quot;, x);
}
</code></pre></pre>
<p>Это справедливо для <code>let</code> привязок и меток loop, но не для <a href="https://doc.rust-lang.org/stable/reference.html#items">элементов</a>.
Код, приведенный ниже, компилируется:</p>
<pre><pre class="playpen"><code class="language-rust">macro_rules! foo {
    () =&gt; (fn x() { });
}

fn main() {
    foo!();
    x();
}
</code></pre></pre>
<h1><a class="header" href="#Рекурсия-макросов" id="Рекурсия-макросов">Рекурсия макросов</a></h1>
<p>Раскрытие макроса также может включать в себя вызовы макросов, в том числе
вызовы того макроса, который раскрывается. Эти рекурсивные макросы могут быть
использованы для обработки древовидного ввода, как показано на этом (упрощенном)
HTML сокращение:</p>
<pre><pre class="playpen"><code class="language-rust"># #![allow(unused_must_use)]
macro_rules! write_html {
    ($w:expr, ) =&gt; (());

    ($w:expr, $e:tt) =&gt; (write!($w, &quot;{}&quot;, $e));

    ($w:expr, $tag:ident [ $($inner:tt)* ] $($rest:tt)*) =&gt; {{
        write!($w, &quot;&lt;{}&gt;&quot;, stringify!($tag));
        write_html!($w, $($inner)*);
        write!($w, &quot;&lt;/{}&gt;&quot;, stringify!($tag));
        write_html!($w, $($rest)*);
    }};
}

fn main() {
#   // FIXME(#21826)
    use std::fmt::Write;
    let mut out = String::new();

    write_html!(&amp;mut out,
        html[
            head[title[&quot;Macros guide&quot;]]
            body[h1[&quot;Macros are the best!&quot;]]
        ]);

    assert_eq!(out,
        &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Macros guide&lt;/title&gt;&lt;/head&gt;\
         &lt;body&gt;&lt;h1&gt;Macros are the best!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;);
}
</code></pre></pre>
<p><a name="debugging-macro-code"></a></p>
<h1><a class="header" href="#Отладка-макросов" id="Отладка-макросов">Отладка макросов</a></h1>
<p>Чтобы увидеть результаты расширения макросов, выполните команду <code>rustc --pretty expanded</code>. Вывод представляет собой целый контейнер, так что вы можете подать
его обратно в <code>rustc</code>, что иногда выдает лучшие сообщения об ошибках, чем при
обычной компиляции. Обратите внимание, что вывод <code>--pretty expanded</code> может иметь
разное значение, если несколько переменных, имеющих одно и то же имя (но разные
контексты синтаксиса), находятся в той же области видимости. В этом случае
<code>--pretty expanded,hygiene</code> расскажет вам о контекстах синтаксиса.</p>
<p><code>rustc</code>, поддерживает два синтаксических расширения, которые помогают с отладкой
макросов. В настоящее время, они неустойчивы и требуют feature gates.</p>
<ul>
<li>
<p><code>log_syntax!(...)</code> будет печатать свои аргументы в стандартный вывод во время
компиляции, и «развертываться» в ничто.</p>
</li>
<li>
<p><code>trace_macros!(true)</code> будет выдавать сообщение компилятора каждый раз, когда
макрос развертывается. Используйте <code>trace_macros!(false)</code> в конце развертывания,
чтобы выключить его.</p>
</li>
</ul>
<h1><a class="header" href="#Требования-синтаксиса" id="Требования-синтаксиса">Требования синтаксиса</a></h1>
<p>Код на Rust может быть разобран в <a href="glossary.html#abstract-syntax-tree">синтаксическое дерево</a>, даже когда он
содержит неразвёрнутые макросы. Это свойство очень полезно для редакторов и
других инструментов, обрабатывающих исходный код. Оно также влияет на вид
системы макросов Rust.</p>
<p>Как следствие, когда компилятор разбирает вызов макроса, ему необходимо знать,
во что развернётся данный макрос. Макрос может разворачиваться в следующее:</p>
<ul>
<li>ноль или больше элементов;</li>
<li>ноль или больше методов;</li>
<li>выражение;</li>
<li>оператор;</li>
<li>образец.</li>
</ul>
<p>Вызов макроса в блоке может представлять собой элементы, выражение, или
оператор. Rust использует простое правило для разрешения этой
неоднозначности. Вызов макроса, производящего элементы, должен либо</p>
<ul>
<li>ограничиваться фигурными скобками, т.е. <code>foo! { ... }</code>;</li>
<li>завершаться точкой с запятой, т.е. <code>foo!(...);</code>.</li>
</ul>
<p>Другое следствие разбора перед раскрытием макросов — это то, что вызов макроса
должен состоять из допустимых лексем. Более того, скобки всех видов должны быть
сбалансированы в месте вызова. Например, <code>foo!([)</code> не является разрешённым
кодом. Такое поведение позволяет компилятору понимать где заканчивается вызов
макроса.</p>
<p>Говоря более формально, тело вызова макроса должно представлять собой
последовательность <em>деревьев лексем</em>. Дерево лексем определяется рекурсивно и
представляет собой либо:</p>
<ul>
<li>последовательность деревьев лексем, окружённую согласованными круглыми,
квадратными или фигурными скобками (<code>()</code>, <code>[]</code>, <code>{}</code>);</li>
<li>любую другую одиночную лексему.</li>
</ul>
<p>Внутри сопоставления каждая метапеременная имеет <em>указатель фрагмента</em>,
определяющий синтаксическую форму, с которой она совпадает. Вот список этих
указателей:</p>
<ul>
<li><code>ident</code>: идентификатор. Например: <code>x</code>; <code>foo</code>.</li>
<li><code>path</code>: квалифицированное имя. Например: <code>T::SpecialA</code>.</li>
<li><code>expr</code>: выражение. Например: <code>2 + 2</code>; <code>if true then { 1 } else { 2 }</code>;
<code>f(42)</code>.</li>
<li><code>ty</code>: тип. Например: <code>i32</code>; <code>Vec&lt;(char, String)&gt;</code>; <code>&amp;T</code>.</li>
<li><code>pat</code>: образец. Например: <code>Some(t)</code>; <code>(17, 'a')</code>; <code>_</code>.</li>
<li><code>stmt</code>: единственный оператор. Например: <code>let x = 3</code>.</li>
<li><code>block</code>: последовательность операторов, ограниченная фигурными
скобками. Например: <code>{ log(error, &quot;hi&quot;); return 12; }</code>.</li>
<li><code>item</code>: <a href="http://doc.rust-lang.org/reference.html#items">элемент</a>. Например: <code>fn foo() { }</code>; <code>struct Bar;</code>.</li>
<li><code>meta</code>: «мета-элемент», как в атрибутах. Например: <code>cfg(target_os = &quot;windows&quot;)</code>.</li>
<li><code>tt</code>: единственное дерево лексем.</li>
</ul>
<p>Есть дополнительные правила относительно лексем, следующих за метапеременной:</p>
<ul>
<li>за <code>expr</code> должно быть что-то из этого: <code>=&gt; , ;</code>;</li>
<li>за <code>ty</code> и <code>path</code> должно быть что-то из этого: <code>=&gt; , : = &gt; as</code>;</li>
<li>за <code>pat</code> должно быть что-то из этого : <code>=&gt; , =</code>;</li>
<li>за другими лексемами могут следовать любые символы.</li>
</ul>
<p>Приведённые правила обеспечивают развитие синтаксиса Rust без необходимости
менять существующие макросы.</p>
<p>И ещё: система макросов никак не обрабатывет неоднозначность разбора. Например,
грамматика <code>$($t:ty)* $e:expr</code> всегда будет выдавать ошибку, потому что
синтаксическому анализатору пришлось бы выбирать между разбором <code>$t</code> и разбором
<code>$e</code>. Можно изменить синтаксис вызова так, чтобы грамматика отличалась в начале.
В данном случае можно написать <code>$(T $t:ty)* E $e:exp</code>.</p>
<h1><a class="header" href="#Области-видимости-импорт-и-экспорт-макросов" id="Области-видимости-импорт-и-экспорт-макросов">Области видимости, импорт и экспорт макросов</a></h1>
<p>Макросы разворачиваются на ранней стадии компиляции, перед разрешением имён.
Один из недостатков такого подхода в том, что правила видимости для макросов
отличны от правил для других конструкций языка.</p>
<p>Компилятор определяет и разворачивает макросы при обходе графа исходного кода
контейнера в глубину. При этом определения макросов включаются в граф в порядке
их встречи компилятором. Поэтому макрос, определённый на уровне модуля, виден во
всём последующем коде модуля, включая тела всех вложенных модулей (<code>mod</code>).</p>
<p>Макрос, определённый в теле функции, или где-то ещё не на уровне модуля, виден
только внутри этого элемента (например, внутри одной функции).</p>
<p>Если модуль имеет атрибут <code>macro_use</code>, то его макросы также видны в его
родительском модуле после элемента <code>mod</code> данного модуля. Если родитель тоже
имеет атрибут <code>macro_use</code>, макросы также будут видны в модуле-родителе родителя,
после элемента <code>mod</code> родителя. Это распространяется на любое число уровней.</p>
<p>Атрибут <code>macro_use</code> также можно поставить на подключение контейнера <code>extern crate</code>. В этом контексте оно управляет тем, какие макросы будут загружены из
внешнего контейнера, т.е.</p>
<pre><code class="language-rust ignore">#[macro_use(foo, bar)]
extern crate baz;
</code></pre>
<p>Если атрибут записан просто как <code>#[macro_use]</code>, будут загружены все
макросы. Если атрибута нет, никакие макросы не будут загружены. Загружены могут
быть только макросы, объявленные с атрибутом <code>#[macro_export]</code>.</p>
<p>Чтобы загрузить макросы из контейнера <em>без</em> компоновки контейнера в выходной
артефакт, можно использовать атрибут <code>#[no_link]</code>.</p>
<p>Например:</p>
<pre><pre class="playpen"><code class="language-rust">macro_rules! m1 { () =&gt; (()) }

// здесь видны: m1

mod foo {
    // здесь видны: m1

    #[macro_export]
    macro_rules! m2 { () =&gt; (()) }

    // здесь видны: m1, m2
}

// здесь видны: m1

macro_rules! m3 { () =&gt; (()) }

// здесь видны: m1, m3

#[macro_use]
mod bar {
    // здесь видны: m1, m3

    macro_rules! m4 { () =&gt; (()) }

    // здесь видны: m1, m3, m4
}

// здесь видны: m1, m3, m4
# fn main() { }
</code></pre></pre>
<p>Когда эта библиотека загружается с помощью <code>#[macro_use] extern crate</code>, виден
только макрос <code>m2</code>.</p>
<p>Атрибуты, относящиеся к макросам,
<a href="https://doc.rust-lang.org/stable/reference.html#macro--and-plugin-related-attributes">перечислены в справочнике Rust</a>.</p>
<h1><a class="header" href="#Переменная-crate" id="Переменная-crate">Переменная <code>$crate</code></a></h1>
<p>Если макрос используется в нескольких контейнерах, всё становится ещё
сложнее. Допустим, <code>mylib</code> определяет</p>
<pre><pre class="playpen"><code class="language-rust">pub fn increment(x: u32) -&gt; u32 {
    x + 1
}

#[macro_export]
macro_rules! inc_a {
    ($x:expr) =&gt; ( ::increment($x) )
}

#[macro_export]
macro_rules! inc_b {
    ($x:expr) =&gt; ( ::mylib::increment($x) )
}
# fn main() { }
</code></pre></pre>
<p><code>inc_a</code> работает только внутри <code>mylib</code>, а <code>inc_b</code> — только снаружи. Более того,
<code>inc_b</code> сломается, если пользователь импортирует <code>mylib</code> под другим именем.</p>
<p>В Rust пока нет гигиеничных ссылок на контейнеры, но есть простой способ обойти
эту проблему. Особая макро-переменная <code>$crate</code> раскроется в <code>::foo</code> внутри
макроса, импортированного из контейнера <code>foo</code>. А когда макрос определён и
используется в одном и том же контейнере, <code>$crate</code> станет пустой. Это означает,
что мы можем написать</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_export]
macro_rules! inc {
    ($x:expr) =&gt; ( $crate::increment($x) )
}
# fn main() { }
</code></pre></pre>
<p>чтобы определить один макрос, который будет работать и внутри, и снаружи
библиотеки. Имя функции раскроется или в <code>::increment</code>, или в
<code>::mylib::increment</code>.</p>
<p>Чтобы эта система работала просто и правильно, <code>#[macro_use] extern crate ...</code>
может быть написано только в корне вашего контейнера, но не внутри <code>mod</code>. Это
обеспечивает, что <code>$crate</code> раскроется в единственный идентификатор.</p>
<h1><a class="header" href="#Во-тьме-глубин" id="Во-тьме-глубин">Во тьме глубин</a></h1>
<p>Вводная глава упоминала рекурсивные макросы, но она не рассказывала всей
истории. Рекурсивные макросы полезны ещё по одной причине: каждый рекурсивный
вызов даёт нам ещё одну возможность сопоставить с образцом аргументы макроса.</p>
<p>Приведём такой радикальный пример использования данной возможности. С помощью
рекурсивных макросов можно реализовать конечный автомат типа
<a href="http://esolangs.org/wiki/Bitwise_Cyclic_Tag">Bitwise Cyclic Tag</a>. Стоит
заметить, что мы не рекомендуем такой подход, а просто иллюстрируем возможности
макросов.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
macro_rules! bct {
    // cmd 0:  d ... =&gt; ...
    (0, $($ps:tt),* ; $_d:tt)
        =&gt; (bct!($($ps),*, 0 ; ));
    (0, $($ps:tt),* ; $_d:tt, $($ds:tt),*)
        =&gt; (bct!($($ps),*, 0 ; $($ds),*));

    // cmd 1p:  1 ... =&gt; 1 ... p
    (1, $p:tt, $($ps:tt),* ; 1)
        =&gt; (bct!($($ps),*, 1, $p ; 1, $p));
    (1, $p:tt, $($ps:tt),* ; 1, $($ds:tt),*)
        =&gt; (bct!($($ps),*, 1, $p ; 1, $($ds),*, $p));

    // cmd 1p:  0 ... =&gt; 0 ...
    (1, $p:tt, $($ps:tt),* ; $($ds:tt),*)
        =&gt; (bct!($($ps),*, 1, $p ; $($ds),*));

    // halt on empty data string
    ( $($ps:tt),* ; )
        =&gt; (());
}
#}</code></pre></pre>
<p>В качестве упражнения предлагаем читателю определить ещё один макрос, чтобы
уменьшить степень дублирования кода в определении выше.</p>
<h1><a class="header" href="#Распространённые-макросы" id="Распространённые-макросы">Распространённые макросы</a></h1>
<p>Вот некоторые распространённые макросы, которые вы увидите в коде на Rust.</p>
<h2><a class="header" href="#panic" id="panic">panic!</a></h2>
<p>Этот макрос вызывает панику текущего потока. Вы можете указать сообщение, с
которым поток завершится:</p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
panic!(&quot;о нет!&quot;);
#}</code></pre></pre>
<h2><a class="header" href="#vec" id="vec">vec!</a></h2>
<p>Макрос <code>vec!</code> используется по всей книге, поэтому вы наверняка уже видели его.
Он упрощает создание <code>Vec&lt;T&gt;</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![1, 2, 3, 4, 5];
#}</code></pre></pre>
<p>Он также позволяет вам создавать векторы с повторяющимися значениями. Например,
вот сто нолей:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let v = vec![0; 100];
#}</code></pre></pre>
<h2><a class="header" href="#assert-and-assert_eq" id="assert-and-assert_eq">assert! and assert_eq!</a></h2>
<p>Эти два макроса используются в тестах. <code>assert!</code> принимает логическое значение.
<code>assert_eq!</code> принимает два значения и проверяет, что они равны. <code>true</code>
засчитывается как успех, а <code>false</code> вызывает панику и проваливает тест. Вот так:</p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
// Работает!

assert!(true);
assert_eq!(5, 3 + 2);

// а это нет :(

assert!(5 &lt; 3);
assert_eq!(5, 3);
#}</code></pre></pre>
<h2><a class="header" href="#try" id="try">try!</a></h2>
<p><code>try!</code> используется для обработки ошибок. Он принимает нечто возвращающее
<code>Result&lt;T, E&gt;</code> и возвращает <code>T</code> если было возвращено <code>Ok&lt;T&gt;</code>; иначе он делает
возврат из функции со значением <code>Err(E)</code>. Вроде такого:</p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
use std::fs::File;

fn foo() -&gt; std::io::Result&lt;()&gt; {
    let f = try!(File::create(&quot;foo.txt&quot;));

    Ok(())
}
#}</code></pre></pre>
<p>Такой код читается легче, чем этот:</p>
<pre><pre class="playpen"><code class="language-rust no_run">
# #![allow(unused_variables)]
#fn main() {
use std::fs::File;

fn foo() -&gt; std::io::Result&lt;()&gt; {
    let f = File::create(&quot;foo.txt&quot;);

    let f = match f {
        Ok(t) =&gt; t,
        Err(e) =&gt; return Err(e),
    };

    Ok(())
}
#}</code></pre></pre>
<h2><a class="header" href="#unreachable" id="unreachable">unreachable!</a></h2>
<p>Этот макрос применяется, когда вы хотите пометить какой-то код, который никогда
не должен исполняться:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
if false {
    unreachable!();
}
#}</code></pre></pre>
<p>Иногда вам придётся определять ветви условных конструкций, которые точно никогда
не исполнятся. В таком случае, используйте этот макрос, чтобы в случае ошибки
программа запаниковала:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x: Option&lt;i32&gt; = None;

match x {
    Some(_) =&gt; unreachable!(),
    None =&gt; println!(&quot;Я знаю, что x — это None!&quot;),
}
#}</code></pre></pre>
<h2><a class="header" href="#unimplemented" id="unimplemented">unimplemented!</a></h2>
<p>Макрос <code>unimplemented!</code> можно использовать, когда вы хотите, чтобы ваш код
прошёл проверку типов, но пока не хотите реализовывать его настоящую логику.
Один из примеров — это реализация типажа с несколькими требуемыми методами.
Возможно, вы хотите разбираться с типажом постепенно — по одному методу за раз.
В таком случае, определите остальные методы как <code>unimplemented!</code>, пока не
захотите наконец реализовать их.</p>
<h1><a class="header" href="#Процедурные-макросы" id="Процедурные-макросы">Процедурные макросы</a></h1>
<p>Если система макросов не может сделать того, что вам нужно, вы можете написать
<a href="compiler-plugins.html">плагин к компилятору</a>. По сравнению с макросами, это гораздо
труднее, там ещё более нестабильные интерфейсы, и ещё сложнее найти ошибки. Зато
вы получаете гибкость — внутри плагина может исполняться произвольный код на
Rust. Иногда плагины расширения синтаксиса называются <em>процедурными макросами</em>.</p>
<p>% Сырые указатели</p>
<p>Стандартная библиотека Rust содержит ряд различных типов умных указателей, но
среди них есть два типа, которые экстра-специальные. Большая часть безопасности
в Rust является следствием проверок во время компиляции, но сырье указатели не
имеют конкретных гарантий и являются <a href="unsafe.html">небезопасными</a> для использования.</p>
<p><code>*const T</code> и <code>*mut T</code> в Rust называются «сырыми указателями» (raw pointers).
Иногда, при написании определенных видов библиотек, вам по какой-то причине
нужно обойти гарантии безопасности Rust. В этом случае, вы можете использовать
сырые указатели в реализации вашей библиотеки, вместе с тем предоставляя
безопасный интерфейс для пользователей. Например, <code>*</code> указатели допускают
псевдонимы, позволяя им быть использованными для записи типов с разделяемой
собственности, и даже поточно-безопасные типы памяти (<code>Rc&lt;T&gt;</code> и <code>Arc&lt;T&gt;</code> типы и
реализован полностью в Rust).</p>
<p>Вот некоторые факты о сырых указателях, которые следует помнить и которые
отличают их от других типов указателей. Они:</p>
<ul>
<li>не гарантируют, что они указывают на действительную область памяти, и не
гарантируют, что они является ненулевыми указателями (в отличие от <code>Box</code> и <code>&amp;</code>);</li>
<li>не имеют никакой автоматической очистки, в отличие от <code>Box</code>, и поэтому требуют
ручного управления ресурсами;</li>
<li>это простые структуры данных (plain-old-data), то есть они не перемещают право
собственности, опять же в отличие от <code>Box</code>, следовательно, компилятор Rust не
может защитить от ошибок, таких как использование освобождённой памяти (use-
after-free);</li>
<li>лишены сроков жизни в какой-либо форме, в отличие от <code>&amp;</code>, и поэтому компилятор
не может делать выводы о висячих указателях; и</li>
<li>не имеют никаких гарантий относительно псевдонимизации или изменяемости, за
исключением изменений, недопустимых непосредственно для <code>*const T</code>.</li>
</ul>
<h1><a class="header" href="#Основы" id="Основы">Основы</a></h1>
<p>Создание сырого указателя совершенно безопасно:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let raw = &amp;x as *const i32;

let mut y = 10;
let raw_mut = &amp;mut y as *mut i32;
#}</code></pre></pre>
<p>А вот его разыменование не является. Следующий код не будет работать:</p>
<pre><code class="language-rust ignore">let x = 5;
let raw = &amp;x as *const i32;

println!(&quot;raw points at {}&quot;, *raw);
</code></pre>
<p>Он выдает такую ошибку:</p>
<pre><code class="language-text">error: dereference of unsafe pointer requires unsafe function or block [E0133]
     println!(&quot;raw points at{}&quot;, *raw);
                                 ^~~~
</code></pre>
<p>Когда вы разыменовываете сырой указатель, вы принимаете на себя ответственность,
что он не указывает на что-то, что может быть некорректным. Таким образом, вы
должны использовать <code>unsafe</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let raw = &amp;x as *const i32;

let points_at = unsafe { *raw };

println!(&quot;raw points at {}&quot;, points_at);
#}</code></pre></pre>
<p>Для более подробной информации по операциям с сырыми указателями, обратитесь к
<a href="http://doc.rust-lang.org/std/primitive.pointer.html">API документации</a> о них.</p>
<h1><a class="header" href="#ffi" id="ffi">FFI</a></h1>
<p>Сырые указатели полезны для FFI: <code>*const T</code> и <code>*mut T</code> в Rust приблизительно
соответствуют <code>const T*</code> и <code>T*</code> в C. Для более подробной информации об этом
обратитесь к главе <a href="ffi.html">FFI</a>.</p>
<h1><a class="header" href="#Ссылки-и-сырые-указатели" id="Ссылки-и-сырые-указатели">Ссылки и сырые указатели</a></h1>
<p>Во время выполнения и сырой указатель, <code>*</code>, и ссылка, указывающая на тот же
кусок данных, имеют одинаковое представление. По факту, ссылка <code>&amp;T</code> будет неявно
приведена к сырому указателю <code>*const T</code> в безопасном коде, аналогично и для
вариантов <code>mut</code> (оба приведения могут быть выполнены явно, с помощью,
соответственно, <code>value as *const T</code> и <code>value as *mut T</code>).</p>
<p>Переход в обратном направлении, от <code>*const</code> к ссылке <code>&amp;</code>, не является безопасным.
Ссылка <code>&amp;T</code> всегда валидна, и поэтому, как минимум, сырой указатель <code>*const T</code>
должен указывать на правильный экземпляр типа <code>T</code>. Кроме того, в результате
указатель должен удовлетворять правилам псевдонимизации и изменяемости ссылок.
Компилятор предполагает, что эти свойства верны для любых ссылок, независимо от
того, как они были созданы, и поэтому любое преобразование из сырых указателей
равносильно утверждению, что они соответствуют этим правилам. Программист
<em>должен</em> гарантировать это.</p>
<p>Рекомендуемым методом преобразования является</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let i: u32 = 1;

// explicit cast
let p_imm: *const u32 = &amp;i as *const u32;
let mut m: u32 = 2;

// implicit coercion
let p_mut: *mut u32 = &amp;mut m;

unsafe {
    let ref_imm: &amp;u32 = &amp;*p_imm;
    let ref_mut: &amp;mut u32 = &amp;mut *p_mut;
}
#}</code></pre></pre>
<p>Разыменование с помощью конструкции <code>&amp;*x</code> является более предпочтительным, чем с
использованием <code>transmute</code>. Последнее является гораздо более мощным
инструментом, чем необходимо, а более ограниченное поведение сложнее
использовать неправильно. Например, она требует, чтобы <code>x</code> представляет собой
указатель (в отличие от <code>transmute</code>).</p>
<p>% Небезопасный код</p>
<p>Главная сила Rust — в мощных статических гарантиях правильности поведения
программы во время исполнения. Но проверки безопасности очень осторожны: на
самом деле, существуют безопасные программы, правильность которых компилятор
доказать не в силах. Чтобы писать такие программы, нужен способ немного ослабить
ограничения. Для этого в Rust есть ключевое слово <code>unsafe</code>. Код, использующий
<code>unsafe</code>, ограничен меньше, чем обычный код.</p>
<p>Давайте рассмотрим синтаксис, а затем поговорим о семантике. <code>unsafe</code>
используется в четырёх контекстах. Первый — это объявление того, что функция
небезопасна:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
unsafe fn beregis_avtomobilya() {
    // страшные вещи
}
#}</code></pre></pre>
<p>Например, все функции, вызываемые через <a href="ffi.html">FFI</a>, должны быть помечены как
небезопасные. Другое использование <code>unsafe</code> — это отметка небезопасного блока:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
unsafe {
    // страшные вещи
}
#}</code></pre></pre>
<p>Третье — небезопасные типажи:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
unsafe trait Scary { }
#}</code></pre></pre>
<p>И четвёртое — реализация (<code>impl</code>) таких типажей:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# unsafe trait Scary { }
unsafe impl Scary for i32 {}
#}</code></pre></pre>
<p>Важно явно выделить код, ошибки в котором могут вызвать большие проблемы. Если
программа на Rust падает с &quot;segmentation fault&quot;, можете быть уверены —
проблема в участке, помеченном как небезопасный.</p>
<h1><a class="header" href="#Что-значит-безопасный" id="Что-значит-безопасный">Что значит &quot;безопасный&quot;?</a></h1>
<p>В контексте Rust &quot;безопасный&quot; значит &quot;не делает ничего небезопасного&quot;. Также
важно знать, что некоторое поведение скорее всего нежелательно, но явно
<em>не</em> считается небезопасным:</p>
<ul>
<li>Deadlock'и</li>
<li>Утечка памяти или других ресурсов</li>
<li>Выход без вызова деструкторов</li>
<li>Целочисленное переполнение</li>
</ul>
<p>Rust не может предотвратить все виды проблем в программах. Код с ошибками может
и будет написан на Rust. Вышеперечисленные вещи неприятны, но они не считаются
именно что небезопасными.</p>
<p>В дополнение к этому, ниже представлен список неопределённого поведения
(undefined behavior) в Rust. Избегайте этих вещей, даже когда пишете
небезопасный код:</p>
<ul>
<li>Гонка данных</li>
<li>Разыменование нулевого или висячего указателя</li>
<li>Чтение <a href="http://llvm.org/docs/LangRef.html#undefined-values">неинициализированной</a> памяти</li>
<li>Нарушение <a href="http://llvm.org/docs/LangRef.html#pointer-aliasing-rules">правил о совпадении указателей</a> с помощью сырых
указателей</li>
<li><code>&amp;mut T</code> и <code>&amp;T</code> следуют модели LLVM <a href="http://llvm.org/docs/LangRef.html#noalias">noalias</a>, кроме случаев, когда
<code>&amp;T</code> содержит <code>UnsafeCell&lt;U&gt;</code>. Небезопасный код не должен нарушать эти
гарантии совпадения указателей.</li>
<li>Изменение неизменяемого значения или ссылки без использования <code>UnsafeCell&lt;U&gt;</code></li>
<li>Получение неопределённого поведения с помощью intrinsic-операций компилятора:
<ul>
<li>Индексация вне границ объекта с помощью <code>std::ptr::offset</code> (<code>offset</code>
intrinsic), кроме разрешённого случая &quot;один байт за концом объекта&quot;.</li>
<li>Использование <code>std::ptr::copy_nonoverlapping_memory</code> (intrinsic-операции
<code>memcpy32</code>/<code>memcpy64</code>) с пересекающимися буферами</li>
</ul>
</li>
<li>Неправильные значения примитивных типов, даже в скрытых полях:
<ul>
<li>Нулевые или висячие ссылки или упаковки (boxes)</li>
<li>Любое значение логического типа, кроме <code>false</code> (0) или <code>true</code> (1)</li>
<li>Вариант перечисления, не включённый в его определение</li>
<li>Суррогатное значение <code>char</code> или значение <code>char</code>, превыщающее <code>char::MAX</code></li>
<li>Последовательности байт, не являющиеся UTF-8, в <code>str</code></li>
</ul>
</li>
<li>Размотка стека в код на Rust из чужого кода (через границы FFI), или размотка
из кода на Rust в чужой код</li>
</ul>
<h1><a class="header" href="#Сверхспособности-небезопасного-кода" id="Сверхспособности-небезопасного-кода">Сверхспособности небезопасного кода</a></h1>
<p>В небезопасном блоке или функции, Rust разрешает три ситуации, которые обычно
запрещены. Всего три. Вот они:</p>
<ol>
<li>Доступ к или изменение <a href="const-and-static.html#static">статической изменяемой переменной</a>.</li>
<li>Разыменование сырого указателя.</li>
<li>Вызов небезопасных функций. Это самая мощная возможность.</li>
</ol>
<p>Это всё. Важно отметить, что <code>unsafe</code>, например, не &quot;выключает проверку
заимствования&quot;. Объявление какого-то кода небезопасным не изменяет его
семантику; небезопасность не означает принятие компилятором любого кода. Но она
позволяет писать вещи, которые <em>нарушают</em> некоторые из правил.</p>
<p>Вы также встретите ключевое слово <code>unsafe</code>, когда будете реализовывать интерфейс
к чужому коду не на Rust. Идиоматичным считается написание безопасных обёрток
вокруг небезопасных библиотек.</p>
<p>Давайте поговорим о трёх упомянутых возможностях, доступных в небезопасном коде.</p>
<h2><a class="header" href="#Доступ-или-изменение-static-mut" id="Доступ-или-изменение-static-mut">Доступ или изменение <code>static mut</code></a></h2>
<p>Rust позволяет пользоваться глобальным изменяемым состоянием с помощью <code>static mut</code>. Это может вызвать гонку по данным, и в сущности небезопасно. Подробнее
смотрите раздел о <a href="const-and-static.html#static">static</a>.</p>
<h2><a class="header" href="#Разыменование-сырого-указателя" id="Разыменование-сырого-указателя">Разыменование сырого указателя</a></h2>
<p>Сырые указатели поддерживают произвольную арифметику указателей, и могут вызвать
целый ряд проблем безопасности памяти и безопасности в целом. В каком-то смысле,
возможность разыменовать произвольный указатель — одна из самых опасных вещей,
которые вы можете сделать. Подробнее смотрите раздел о
<a href="raw-pointers.html">сырых указателях</a>.</p>
<h2><a class="header" href="#Вызов-небезопасных-функций" id="Вызов-небезопасных-функций">Вызов небезопасных функций</a></h2>
<p>Эта возможность затрагивает то, откуда можно делать вызов небезопасного кода:
небезопасные функции могут вызываться только из небезопасных блоков.</p>
<p>Мощь и полезность этой возможности сложно переоценить. Rust предоставляет
некоторые <a href="intrinsics.html">intrinsic-операции</a> компилятора в виде небезопасных
функций, а некоторые небезопасные функции обходят проверки безопасности для
достижения большей скорости исполнения.</p>
<p>В заключение, повторимся: хотя вы и <em>можете</em> делать в небезопасных участках
почти что угодно, это не значит, что стоит это делать. Компилятор будет
предполагать выполнение оговоренных инвариантов, так что будьте осторожны!</p>
<p>% Эффективное использование Rust</p>
<p>Итак, вы узнали, как писать код на Rust. Но есть разница между написанием
<em>какого-то</em> кода на Rust и написанием <em>хорошего</em> кода на Rust.</p>
<p>Этот раздел состоит из относительно самостоятельных уроков, которые показывают,
как повысить уровень вашего кода на Rust. В нем представлены общие шаблоны и
стандартные функции библиотеки. Главы в этом разделе могут быть прочитаны в
любом порядке по вашему выбору.</p>
<p>% Стек и куча</p>
<p>Как любой системный язык программирования, Rust работает на низком уровне. Если
вы пришли из языка высокого уровня, то вам могут быть незнакомы некоторые
аспекты системного программирования. Наиболее важными из них являются те,
которые касаются работы с памятью в стеке и в куче. Если вы уже знакомы с тем,
как в C-подобных языках используется выделение памяти в стеке, то эта глава
освежит ваши знания. Если же вы еще не знакомы с этим, то в общих чертах узнаете
об этом понятии, но с акцентом на Rust.</p>
<h1><a class="header" href="#Управление-памятью" id="Управление-памятью">Управление памятью</a></h1>
<p>Эти два термина касаются управления памятью. Стек и куча — это абстракции,
которые помогают вам определить, когда требуется выделение и освобождение
памяти.</p>
<p>Вот высокоуровневое сравнение.</p>
<p>Стек работает очень быстро; в Rust память
выделяется в стеке по умолчанию. Выделение памяти в стеке является локальным по
отношению к вызову функции, и имеет ограниченный размер. Куча, с другой стороны,
работает медленнее, а выделение памяти в куче осуществляется в программе
явно. Но такая память имеет теоретически неограниченный размер, и доступна
глобально.</p>
<h1><a class="header" href="#Стек" id="Стек">Стек</a></h1>
<p>Давайте поговорим о следующей программе на Rust:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 42;
}
</code></pre></pre>
<p>Эта программа имеет одно связанное имя, <code>x</code>. Память для него необходимо
где-то выделить. Rust по умолчанию «выделяет память в стеке», что означает, что
переменные «помещаются в стеке». Что это значит?</p>
<p>Когда функция вызывается, то выделяется некоторый объем памяти для всех её
локальных переменных и некоторой дополнительной информации. Это называется
«стековый кадр» (stack frame). В этом руководстве мы будем игнорировать эту
дополнительную информацию, и будем рассматривать лишь локальные переменные,
которые мы определяем. Таким образом, в этом случае, когда выполняется
<code>main()</code>, мы выделяем одно 32-битное целое число в нашем кадре стека. Как вы
можете видеть, это происходит автоматически — мы не должны писать какой-либо
специальный код на Rust для этого.</p>
<p>Когда функция завершается, её стековый кадр освобождается. Это происходит
автоматически — для этого нам не надо предпринимать никаких действий.</p>
<p>Вот и все, что касается этой простой программы. Главное, что здесь нужно
понять — это что выделение в стеке очень, очень быстро. Поскольку все локальные
переменные известны нам заранее, мы можем выделить память для них всех сразу. И
так как они, как правило, одновременно выходят из области видимости, мы можем
очень быстро освободить выделенную память.</p>
<p>Недостатком является то, что мы не можем хранить необходимые значения дольше,
чем в рамках одной функции.</p>
<p>А ещё мы не говорили о том, что же означает название «стек». Для этого мы должны
привести немного более сложный пример:</p>
<pre><pre class="playpen"><code class="language-rust">fn foo() {
    let y = 5;
    let z = 100;
}

fn main() {
    let x = 42;

    foo();
}
</code></pre></pre>
<p>Эта программа имеет в общей сложности три переменные: две в <code>foo()</code> и одну в
<code>main()</code>. Так же как и раньше, когда вызывается <code>main()</code>, в её стековом кадре
выделяется одно целое число. Но, прежде чем мы сможем показать, что происходит,
когда вызывается <code>foo()</code>, мы должны визуализировать то, что происходит с
памятью. Ваша операционная система представляет отображение памяти для вашей
программы. Это довольно просто: огромный список адресов, от 0 до большого числа,
представляющего количество оперативной памяти у вашего компьютера. Например,
если у вас есть гигабайт оперативной памяти, то ваши адреса будут от <code>0</code> до
<code>1 073 741 823</code>. Это число равно 2<sup>30</sup>, количеству байтов в
гигабайте.</p>
<p>Эта память вроде гигантского массива: адреса начинаются с нуля и продолжаются до
конечного числа. Так вот схема нашего первого кадра стека:</p>
<table><thead><tr><th>Адрес</th><th>Имя</th><th>Значение</th></tr></thead><tbody>
<tr><td>0</td><td>x</td><td>42</td></tr>
</tbody></table>
<p>У нас есть переменная <code>x</code>, расположенная по адресу <code>0</code>, имеющая значение <code>42</code>.</p>
<p>Когда вызывается <code>foo()</code>, выделяется новый стековый кадр:</p>
<table><thead><tr><th>Адрес</th><th>Имя</th><th>Значение</th></tr></thead><tbody>
<tr><td>2</td><td>z</td><td>100</td></tr>
<tr><td>1</td><td>y</td><td>5</td></tr>
<tr><td>0</td><td>x</td><td>42</td></tr>
</tbody></table>
<p>Поскольку <code>0</code> было задействовано в первом кадре, для кадра <code>foo()</code> используются
<code>1</code> и <code>2</code>. При дальнейших вызовах функций стек будет расти вверх.</p>
<p>Здесь необходимо принять к сведению некоторые важные замечания. Адреса 0, 1 и 2
приведены исключительно в иллюстративных целях, и не имеют никакого отношения к
фактическим адресам, которые компьютер будет использовать. В частности, набор
адресов в действительности включает выравнивающие разделители, состоящие из
некоторого числа байтов, которые отделяют каждый из адресов. Размер этого
разделителя может даже превышать размер хранящегося значения.</p>
<p>После того, как <code>foo()</code> завершается, её кадр будет освобожден:</p>
<table><thead><tr><th>Адрес</th><th>Имя</th><th>Значение</th></tr></thead><tbody>
<tr><td>0</td><td>x</td><td>42</td></tr>
</tbody></table>
<p>А потом, после <code>main()</code>, даже это последнее значение уходит. Легко!</p>
<p>Это называется «стек» (по-русски, стопка), потому что он работает как стопка
тарелок: первая тарелка, которую вы положили, будет последней тарелкой,
которую вы возьмете обратно. По этой причине стек иногда называют очередью
«последним пришел, первым вышел». Последнее значение, которое вы положили в
стек, будет первым, которое вы получите из него.</p>
<p>Давайте попробуем трёхуровневый пример:</p>
<pre><pre class="playpen"><code class="language-rust">fn bar() {
    let i = 6;
}

fn foo() {
    let a = 5;
    let b = 100;
    let c = 1;

    bar();
}

fn main() {
    let x = 42;

    foo();
}
</code></pre></pre>
<p>Сначала вызывается <code>main()</code>:</p>
<table><thead><tr><th>Адрес</th><th>Имя</th><th>Значение</th></tr></thead><tbody>
<tr><td>0</td><td>x</td><td>42</td></tr>
</tbody></table>
<p>Затем из <code>main()</code> вызывается <code>foo()</code>:</p>
<table><thead><tr><th>Адрес</th><th>Имя</th><th>Значение</th></tr></thead><tbody>
<tr><td>3</td><td>c</td><td>1</td></tr>
<tr><td>2</td><td>b</td><td>100</td></tr>
<tr><td>1</td><td>a</td><td>5</td></tr>
<tr><td>0</td><td>x</td><td>42</td></tr>
</tbody></table>
<p>И затем из <code>foo()</code> вызывается <code>bar()</code>:</p>
<table><thead><tr><th>Адрес</th><th>Имя</th><th>Значение</th></tr></thead><tbody>
<tr><td>4</td><td>i</td><td>6</td></tr>
<tr><td>3</td><td>c</td><td>1</td></tr>
<tr><td>2</td><td>b</td><td>100</td></tr>
<tr><td>1</td><td>a</td><td>5</td></tr>
<tr><td>0</td><td>x</td><td>42</td></tr>
</tbody></table>
<p>Вот что мы имели ввиду раньше, говоря, что наш стек растет вверх.</p>
<p>После того, как <code>bar()</code> завершается, её кадр будет освобожден, оставляя только
<code>foo()</code> и <code>main()</code>:</p>
<table><thead><tr><th>Адрес</th><th>Имя</th><th>Значение</th></tr></thead><tbody>
<tr><td>3</td><td>c</td><td>1</td></tr>
<tr><td>2</td><td>b</td><td>100</td></tr>
<tr><td>1</td><td>a</td><td>5</td></tr>
<tr><td>0</td><td>x</td><td>42</td></tr>
</tbody></table>
<p>А затем завершается <code>foo()</code>, оставляя только <code>main()</code>:</p>
<table><thead><tr><th>Адрес</th><th>Имя</th><th>Значение</th></tr></thead><tbody>
<tr><td>0</td><td>x</td><td>42</td></tr>
</tbody></table>
<p>И вот мы закончили. Уловили суть? Это как стопка тарелок: вы кладете наверх, и
берёте сверху.</p>
<h1><a class="header" href="#Куча" id="Куча">Куча</a></h1>
<p>Такой способ выделения памяти работает очень хорошо, но он может быть
использован не всегда. Иногда вам необходимо передать некоторую память между
различными функциями или сохранить её валидность после окончания выполнения
функции. Для этого мы можем использовать кучу.</p>
<p>В Rust, вы можете выделить память в куче с помощью упаковки, т.е.
<a href="http://doc.rust-lang.org/std/boxed/index.html">типа <code>Box&lt;T&gt;</code></a>. (Примечание переводчика: мы называем <code>Box&lt;T&gt;</code> упаковкой,
потому что <code>T</code> как бы «упакован» в <code>Box</code>: упаковка знает размер того, что лежит
внутри. Эта информация закодирована в типе <code>T</code>, поэтому во время исполнения, для
размерных типов, это просто указатель.) Вот пример:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = Box::new(5);
    let y = 42;
}
</code></pre></pre>
<p>Вот что происходит с памятью, когда вызывается <code>main()</code>:</p>
<table><thead><tr><th>Адрес</th><th>Имя</th><th>Значение</th></tr></thead><tbody>
<tr><td>1</td><td>y</td><td>42</td></tr>
<tr><td>0</td><td>x</td><td>??????</td></tr>
</tbody></table>
<p>Мы выделяем место для двух переменных в стеке. <code>y</code> представляет собой <code>42</code>,
тут всё как обычно. Но что насчёт <code>x</code>? Наш <code>x</code> представляет собой <code>Box&lt;i32&gt;</code>,
а упаковка выделяет память в куче. Фактическое значение упаковки — структура,
которая хранит указатель на «кучу». Когда начинает выполняться функция,
осуществляется вызов <code>Box::new()</code>, который выделяет некоторый объем памяти в
куче, и кладет туда <code>5</code>. Теперь память выглядит следующим образом:</p>
<table><thead><tr><th>Адрес</th><th>Имя</th><th>Значение</th></tr></thead><tbody>
<tr><td>(2<sup>30</sup>) - 1</td><td></td><td>5</td></tr>
<tr><td>...</td><td>...</td><td>...</td></tr>
<tr><td>1</td><td>y</td><td>42</td></tr>
<tr><td>0</td><td>x</td><td>→ (2<sup>30</sup>) - 1</td></tr>
</tbody></table>
<p>В нашем гипотетическом компьютере c 1Гб оперативной памяти имеется
2<sup>30</sup> адресов. А так как наш стек растет от нуля, то проще всего
выделить память с другого конца. Таким образом, наше первое значение находится
на самом высоком месте в памяти. Поскольку структура <code>x</code> хранит <a href="raw-pointers.html">сырой
указатель (raw pointer)</a> на адрес, который мы выделили в куче, то
значение <code>x</code> равно (2<sup>30</sup>) - 1 — это то самое местоположение в памяти.</p>
<p>Мы не слишком много говорили о том, что на самом деле означает «выделить» и
«освободить память» в этом контексте. Чрезмерное углубление в детали по этому
вопросу выходит за рамки данного руководства, но важно отметить, что куча — это
не просто стек, который растет с противоположного конца. Как мы увидим в
дальнейших примерах в этой книге, память из кучи может быть выделена и
освобождена в любом порядке, что в конечном итоге может привести к «дыркам». Вот
схема размещения памяти программы, проработавшей в течение некоторого времени:</p>
<table><thead><tr><th>Адрес</th><th>Имя</th><th>Значение</th></tr></thead><tbody>
<tr><td>(2<sup>30</sup>) - 1</td><td></td><td>5</td></tr>
<tr><td>(2<sup>30</sup>) - 2</td><td></td><td></td></tr>
<tr><td>(2<sup>30</sup>) - 3</td><td></td><td></td></tr>
<tr><td>(2<sup>30</sup>) - 4</td><td></td><td>42</td></tr>
<tr><td>...</td><td>...</td><td>...</td></tr>
<tr><td>3</td><td>y</td><td>→ (2<sup>30</sup>) - 4</td></tr>
<tr><td>2</td><td>y</td><td>42</td></tr>
<tr><td>1</td><td>y</td><td>42</td></tr>
<tr><td>0</td><td>x</td><td>→ (2<sup>30</sup>) - 1</td></tr>
</tbody></table>
<p>В этом примере мы выделили четыре элемента в куче, но освободили лишь два из
них. Отсюда разрыв между (2<sup>30</sup>) - 1 и (2<sup>30</sup>) - 4, который в
настоящее время не используется. Конкретные детали того, как и почему это
происходит, зависят от того, какую стратегию вы используете для управления
кучей. Различные программы могут использовать различные «распределители памяти»,
которые представляют собой библиотеки, которые управляют памятью за вас.
Программы на Rust используют для этого <a href="http://www.canonware.com/jemalloc/">jemalloc</a>.</p>
<p>Ладно, вернемся к нашему примеру. Так как эта память расположена в куче, то она
может оставаться валидной дольше, чем функция, которая выделяет упаковку. В
данном случае, однако, это не так.<sup class="footnote-reference"><a href="#moving">1</a></sup> Когда функция завершается, мы должны
освободить кадр стека для <code>main()</code>. Хотя у <code>Box&lt;T&gt;</code> для этого есть свой трюк:
<a href="drop.html">Drop</a>. Реализация <code>Drop</code> для <code>Box</code> освобождает память, которая была
выделена при создании. Отлично! Поэтому, когда <code>x</code> уходит, сначала освобождается
память, выделенная в куче:</p>
<table><thead><tr><th>Адрес</th><th>Имя</th><th>Значение</th></tr></thead><tbody>
<tr><td>1</td><td>y</td><td>42</td></tr>
<tr><td>0</td><td>x</td><td>??????</td></tr>
</tbody></table>
<div class="footnote-definition" id="moving"><sup class="footnote-definition-label">1</sup>
<p>Мы можем продлить время жизни памяти путем передачи права
собственности, что иногда называют «перемещение из упаковки» («moving
out of the box»). Более сложные примеры будут рассмотрены позже.</p>
</div>
<p>А потом кадр стека уходит, освобождая всю нашу память.</p>
<h1><a class="header" href="#Аргументы-и-заимствование" id="Аргументы-и-заимствование">Аргументы и заимствование</a></h1>
<p>У нас есть некоторые простые примеры со стеком и кучей, но что насчёт аргументов
функции и заимствования? Вот небольшая программа на Rust:</p>
<pre><pre class="playpen"><code class="language-rust">fn foo(i: &amp;i32) {
    let z = 42;
}

fn main() {
    let x = 5;
    let y = &amp;x;

    foo(y);
}
</code></pre></pre>
<p>Когда мы входим в <code>main()</code>, память выглядит следующим образом:</p>
<table><thead><tr><th>Адрес</th><th>Имя</th><th>Значение</th></tr></thead><tbody>
<tr><td>1</td><td>y</td><td>→ 0</td></tr>
<tr><td>0</td><td>x</td><td>5</td></tr>
</tbody></table>
<p>Значением <code>x</code> является <code>5</code>, а <code>y</code> представляет собой ссылку на <code>x</code>. То есть, ее
значением является адрес памяти, по которому расположен <code>x</code>. В данном случае это
<code>0</code>.</p>
<p>А что насчёт случая, когда мы вызываем <code>foo()</code>, передавая <code>y</code> в качестве
аргумента?</p>
<table><thead><tr><th>Адрес</th><th>Имя</th><th>Значение</th></tr></thead><tbody>
<tr><td>3</td><td>z</td><td>42</td></tr>
<tr><td>2</td><td>i</td><td>→ 0</td></tr>
<tr><td>1</td><td>y</td><td>→ 0</td></tr>
<tr><td>0</td><td>x</td><td>5</td></tr>
</tbody></table>
<p>Кадры стека используются не только для локальных имён, но также и для
аргументов. Таким образом, в этом случае, наш кадр должен содержать как <code>i</code>, наш
аргумент, так и <code>z</code>, наше локальное имя. <code>i</code> — это копия аргумента <code>y</code>.
Соответственно, значением <code>i</code>, как и значением <code>y</code>, является <code>0</code>.</p>
<p>Это одна из причин, почему заимствование переменной не освобождает какую-либо
память: значением ссылки является просто указатель на область памяти. Если мы
освободим находящуюся по этому указателю память, то это может привести к ошибкам
в дальнейшей работе.</p>
<h1><a class="header" href="#Сложный-пример" id="Сложный-пример">Сложный пример</a></h1>
<p>Хорошо, давайте рассмотрим следующую, более сложную программу шаг за шагом:</p>
<pre><pre class="playpen"><code class="language-rust">fn foo(x: &amp;i32) {
    let y = 10;
    let z = &amp;y;

    baz(z);
    bar(x, z);
}

fn bar(a: &amp;i32, b: &amp;i32) {
    let c = 5;
    let d = Box::new(5);
    let e = &amp;d;

    baz(e);
}

fn baz(f: &amp;i32) {
    let g = 100;
}

fn main() {
    let h = 3;
    let i = Box::new(20);
    let j = &amp;h;

    foo(j);
}
</code></pre></pre>
<p>Сначала мы вызываем <code>main()</code>:</p>
<table><thead><tr><th>Адрес</th><th>Имя</th><th>Значение</th></tr></thead><tbody>
<tr><td>(2<sup>30</sup>) - 1</td><td></td><td>20</td></tr>
<tr><td>...</td><td>...</td><td>...</td></tr>
<tr><td>2</td><td>j</td><td>→ 0</td></tr>
<tr><td>1</td><td>i</td><td>→ (2<sup>30</sup>) - 1</td></tr>
<tr><td>0</td><td>h</td><td>3</td></tr>
</tbody></table>
<p>Мы выделяем память для <code>j</code>, <code>i</code>, и <code>h</code>. <code>i</code> выделена в куче и поэтому содержит
указатель на значение в куче.</p>
<p>Далее, в конце вызова <code>main()</code>, вызывается <code>foo()</code>:</p>
<table><thead><tr><th>Адрес</th><th>Имя</th><th>Значение</th></tr></thead><tbody>
<tr><td>(2<sup>30</sup>) - 1</td><td></td><td>20</td></tr>
<tr><td>...</td><td>...</td><td>...</td></tr>
<tr><td>5</td><td>z</td><td>→ 4</td></tr>
<tr><td>4</td><td>y</td><td>10</td></tr>
<tr><td>3</td><td>x</td><td>→ 0</td></tr>
<tr><td>2</td><td>j</td><td>→ 0</td></tr>
<tr><td>1</td><td>i</td><td>→ (2<sup>30</sup>) - 1</td></tr>
<tr><td>0</td><td>h</td><td>3</td></tr>
</tbody></table>
<p>Пространство выделяется для <code>x</code>, <code>y</code> и <code>z</code>. Аргумент <code>x</code> имеет такое же
значение, как и <code>j</code>, так как мы передали <code>j</code> в качестве аргумента. Это указатель
на адрес <code>0</code>, так как <code>j</code> указывает на <code>h</code>.</p>
<p>Далее, <code>foo()</code> вызывает <code>baz()</code>, передавая <code>z</code>:</p>
<table><thead><tr><th>Адрес</th><th>Имя</th><th>Значение</th></tr></thead><tbody>
<tr><td>(2<sup>30</sup>) - 1</td><td></td><td>20</td></tr>
<tr><td>...</td><td>...</td><td>...</td></tr>
<tr><td>7</td><td>g</td><td>100</td></tr>
<tr><td>6</td><td>f</td><td>→ 4</td></tr>
<tr><td>5</td><td>z</td><td>→ 4</td></tr>
<tr><td>4</td><td>y</td><td>10</td></tr>
<tr><td>3</td><td>x</td><td>→ 0</td></tr>
<tr><td>2</td><td>j</td><td>→ 0</td></tr>
<tr><td>1</td><td>i</td><td>→ (2<sup>30</sup>) - 1</td></tr>
<tr><td>0</td><td>h</td><td>3</td></tr>
</tbody></table>
<p>Мы выделили память для <code>f</code> и <code>g</code>. <code>baz()</code> очень короткая, и когда она
завершается, мы избавляемся от её кадра стека:</p>
<table><thead><tr><th>Адрес</th><th>Имя</th><th>Значение</th></tr></thead><tbody>
<tr><td>(2<sup>30</sup>) - 1</td><td></td><td>20</td></tr>
<tr><td>...</td><td>...</td><td>...</td></tr>
<tr><td>5</td><td>z</td><td>→ 4</td></tr>
<tr><td>4</td><td>y</td><td>10</td></tr>
<tr><td>3</td><td>x</td><td>→ 0</td></tr>
<tr><td>2</td><td>j</td><td>→ 0</td></tr>
<tr><td>1</td><td>i</td><td>→ (2<sup>30</sup>) - 1</td></tr>
<tr><td>0</td><td>h</td><td>3</td></tr>
</tbody></table>
<p>Далее <code>foo()</code> вызывает <code>bar()</code> с аргументами <code>x</code> и <code>z</code>:</p>
<table><thead><tr><th>Адрес</th><th>Имя</th><th>Значение</th></tr></thead><tbody>
<tr><td>(2<sup>30</sup>) - 1</td><td></td><td>20</td></tr>
<tr><td>(2<sup>30</sup>) - 2</td><td></td><td>5</td></tr>
<tr><td>...</td><td>...</td><td>...</td></tr>
<tr><td>10</td><td>e</td><td>→ 9</td></tr>
<tr><td>9</td><td>d</td><td>→ (2<sup>30</sup>) - 2</td></tr>
<tr><td>8</td><td>c</td><td>5</td></tr>
<tr><td>7</td><td>b</td><td>→ 4</td></tr>
<tr><td>6</td><td>a</td><td>→ 0</td></tr>
<tr><td>5</td><td>z</td><td>→ 4</td></tr>
<tr><td>4</td><td>y</td><td>10</td></tr>
<tr><td>3</td><td>x</td><td>→ 0</td></tr>
<tr><td>2</td><td>j</td><td>→ 0</td></tr>
<tr><td>1</td><td>i</td><td>→ (2<sup>30</sup>) - 1</td></tr>
<tr><td>0</td><td>h</td><td>3</td></tr>
</tbody></table>
<p>Тут мы выделяем другое значение в куче, и поэтому мы вычитаем единицу из
(2<sup>30</sup>) - 1. Это выражение написать легче, чем <code>1 073 741 822</code>.
В любом случае, переменные создаются, как обычно.</p>
<p>В конце <code>bar()</code> вызывает <code>baz()</code>:</p>
<table><thead><tr><th>Адрес</th><th>Имя</th><th>Значение</th></tr></thead><tbody>
<tr><td>(2<sup>30</sup>) - 1</td><td></td><td>20</td></tr>
<tr><td>(2<sup>30</sup>) - 2</td><td></td><td>5</td></tr>
<tr><td>...</td><td>...</td><td>...</td></tr>
<tr><td>12</td><td>g</td><td>100</td></tr>
<tr><td>11</td><td>f</td><td>→ 9</td></tr>
<tr><td>10</td><td>e</td><td>→ 9</td></tr>
<tr><td>9</td><td>d</td><td>→ (2<sup>30</sup>) - 2</td></tr>
<tr><td>8</td><td>c</td><td>5</td></tr>
<tr><td>7</td><td>b</td><td>→ 4</td></tr>
<tr><td>6</td><td>a</td><td>→ 0</td></tr>
<tr><td>5</td><td>z</td><td>→ 4</td></tr>
<tr><td>4</td><td>y</td><td>10</td></tr>
<tr><td>3</td><td>x</td><td>→ 0</td></tr>
<tr><td>2</td><td>j</td><td>→ 0</td></tr>
<tr><td>1</td><td>i</td><td>→ (2<sup>30</sup>) - 1</td></tr>
<tr><td>0</td><td>h</td><td>3</td></tr>
</tbody></table>
<p>Сейчас мы на наибольшей глубине! Поздравляем с достижением данной точки.</p>
<p>После завершения <code>baz()</code>, мы избавляемся от <code>f</code> и <code>g</code>:</p>
<table><thead><tr><th>Адрес</th><th>Имя</th><th>Значение</th></tr></thead><tbody>
<tr><td>(2<sup>30</sup>) - 1</td><td></td><td>20</td></tr>
<tr><td>(2<sup>30</sup>) - 2</td><td></td><td>5</td></tr>
<tr><td>...</td><td>...</td><td>...</td></tr>
<tr><td>10</td><td>e</td><td>→ 9</td></tr>
<tr><td>9</td><td>d</td><td>→ (2<sup>30</sup>) - 2</td></tr>
<tr><td>8</td><td>c</td><td>5</td></tr>
<tr><td>7</td><td>b</td><td>→ 4</td></tr>
<tr><td>6</td><td>a</td><td>→ 0</td></tr>
<tr><td>5</td><td>z</td><td>→ 4</td></tr>
<tr><td>4</td><td>y</td><td>10</td></tr>
<tr><td>3</td><td>x</td><td>→ 0</td></tr>
<tr><td>2</td><td>j</td><td>→ 0</td></tr>
<tr><td>1</td><td>i</td><td>→ (2<sup>30</sup>) - 1</td></tr>
<tr><td>0</td><td>h</td><td>3</td></tr>
</tbody></table>
<p>Далее мы выполняем возврат из <code>bar()</code>. В этом случае <code>d</code> представляет собой
<code>Box&lt;T&gt;</code>, поэтому он также освобождает и то, на что он указывает:
(2<sup>30</sup>) - 2.</p>
<table><thead><tr><th>Адрес</th><th>Имя</th><th>Значение</th></tr></thead><tbody>
<tr><td>(2<sup>30</sup>) - 1</td><td></td><td>20</td></tr>
<tr><td>...</td><td>...</td><td>...</td></tr>
<tr><td>5</td><td>z</td><td>→ 4</td></tr>
<tr><td>4</td><td>y</td><td>10</td></tr>
<tr><td>3</td><td>x</td><td>→ 0</td></tr>
<tr><td>2</td><td>j</td><td>→ 0</td></tr>
<tr><td>1</td><td>i</td><td>→ (2<sup>30</sup>) - 1</td></tr>
<tr><td>0</td><td>h</td><td>3</td></tr>
</tbody></table>
<p>И после этого происходит возврат из <code>foo()</code>:</p>
<table><thead><tr><th>Адрес</th><th>Имя</th><th>Значение</th></tr></thead><tbody>
<tr><td>(2<sup>30</sup>) - 1</td><td></td><td>20</td></tr>
<tr><td>...</td><td>...</td><td>...</td></tr>
<tr><td>2</td><td>j</td><td>→ 0</td></tr>
<tr><td>1</td><td>i</td><td>→ (2<sup>30</sup>) - 1</td></tr>
<tr><td>0</td><td>h</td><td>3</td></tr>
</tbody></table>
<p>И вот, наконец, <code>main()</code>, которая очищает все остальное. Когда освобождается <code>i</code>
(<code>Drop</code>), будет также очищен и конец кучи.</p>
<h1><a class="header" href="#А-что-делают-другие-языки" id="А-что-делают-другие-языки">А что делают другие языки?</a></h1>
<p>Большинство языков со сборщиком мусора по умолчанию выделяет память из кучи. Это
означает, что каждое значение будет упаковано. Есть ряд причин, почему делается
именно так, но они выходят за рамки данного руководства. Есть несколько
возможных оптимизаций, которые, правда, не достигают своей цели во всех случаях.
Вместо того чтобы полагаться на стек и <code>Drop</code> в вопросах очистки памяти, сборщик
мусора работает с кучей.</p>
<h1><a class="header" href="#Что-использовать" id="Что-использовать">Что использовать?</a></h1>
<p>Но, если стек быстрее и проще в управлении, зачем тогда нужна куча? Весомая
причина заключается в том, что память в стеке может выделяться только по
принципу «первым пришёл — последним вышел». Таким образом, место из-под кадра
стека предыдущего вызова функции будет переиспользовано под следующий вызов.
Выделение в куче — более общая техника. Она позволяет выделение и освобождение
памяти в любом порядке. Однако, это достигается ценой увеличения сложности
реализации механизма выделения памяти.</p>
<p>В общем случае, следует предпочитать выделение в стеке, и поэтому, Rust
использует выделение в стеке по умолчанию. LIFO модель стека («последним
пришёл — первым вышел») фундаментально проще. Это значит, что программа быстрее
исполняется, и проще по смыслу.</p>
<h2><a class="header" href="#Эффективность-во-время-выполнения" id="Эффективность-во-время-выполнения">Эффективность во время выполнения</a></h2>
<p>Управление памятью для стека тривиально: машина просто увеличивает или
уменьшает одно значение, так называемый «указатель стека» (stack pointer).
Управление памятью для кучи сложнее: память, выделенная в куче, освобождается в
произвольные моменты, а каждая область выделенной в куче памяти может быть
произвольного размера. Распределителю памяти, как правило, требуется приложить
гораздо больше усилий для определения областей, которые можно использовать
заново.</p>
<p>Если вы хотите изучить эту тему более подробно, то <a href="http://www.cs.northwestern.edu/%7Epdinda/icsclass/doc/dsa.pdf">эта статья</a> будет
отличным введением.</p>
<h2><a class="header" href="#Простота-программы" id="Простота-программы">Простота программы</a></h2>
<p>Выделение памяти в стеке воздействует как на сам язык Rust, так и на модель
мышления разработчиков. Стековая семантика — ключевое понятие Rust. Мы получаем
автоматическое управление памятью без усложнения среды исполнения. Именно этот
механизм позволяет освободить память в куче, как только её владелец вышел из
области видимости — по сути, как только схлопнулся стек кадра, на котором он
жил. К сожалению, в некоторых ситуациях стека недостаточно. Если нужна большая
гибкость во владении памятью, можно воспользоваться счётчиками ссылок <code>Rc&lt;T&gt;</code> и
<code>Arc&lt;T&gt;</code>.</p>
<p>Желание более удобно пользоваться памятью в куче может доходить до крайности. С
одной стороны, можно реализовать сборщик мусора — но это сильно увеличивает
сложность среды исполнения. С другой стороны, полностью ручное управление
памятью с явным вызовом процедуры освобождения часто приводит к ошибкам,
предотвратить которые компилятор Rust не в силах.</p>
<p>% Тестирование</p>
<blockquote>
<p>Program testing can be a very effective way to show the presence of bugs, but
it is hopelessly inadequate for showing their absence.</p>
<p>Edsger W. Dijkstra, &quot;The Humble Programmer&quot; (1972)</p>
</blockquote>
<blockquote>
<p>Тестирование программы может быть очень эффективным способом показать наличие
ошибок, но оно безнадёжно неподходяще для доказательства их отсутствия.</p>
<p>Дейкстра, Эдсгер Вибе, «The Humble Programmer» (1972)</p>
</blockquote>
<p>Давайте поговорим о том, как тестировать код на Rust. Мы не будем рассказывать о
том, какой подход к тестированию Rust кода является верным. Есть много подходов,
каждый из которых имеет свое представление о правильном написании тестов. Но все
эти подходы используют одни и те же основные инструменты, и мы покажем вам
синтаксис их использования.</p>
<h1><a class="header" href="#Тесты-с-атрибутом-test" id="Тесты-с-атрибутом-test">Тесты с атрибутом <code>test</code></a></h1>
<p>В самом простом случае, тест в Rust — это функция, аннотированная атрибутом
<code>test</code>. Давайте создадим новый проект Cargo, который будет называться <code>adder</code>:</p>
<pre><code class="language-bash">$ cargo new adder
$ cd adder
</code></pre>
<p>При создании нового проекта, Cargo автоматически сгенерирует простой тест. Ниже
представлено содержимое <code>src/lib.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn it_works() {
}
#}</code></pre></pre>
<p>Обратите внимание на <code>#[test]</code>. Этот атрибут указывает, что это тестовая
функция. В этом примере она не имеет тела. Но такого вида функции достаточно,
чтобы удачно выполнить тест. Запуск тестов осуществляется командой <code>cargo test</code>.</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Cargo скомпилировал и запустил наши тесты. В результате мы получили выходные
данные, поделенные на два раздела: один содержит информацию о тесте, который мы
написали, а другой — информацию о тестах из документации. Но об этом позже. А
сейчас посмотрим на эту строку:</p>
<pre><code class="language-text">test it_works ... ok
</code></pre>
<p>Обратите внимание на <code>it_works</code>. Это название нашей функции:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn it_works() {
# }
#}</code></pre></pre>
<p>Мы также получили итоговую строку:</p>
<pre><code class="language-text">test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Так почему же наш ничего не делающий тест был выполнен удачно? Любой тест,
который не вызывает <code>panic!</code>, выполняется удачно, а любой тест, который вызывает
<code>panic!</code>, выполняется неудачно. Давайте сделаем тест, который выполнится
неудачно:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
fn it_works() {
    assert!(false);
}
#}</code></pre></pre>
<p><code>assert!</code> — это макрос, определенный в Rust, и принимающий один аргумент: если
аргумент имеет значение <code>true</code>, то ничего не происходит; если аргумент является
<code>false</code>, то вызывается <code>panic!</code>. Давайте запустим наши тесты снова:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... FAILED

failures:

---- it_works stdout ----
        thread 'it_works' panicked at 'assertion failed: false', /home/steve/tmp/adder/src/lib.rs:3



failures:
    it_works

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured

thread '&lt;main&gt;' panicked at 'Some tests failed', /home/steve/src/rust/src/libtest/lib.rs:247
</code></pre>
<p>Rust сообщает, что наш тест выполнен неудачно:</p>
<pre><code class="language-text">test it_works ... FAILED
</code></pre>
<p>Это же отражается в итоговой строке:</p>
<pre><code class="language-text">test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured
</code></pre>
<p>Мы также получаем ненулевой код состояния. Можно использовать <code>$?</code> на OS X и Linux:</p>
<pre><code class="language-bash">$ echo $?
101
</code></pre>
<p>На Windows, если вы используете <code>cmd</code>:</p>
<pre><code class="language-bash">    echo %ERRORLEVEL%
</code></pre>
<p>И если вы используете PowerShell:</p>
<pre><code class="language-bash">    echo $LASTEXITCODE # сам код
    echo $? # логическое, успешно или не успешно
</code></pre>
<p>Это бывает полезно, если вы хотите интегрировать <code>cargo test</code> в сторонний
инструмент.</p>
<p>Можно инвертировать ожидаемый результат теста с помощью атрибута:
<code>should_panic</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
#[should_panic]
fn it_works() {
    assert!(false);
}
#}</code></pre></pre>
<p>Теперь этот тест будет выполнен удачно, если вызывается <code>panic!</code>, и неудачно,
если <code>panic!</code> не вызывается. Давайте попробуем:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Rust предоставляет и другой макрос, <code>assert_eq!</code>, который проверяет равенство
двух аргументов:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
#[should_panic]
fn it_works() {
    assert_eq!(&quot;Hello&quot;, &quot;world&quot;);
}
#}</code></pre></pre>
<p>А теперь этот тест будет выполнен удачно или неудачно? Из-за атрибута
<code>should_panic</code> он завершится удачно:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Тесты <code>should_panic</code> могут быть хрупкими, поскольку трудно гарантировать, что
тест не вызовет панику по неожиданной причине. Чтобы помочь в этом аспекте, к
атрибуту <code>should_panic</code> может быть добавлен необязательный параметр <code>expected</code>.
Тогда тест также будет проверять, что сообщение об ошибке содержит ожидаемый
текст. Ниже представлен более безопасный вариант приведенного выше примера:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[test]
#[should_panic(expected = &quot;assertion failed&quot;)]
fn it_works() {
    assert_eq!(&quot;Hello&quot;, &quot;world&quot;);
}
#}</code></pre></pre>
<p>Вот и все, что касается основ! Давайте напишем один «настоящий» тест:</p>
<pre><code class="language-rust ignore">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[test]
fn it_works() {
    assert_eq!(4, add_two(2));
}
</code></pre>
<p>Это распространенное использование макроса <code>assert_eq!</code>: вызывать некоторую
функцию с известными аргументами и сравнить результат её вызова с ожидаемым
результатом.</p>
<h1><a class="header" href="#Тесты-с-атрибутом-ignore" id="Тесты-с-атрибутом-ignore">Тесты с атрибутом <code>ignore</code></a></h1>
<p>Некоторые тесты могу занимать много времени на выполнение. Такие тесты могут
быть отключены по умолчанию с помощью атрибута <code>ignore</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn it_works() {
    assert_eq!(4, add_two(2));
}

#[test]
#[ignore]
fn expensive_test() {
    // код, который занимает час на выполнение
}
#}</code></pre></pre>
<p>Теперь запустим наши тесты и видим, что <code>it_works</code> запускается, а
<code>expensive_test</code> нет:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Дорогостоящие тесты могут быть запущены с помощью команды
<code>cargo test -- --ignored</code>:</p>
<pre><code class="language-bash">$ cargo test -- --ignored
     Running target/adder-91b3e234d4ed382a

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Аргумент <code>--ignored</code> — это аргумент для тестового исполняемого файла, а не для
Cargo, именно поэтому команда выглядит так <code>cargo test -- --ignored</code>.</p>
<h1><a class="header" href="#Тесты-в-модуле-test" id="Тесты-в-модуле-test">Тесты в модуле <code>test</code></a></h1>
<p>Есть один нюанс, из-за которого наш пример нельзя назвать идиоматичным:
отсутствует модуль тестирования. Идиоматичный вариант нашего примера будет
выглядеть примерно так:</p>
<pre><code class="language-rust ignore">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod test {
    use super::add_two;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }
}
</code></pre>
<p>Здесь есть несколько изменений. Первое — это введение <code>mod test</code> с атрибутом
<code>cfg</code>. Модуль позволяет сгруппировать все наши тесты вместе, а также, если
нужно, определить вспомогательные функции, которые будут отделены от остальной
части контейнера. Атрибут <code>cfg</code> указывает на то, что тест будет скомпилирован,
только когда мы попытаемся запустить тесты. Это может сэкономить время
компиляции, а также гарантирует, что наши тесты полностью исключены из обычной
сборки.</p>
<p>Второе изменение заключается в объявлении <code>use</code>. Так как мы находимся во
внутреннем модуле, то мы должны объявить использование тестируемой функции в его
области видимости. Это может раздражать, если у вас большой модуль, и поэтому
обычно используют возможность <code>glob</code>. Давайте изменим <code>src/lib.rs</code>
соответствующим образом:</p>
<pre><code class="language-rust ignore">
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }
}
</code></pre>
<p>Обратите внимание на различие в строке с <code>use</code>. Теперь запустим наши тесты:</p>
<pre><code class="language-bash">$ cargo test
    Updating registry `https://github.com/rust-lang/crates.io-index`
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test test::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Работает!</p>
<p>Данный подход представляет собой использование модуля <code>test</code>, содержащего
модульные тесты (unit tests). Любой код, задачей которого является только лишь
тестирование небольшого кусочка функциональности, имеет смысл перенести в этот
модуль. Но что если мы хотим написать «интеграционные тесты» (integration
tests)? Для этого следует использовать директорию <code>tests</code>.</p>
<h1><a class="header" href="#Тесты-в-директории-tests" id="Тесты-в-директории-tests">Тесты в директории <code>tests</code></a></h1>
<p>Чтобы написать интеграционный тест, давайте создадим директорию <code>tests</code>, и
положим в нее файл <code>tests/lib.rs</code> со следующим содержимым:</p>
<pre><code class="language-rust ignore">extern crate adder;

#[test]
fn it_works() {
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p>Выглядит примерно так же, как и наши предыдущие тесты, но есть некоторые
отличия. Теперь сверху у нас <code>extern crate adder</code>. Это потому, что тесты в
директории <code>tests</code> — это отдельный контейнер, и, следовательно, мы должны
компоноваться с нашей библиотекой. Это также объясняет, почему директория
<code>tests</code> — наиболее подходящее место для написания интеграционных тестов: они
используют библиотеку, как это делал бы любой другой потребитель.</p>
<p>Давайте запустим их:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/you/projects/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test test::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

     Running target/lib-c18e7d3494509e74

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Теперь у нас появилось три раздела: запускается старый модульный тест, а также
новый интеграционный тест.</p>
<p>Это все, что касается директории <code>tests</code>. Модуль <code>test</code> здесь не нужен, так как
здесь всё относится к тестам.</p>
<p>Давайте, наконец, перейдем к третьей части: тесты в документации.</p>
<h1><a class="header" href="#Тесты-в-документации" id="Тесты-в-документации">Тесты в документации</a></h1>
<p>Нет ничего лучше, чем документация с примерами. Нет ничего хуже, чем примеры,
которые на самом деле не работают, потому что код изменился с тех пор, как была
написана документация. Для того, чтобы такой ситуации не возникало, Rust
поддерживает автоматический запуск примеров в документации (имейте ввиду, что
это работает только с библиотеками). Вот дополненный <code>src/lib.rs</code> с примерами:</p>
<pre><code class="language-rust ignore">//! Контейнер `adder` предоставляет функции сложения чисел.
//!
//! # Examples
//!
//! ```
//! assert_eq!(4, adder::add_two(2));
//! ```

/// Эта функция прибавляет 2 к своему аргументу.
///
/// # Examples
///
/// ```
/// use adder::add_two;
///
/// assert_eq!(4, add_two(2));
/// ```
pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }
}
</code></pre>
<p>Обратите внимание на документацию уровня модуля, начинающуюся с <code>//!</code> и на
документацию уровня функции, начинающуюся с <code>///</code>. Документация Rust
поддерживает Markdown в комментариях, поэтому блоки кода помечают тройными
символами `. В комментарии документации обычно включают раздел <code># Examples</code>,
содержащий примеры, такие как этот. (Примечание переводчика: заголовок <code># Examples</code> имеет особое значение: его нельзя написать по-другому или написать на
русском языке, иначе Rust не найдёт примеров кода в документации.)</p>
<p>Давайте запустим тесты снова:</p>
<pre><code class="language-bash">$ cargo test
   Compiling adder v0.0.1 (file:///home/steve/tmp/adder)
     Running target/adder-91b3e234d4ed382a

running 1 test
test test::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

     Running target/lib-c18e7d3494509e74

running 1 test
test it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured

   Doc-tests adder

running 2 tests
test add_two_0 ... ok
test _0 ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<p>Теперь у нас запускаются все три вида тестов! Обратите внимание на имена тестов
из документации: <code>_0</code> генерируется для модульных тестов, и <code>add_two_0</code> — для
функциональных тестов. Цифры на конце будут увеличиваться автоматически, если вы
добавите еще примеров. Например, при добавлении ещё одного функционального
теста, он получит имя <code>add_two_1</code>.</p>
<p>Мы не рассмотрели все детали написания тестов в документации. Подробнее
смотрите главу <a href="documentation.html">Документация</a>.</p>
<p>Последнее замечание: тесты в документации <em>не работают</em> для исполняемых файлов.
Подробнее об организации файлов можно узнать в главе <a href="crates-and-modules.html">Контейнеры и модули</a>.</p>
<p>% Условная компиляция</p>
<p>В Rust есть специальный атрибут, <code>#[cfg]</code>, который позволяет компилировать код в
зависимости от флагов, переданных компилятору. Он имеет две формы:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(foo)]
# fn foo() {}

#[cfg(bar = &quot;baz&quot;)]
# fn bar() {}
#}</code></pre></pre>
<p>Над атрибутами конфигурации определены логические операции:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(any(unix, windows))]
# fn foo() {}

#[cfg(all(unix, target_pointer_width = &quot;32&quot;))]
# fn bar() {}

#[cfg(not(foo))]
# fn not_foo() {}
#}</code></pre></pre>
<p>Они могут быть как угодно вложены:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(any(not(unix), all(target_os=&quot;macos&quot;, target_arch = &quot;powerpc&quot;)))]
# fn foo() {}
#}</code></pre></pre>
<p>Что же касается того, как включить или отключить эти флаги: если вы используете
Cargo, то они устанавливаются в <a href="http://doc.crates.io/manifest.html#the-%5Bfeatures%5D-section">разделе <code>[features]</code></a> вашего
<code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[features]
# по умолчанию, никаких дополнительных возможностей
default = []

# возможность «secure-password» зависит от пакета bcrypt
secure-password = [&quot;bcrypt&quot;]
</code></pre>
<p>Если вы определите такие возможности, Cargo передаст флаг в <code>rustc</code>:</p>
<pre><code class="language-text">--cfg feature=&quot;${feature_name}&quot;
</code></pre>
<p>Совокупность этих флагов конфигурации (<code>cfg</code>) будет определять, какие из них
будут активны, и, следовательно, какой код будет скомпилирован. Давайте
рассмотрим такой код:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg(feature = &quot;foo&quot;)]
mod foo {
}
#}</code></pre></pre>
<p>Если скомпилировать его с помощью <code>cargo build --features &quot;foo&quot;</code>, то в <code>rustc</code>
будет передан флаг <code>--cfg feature=&quot;foo&quot;</code>, и результат будет содержать
модуль <code>mod foo</code>. Если скомпилировать его с помощью обычной команды <code>cargo build</code>, то никаких дополнительных флагов передано не будет, и поэтому, модуль
<code>mod foo</code> будет отсутствовать.</p>
<h1><a class="header" href="#cfg_attr" id="cfg_attr">cfg_attr</a></h1>
<p>Вы также можете установить другой атрибут в зависимости от переменной <code>cfg</code> с
помощью атрибута <code>cfg_attr</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[cfg_attr(a, b)]
# fn foo() {}
#}</code></pre></pre>
<p>Этот код будет равносилен атрибуту <code>#[b]</code>, если в атрибуте <code>cfg</code> установлен флаг
<code>a</code>, или «без атрибута» в противном случае.</p>
<h1><a class="header" href="#cfg" id="cfg">cfg!</a></h1>
<p><a href="compiler-plugins.html">Расширение синтаксиса</a> <code>cfg!</code> позволяет использовать данные
виды флагов и в другом месте в коде:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
if cfg!(target_os = &quot;macos&quot;) || cfg!(target_os = &quot;ios&quot;) {
    println!(&quot;Think Different!&quot;);
}
#}</code></pre></pre>
<p>Значение флага будет заменено на <code>true</code> или <code>false</code> во время компиляции, в
зависимости от настройки конфигурации.</p>
<p>% Документация</p>
<p>Документация является важной частью любого программного проекта, и в Rust ей
уделяется не меньше внимания, чем самому коду. Давайте поговорим об инструментах
Rust, предназначенных для создания документации к проекту.</p>
<h2><a class="header" href="#О-rustdoc" id="О-rustdoc">О <code>rustdoc</code></a></h2>
<p>Дистрибутив Rust включает в себя инструмент, <code>rustdoc</code>, который генерирует
документацию. <code>rustdoc</code> также используется Cargo через <code>cargo doc</code>.</p>
<p>Документация может быть сгенерирована двумя методами: из исходного кода, и из
отдельных файлов в формате Markdown.</p>
<h2><a class="header" href="#Документирование-исходного-кода" id="Документирование-исходного-кода">Документирование исходного кода</a></h2>
<p>Основной способ документирования проекта на Rust заключается в комментировании
исходного кода. Для этой цели вы можете использовать документирующие
комментарии:</p>
<pre><code class="language-rust ignore">/// Создаёт новый `Rc&lt;T&gt;`.
///
/// # Examples
///
/// ```
/// use std::rc::Rc;
///
/// let five = Rc::new(5);
/// ```
pub fn new(value: T) -&gt; Rc&lt;T&gt; {
    // здесь реализация
}
</code></pre>
<p>Этот код генерирует документацию, которая выглядит <a href="http://doc.rust-lang.org/std/rc/struct.Rc.html#method.new">так</a>. В приведенном
коде реализация метода была заменена на обычный комментарий. Первое, на что
следует обратить внимание в этом примере, это на использование <code>///</code> вместо
<code>//</code>. Символы <code>///</code> указывают, что это документирующий комментарий.</p>
<p>Документирующие комментарии пишутся на Markdown.</p>
<p>Rust отслеживает такие комментарии, и использует их при создании документации.</p>
<p>При документировании таких вещей, как перечисления, нужно учитывать некоторые
особенности работы <code>rustdoc</code>. Такой код работает:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Тип `Option`. Подробнее смотрите [документацию уровня модуля](http://doc.rust-lang.org/).
enum Option&lt;T&gt; {
    /// Нет значения
    None,
    /// Некоторое значение `T`
    Some(T),
}
#}</code></pre></pre>
<p>А такой — нет:</p>
<pre><code class="language-rust ignore">/// Тип `Option`. Подробнее смотрите [документацию уровня модуля](http://doc.rust-lang.org/).
enum Option&lt;T&gt; {
    None, /// Нет значения
    Some(T), /// Некоторое значение `T`
}
</code></pre>
<p>Вы получите ошибку:</p>
<pre><code class="language-text">hello.rs:4:1: 4:2 error: expected ident, found `}`
hello.rs:4 }
           ^
</code></pre>
<p>Эта досадная <a href="https://github.com/rust-lang/rust/issues/22547">ошибка</a>
заключается в следующем: комментарии документации распространяются на элементы,
расположенные за ними, а в данном примере нет элемента, расположенного после
последнего комментария.</p>
<h3><a class="header" href="#Написание-комментариев-документации" id="Написание-комментариев-документации">Написание комментариев документации</a></h3>
<p>Давайте рассмотрим каждую часть приведенного комментария в деталях:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Создаёт новый `Rc&lt;T&gt;`.
# fn foo() {}
#}</code></pre></pre>
<p>Первая строка документирующего комментария должна представлять из себя краткую
информацию о функциональности. Одно предложение. Только самое основное.
Высокоуровневое.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
///
/// Подробности создания `Rc&lt;T&gt;`, возможно, описывающие сложности семантики,
/// дополнительные опции, и всё остальное.
///
# fn foo() {}
#}</code></pre></pre>
<p>Наш исходный пример включал только строку с краткой информацией, но если бы у
нас было больше информации, о которой следует сказать, мы могли бы добавить эту
информацию в новом параграфе.</p>
<h4><a class="header" href="#Специальные-разделы" id="Специальные-разделы">Специальные разделы</a></h4>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// # Examples
# fn foo() {}
#}</code></pre></pre>
<p>Далее идут специальные разделы. Они обознаются заголовком, который начинается с
<code>#</code>. Существуют три вида заголовков, которые обычно используются. Они не
являются каким-либо специальным синтаксисом, на данный момент это просто
соглашение.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// # Panics
# fn foo() {}
#}</code></pre></pre>
<p>Раздел <code>Panics</code>. Неустранимые ошибки при неправильном вызове функции (так
называемые ошибки программирования) в Rust, как правило, вызывают панику,
которая, в крайнем случае, убивает весь текущий поток (thread). Если ваша
функция имеет подобное нетривиальное поведение — т.е. обнаруживает/вызывает
панику, то очень важно задокументировать это.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// # Failures
# fn foo() {}
#}</code></pre></pre>
<p>Раздел <code>Failures</code>. Если ваша функция или метод возвращает <code>Result&lt;T, E&gt;</code>, то
хорошим тоном является описание условий, при которых она возвращает <code>Err(E)</code>.
Это чуть менее важно, чем описание <code>Panics</code>, потому как неудача кодируется в
системе типов, но это не значит, что стоит пренебрегать данной возможностью.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// # Safety
# fn foo() {}
#}</code></pre></pre>
<p>Раздел <code>Safety</code>. Если ваша функция является <code>unsafe</code>, необходимо пояснить, какие
инварианты вызова должны поддерживаться.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// # Examples
///
/// ```
/// use std::rc::Rc;
///
/// let five = Rc::new(5);
/// ```
# fn foo() {}
#}</code></pre></pre>
<p>Раздел <code>Examples</code>. Включите в этот раздел один или несколько примеров
использования функции или метода, и ваши пользователи будут вам благодарны.
Примеры должны размещаться внутри блоков кода, о которых мы сейчас поговорим.
Этот раздел может иметь более одного подраздела:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// # Examples
///
/// Простые образцы типа `&amp;str`:
///
/// ```
/// let v: Vec&lt;&amp;str&gt; = &quot;И была у них курочка Ряба&quot;.split(' ').collect();
/// assert_eq!(v, vec![&quot;И&quot;, &quot;была&quot;, &quot;у&quot;, &quot;них&quot;, &quot;курочка&quot;, &quot;Ряба&quot;]);
/// ```
///
/// Более сложные образцы с замыканиями:
///
/// ```
/// let v: Vec&lt;&amp;str&gt; = &quot;абв1где2жзи&quot;.split(|c: char| c.is_numeric()).collect();
/// assert_eq!(v, vec![&quot;абв&quot;, &quot;где&quot;, &quot;жзи&quot;]);
/// ```
# fn foo() {}
#}</code></pre></pre>
<p>Давайте подробно обсудим блоки кода.</p>
<h4><a class="header" href="#Блок-кода" id="Блок-кода">Блок кода</a></h4>
<p>Чтобы написать код на Rust в комментарии, используйте символы ```:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// ```
/// println!(&quot;Привет, мир&quot;);
/// ```
# fn foo() {}
#}</code></pre></pre>
<p>Если вы хотите написать код на любом другом языке (не на Rust), вы можете
добавить аннотацию:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// ```c
/// printf(&quot;Hello, world\n&quot;);
/// ```
# fn foo() {}
#}</code></pre></pre>
<p>Это позволит использовать подсветку синтаксиса, соответствующую тому языку,
который был указан в аннотации. Если же это простой текст, то в аннотации
указывается <code>text</code>.</p>
<p>Важно выбрать правильную аннотацию, потому что <code>rustdoc</code> использует ее
интересным способом: Rust может выполнять проверку работоспособности примеров на
момент создания документации. Это позволяет избежать устаревания примеров.
Предположим, у вас есть код на C. Если вы опустите аннотацию, указывающую, что
это код на C, то <code>rustdoc</code> будет думать, что это код на Rust, поэтому он
пожалуется при попытке создания документации.</p>
<h2><a class="header" href="#Тесты-в-документации-1" id="Тесты-в-документации-1">Тесты в документации</a></h2>
<p>Давайте обсудим наш пример документации:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// ```
/// println!(&quot;Привет, мир&quot;);
/// ```
# fn foo() {}
#}</code></pre></pre>
<p>Заметьте, что здесь нет нужды в <code>fn main()</code> или чём-нибудь подобном. <code>rustdoc</code>
автоматически добавит оборачивающий <code>main()</code> вокруг вашего кода в нужном месте.
Например:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// ```
/// use std::rc::Rc;
///
/// let five = Rc::new(5);
/// ```
# fn foo() {}
#}</code></pre></pre>
<p>В конечном итоге это будет тест:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    use std::rc::Rc;
    let five = Rc::new(5);
}
</code></pre></pre>
<p>Вот полный алгоритм, который <code>rustdoc</code> использует для обработки примеров:</p>
<ol>
<li>Любые ведущие (leading) атрибуты <code>#![foo]</code> остаются без изменений в качестве
атрибутов контейнера.</li>
<li>Будут вставлены некоторые общие атрибуты <code>allow</code>, в том числе:
<code>unused_variables</code>, <code>unused_assignments</code>, <code>unused_mut</code>, <code>unused_attributes</code>,
<code>dead_code</code>. Небольшие примеры часто приводят к срабатыванию этих анализов.</li>
<li>Если пример не содержит <code>extern crate</code>, то будет вставлено <code>extern crate &lt;mycrate&gt;;</code>.</li>
<li>Наконец, если пример не содержит <code>fn main</code>, то оставшаяся часть текста будет
обернута в <code>fn main() { your_code }</code></li>
</ol>
<p>Хотя иногда этого не достаточно. Например, что насчёт всех этих примеров кода с
<code>///</code>, о которых мы говорили? Простой текст, обработанный <code>rustdoc</code>, выглядит
так:</p>
<pre><code class="language-text">/// Некоторая документация.
# fn foo() {}
</code></pre>
<p>А исходный текст на Rust после обработки выглядит так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Некоторая документация.
# fn foo() {}
#}</code></pre></pre>
<p>Да, именно так: вы можете добавлять строки, которые начинаются с <code># </code>, и они
будут скрыты в выводе, но при этом будут использоваться во время компиляции
кода. Вы можете использовать это в своих интересах. Если в документирующем
комментарии необходимо обратиться к какой-то функции, то ниже нужно будет
добавить определение этой функции. В то же время, это делается только для того,
чтобы удовлетворить компилятор, поэтому сокрытие ненужных строк в выводе делает
пример более ясным. Вы можете использовать эту технику, чтобы детально объяснять
длинные примеры, сохраняя при этом тестируемость документации. Например, вот
код:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
let y = 6;
println!(&quot;{}&quot;, x + y);
#}</code></pre></pre>
<p>Ниже приведено отрисованное объяснение этого кода.</p>
<p>Сперва мы устанавливаем <code>x</code> равным пяти:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = 5;
# let y = 6;
# println!(&quot;{}&quot;, x + y);
#}</code></pre></pre>
<p>Затем мы устанавливаем <code>y</code> равным шести:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let x = 5;
let y = 6;
# println!(&quot;{}&quot;, x + y);
#}</code></pre></pre>
<p>В конце мы печатаем сумму <code>x</code> и <code>y</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# let x = 5;
# let y = 6;
println!(&quot;{}&quot;, x + y);
#}</code></pre></pre>
<p>А вот то же самое объяснение, но в виде простого текста:</p>
<blockquote>
<p>Сперва мы устанавливаем <code>x</code> равным пяти:</p>
<pre><code class="language-text">let x = 5;
# let y = 6;
# println!(&quot;{}&quot;, x + y);
</code></pre>
<p>Затем мы устанавливаем <code>y</code> равным шести:</p>
<pre><code class="language-text"># let x = 5;
let y = 6;
# println!(&quot;{}&quot;, x + y);
</code></pre>
<p>В конце мы печатаем сумму <code>x</code> и <code>y</code>:</p>
<pre><code class="language-text"># let x = 5;
# let y = 6;
println!(&quot;{}&quot;, x + y);
</code></pre>
</blockquote>
<p>Повторяя все части примера, вы можете быть уверены, что ваш пример
компилируется, а не просто отображает кусочки кода, которые как-то относятся к
той или иной части вашего объяснения.</p>
<h3><a class="header" href="#Документирование-макросов" id="Документирование-макросов">Документирование макросов</a></h3>
<p>Вот пример документирования макроса:</p>
<pre><pre class="playpen"><code class="language-rust">/// Паниковать с данным сообщением, если только выражение не является истиной.
///
/// # Examples
///
/// ```
/// # #[macro_use] extern crate foo;
/// # fn main() {
/// panic_unless!(1 + 1 == 2, &quot;Математика сломалась.&quot;);
/// # }
/// ```
///
/// ```should_panic
/// # #[macro_use] extern crate foo;
/// # fn main() {
/// panic_unless!(true == false, &quot;Я сломан.&quot;);
/// # }
/// ```
#[macro_export]
macro_rules! panic_unless {
    ($condition:expr, $($rest:expr),+) =&gt; ({ if ! $condition { panic!($($rest),+); } });
}
# fn main() {}
</code></pre></pre>
<p>В нем вы можете заметить три вещи. Во-первых, мы должны собственноручно добавить
строку с <code>extern crate</code> для того, чтобы мы могли указать атрибут <code>#[macro_use]</code>.
Во-вторых, мы также собственноручно должны добавить <code>main()</code>. И наконец, разумно
будет использовать <code>#</code>, чтобы закомментировать все, что мы добавили в первых
двух пунктах, что бы оно не отображалось в генерируемом выводе.</p>
<h3><a class="header" href="#Запуск-тестов-в-документации" id="Запуск-тестов-в-документации">Запуск тестов в документации</a></h3>
<p>Для запуска тестов можно использовать одну из двух комманд</p>
<pre><code class="language-bash">$ rustdoc --test path/to/my/crate/root.rs
# или
$ cargo test
</code></pre>
<p>Все верно, <code>cargo test</code> также выполняет тесты, встроенные в документацию. Тем не
менее, <code>cargo test</code> не будет тестировать исполняемые контейнеры, только
библиотечные. Это связано с тем, как работает <code>rustdoc</code>: он компонуется с
библиотекой, которую надо протестировать, но в случае с исполняемым файлом
компоноваться не с чем.</p>
<p>Есть еще несколько полезных аннотаций, которые помогают <code>rustdoc</code> работать
правильно при тестировании кода:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// ```ignore
/// fn foo() {
/// ```
# fn foo() {}
#}</code></pre></pre>
<p>Аннотация <code>ignore</code> указывает Rust, что код должен быть проигнорирован. Почти во
всех случаях это не то, что вам нужно, так как эта директива носит очень общий
характер. Вместо неё лучше использовать аннотацию <code>text</code>, если это не код, или
<code>#</code>, чтобы получить рабочий пример, отображающий только ту часть, которая вам
нужна.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// ```should_panic
/// assert!(false);
/// ```
# fn foo() {}
#}</code></pre></pre>
<p>Аннотация <code>should_panic</code> указывает <code>rustdoc</code>, что код должен компилироваться, но
выполнение теста должно завершиться ошибкой.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// ```no_run
/// loop {
///     println!(&quot;Привет, мир&quot;);
/// }
/// ```
# fn foo() {}
#}</code></pre></pre>
<p>Аннотация <code>no_run</code> указывает, что код должен компилироваться, но запускать его
на выполнение не требуется. Это важно для таких примеров, которые должны успешно
компилироваться, но выполнение которых оказывается бесконечным циклом! Например:
«Вот как запустить сетевой сервис».</p>
<h3><a class="header" href="#Документирование-модулей" id="Документирование-модулей">Документирование модулей</a></h3>
<p>Rust предоставляет ещё один вид документирующих комментариев, <code>//!</code>. Этот
комментарий относится не к следующему за ним элементу, а к элементу, который его
включает. Другими словами:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod foo {
    //! Это документация для модуля `foo`.
    //!
    //! # Examples

    // ...
}
#}</code></pre></pre>
<p>Приведённый пример демонстрирует наиболее распространённое использование <code>//!</code>:
документирование модуля. Если же модуль расположен в файле <code>foo.rs</code>, то вы,
открывая его код, часто будете видеть следующее:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! Модуль использования разных `foo`.
//!
//! Модуль `foo` содержит много полезной функциональности ла-ла-ла
#}</code></pre></pre>
<h3><a class="header" href="#Стиль-документирующих-комментариев" id="Стиль-документирующих-комментариев">Стиль документирующих комментариев</a></h3>
<p>Изучите <a href="https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md">RFC 505</a> для получения полных сведений о соглашениях по стилю и
формату документации.</p>
<h2><a class="header" href="#Другая-документация" id="Другая-документация">Другая документация</a></h2>
<p>Все эти правила поведения также применимы и в отношении исходных файлов не на
Rust. Так как комментарии пишутся на Markdown, то часто эти файлы имеют
расширение <code>.md</code>.</p>
<p>Когда вы пишете документацию в файлах Markdown, вам не нужно добавлять префикс
документирующего комментария, <code>///</code>. Например:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// # Examples
///
/// ```
/// use std::rc::Rc;
///
/// let five = Rc::new(5);
/// ```
# fn foo() {}
#}</code></pre></pre>
<p>преобразуется в</p>
<pre><code class="language-markdown"># Examples

```
use std::rc::Rc;

let five = Rc::new(5);
```
</code></pre>
<p>когда он находится в файле Markdown. Однако есть один недостаток: файлы Markdown
должны иметь заголовок наподобие этого:</p>
<pre><code class="language-markdown">% Заголовок

Это пример документации.
</code></pre>
<p>Строка, начинающаяся с <code>%</code>, должна быть самой первой строкой файла.</p>
<h2><a class="header" href="#Атрибуты-doc" id="Атрибуты-doc">Атрибуты <code>doc</code></a></h2>
<p>На более глубоком уровне, комментарии документации — это синтаксический сахар
для атрибутов документации:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// this
# fn foo() {}

#[doc=&quot;this&quot;]
# fn bar() {}
#}</code></pre></pre>
<p>Т.е. представленные выше комментарии идентичны, также как и ниже:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
//! this

#![doc=&quot;/// this&quot;]
#}</code></pre></pre>
<p>Вы не часто будете видеть этот атрибут, используемый для написания документации,
но он может быть полезен для изменения некоторых настроек, или при написании
макроса.</p>
<h3><a class="header" href="#Ре-экспорт" id="Ре-экспорт">Ре-экспорт</a></h3>
<p><code>rustdoc</code> будет показывать документацию для общедоступного (public) ре-экспорта
в двух местах:</p>
<pre><code class="language-ignore">extern crate foo;

pub use foo::bar;
</code></pre>
<p>Это создаст документацию для <code>bar</code> как в документации для контейнера <code>foo</code>, так
и в документации к вашему контейнеру. То есть в обоих местах будет использована
одна и та же документация.</p>
<p>Такое поведение может быть подавлено с помощью <code>no_inline</code>:</p>
<pre><code class="language-ignore">extern crate foo;

#[doc(no_inline)]
pub use foo::bar;
</code></pre>
<h3><a class="header" href="#Управление-html" id="Управление-html">Управление HTML</a></h3>
<p>Вы можете управлять некоторыми аспектами HTML, который генерирует <code>rustdoc</code>,
через атрибут <code>#![doc]</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![doc(html_logo_url = &quot;http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png&quot;,
#fn main() {
       html_favicon_url = &quot;http://www.rust-lang.org/favicon.ico&quot;,
       html_root_url = &quot;http://doc.rust-lang.org/&quot;)];
#}</code></pre></pre>
<p>В этом примере устанавливается несколько различных опций: логотип, иконка и
корневой URL.</p>
<h2><a class="header" href="#Опции-генерации" id="Опции-генерации">Опции генерации</a></h2>
<p><code>rustdoc</code> также содержит несколько опций командной строки для дальнейшей
настройки:</p>
<ul>
<li><code>--html-in-header FILE</code>: включить содержимое FILE в конец раздела
<code>&lt;head&gt;...&lt;/head&gt;</code>.</li>
<li><code>--html-before-content FILE</code>: включить содержимое FILE сразу после <code>&lt;body&gt;</code>,
перед отображаемым содержимым (в том числе строки поиска).</li>
<li><code>--html-after-content FILE</code>: включить содержимое FILE после всего
отображаемого содержимого.</li>
</ul>
<h2><a class="header" href="#Замечание-по-безопасности" id="Замечание-по-безопасности">Замечание по безопасности</a></h2>
<p>Комментарии в документации в формате Markdown помещаются в конечную веб-страницу
без обработки. Будьте осторожны с HTML-литералами:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// &lt;script&gt;alert(document.cookie)&lt;/script&gt;
# fn foo() {}
#}</code></pre></pre>
<p>% Итераторы</p>
<p>Давайте поговорим о циклах.</p>
<p>Помните цикл <code>for</code> в Rust? Вот пример:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for x in 0..10 {
    println!(&quot;{}&quot;, x);
}
#}</code></pre></pre>
<p>Теперь, когда вы знаете о Rust немного больше, мы можем детально обсудить, как
же это работает. Диапазоны (<code>0..10</code>) являются «итераторами». Итератор — это
сущность, для которой мы можем неоднократно вызвать метод <code>.next()</code>, в
результате чего мы получим последовательность элементов.</p>
<p>Как представлено ниже:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let mut range = 0..10;

loop {
    match range.next() {
        Some(x) =&gt; {
            println!(&quot;{}&quot;, x);
        },
        None =&gt; { break }
    }
}
#}</code></pre></pre>
<p>Мы связываем с диапазоном изменяемое имя, которая и является нашим итератором.
Затем мы используем цикл <code>loop</code> с внутренней конструкцией <code>match</code>. Здесь <code>match</code>
применяется к результату <code>range.next()</code>, который выдает нам ссылку на следующее
значение итератора. В данном случае <code>next</code> возвращает <code>Option&lt;i32&gt;</code>, который
представляет собой <code>Some(i32)</code> когда у нас есть значение и <code>None</code> когда перебор
элементов закончен. Если мы получаем <code>Some(i32)</code>, то печатаем его, а если
<code>None</code>, то прекращаем выполнение цикла оператором <code>break</code>.</p>
<p>Этот пример, по большому счету, делает то же самое, что и пример с циклом <code>for</code>.
Цикл <code>for</code> — просто удобный способ записи конструкции <code>loop</code>/<code>match</code>/<code>break</code>.</p>
<p>Однако, цикл <code>for</code> не является единственной конструкцией, которая использует
итераторы. Написание своего собственного итератора заключается в реализации
типажа <code>Iterator</code>. Хотя эта тема и выходит за рамки данного руководства, Rust
предоставляет ряд полезных итераторов для выполнения различных задач. Прежде чем
мы поговорим о них, мы должны рассказать о плохой практике в Rust, связанной с
использованием диапазонов. Она продемонстрирована в примере ниже.</p>
<p>Вот, только что мы говорили о том, какие диапазоны крутые. Но диапазоны также и
очень примитивны. Например, если вам нужно перебрать содержимое вектора, у вас
может возникнуть желание написать так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let nums = vec![1, 2, 3];

for i in 0..nums.len() {
    println!(&quot;{}&quot;, nums[i]);
}
#}</code></pre></pre>
<p>Это намного хуже, чем если бы мы использовали итератор непосредственно. Вы
можете пройти по элементам векторов напрямую, как показано ниже:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let nums = vec![1, 2, 3];

for num in &amp;nums {
    println!(&quot;{}&quot;, num);
}
#}</code></pre></pre>
<p>Есть две причины предпочесть прямое использование итератора. Во-первых, это
яснее выражает наше намерение. Мы обходим элементы вектора, а не индексы с
последующей индексацией вектора. Во-вторых, эта версия является более
эффективной: первая версия будет выполнять дополнительные проверки границ,
потому что используется индексация, <code>nums[i]</code>. Во втором примере нет никаких
проверок границ, поскольку мы получаем ссылки на каждый элемент вектора, одну за
одной, по мере итерирования. Это очень распространенный прием работы с
итераторами: мы можем игнорировать ненужные проверки границ, но все еще быть
уверенными, что мы в безопасности.</p>
<p>Остается неясной еще одна деталь работы <code>println!</code>. На самом деле <code>num</code> имеет
тип <code>&amp;i32</code>. То есть, это ссылка на <code>i32</code>, а не сам <code>i32</code>. <code>println!</code> выполняет
разыменование переменной за нас, поэтому мы не видим его в исходном коде. Этот
код также прекрасно работает:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let nums = vec![1, 2, 3];

for num in &amp;nums {
    println!(&quot;{}&quot;, *num);
}
#}</code></pre></pre>
<p>Здесь мы явно разыменовываем <code>num</code>. Почему <code>&amp;nums</code> выдает нам ссылки? Во-первых,
потому что мы явно попросили его об этом с помощью <code>&amp;</code>. Во-вторых, если он будет
выдавать нам сами данные, то мы должны быть их владельцем, что подразумевает
создание копии данных и выдачу этой копии нам. Со ссылками же мы просто
заимствуем ссылку на данные, и поэтому будет выдана просто ссылка, без
необходимости перемещать данные.</p>
<p>Теперь, когда мы установили, что зачастую диапазоны — это не то, что нужно,
давайте поговорим о том, что же можно использовать вместо диапазонов.</p>
<p>Есть три основных класса объектов, которые имеют отношение к данному вопросу:
<em>итераторы</em>, <em>адаптеры итераторов</em> и <em>потребители</em>. Вот некоторые определения:</p>
<ul>
<li><em>итераторы</em> выдают последовательность значений;</li>
<li><em>адаптеры итераторов</em> применяются к итератору и выдают новый итератор с другой
выходной последовательностью;</li>
<li><em>потребители</em> применяются к итератору, выдающему некоторый конечный набор
значений.</li>
</ul>
<p>Давайте сначала поговорим о потребителях, так как итераторы вы уже видели — это
диапазоны.</p>
<h2><a class="header" href="#Потребители" id="Потребители">Потребители</a></h2>
<p><em>Потребитель</em> применяется к итератору, возвращая какое-то значение или значения.
Наиболее распространенным потребителем является <code>collect()</code>. Этот код не
компилируется, но он показывает идею:</p>
<pre><code class="language-rust ignore">let one_to_one_hundred = (1..101).collect();
</code></pre>
<p>Как вы можете видеть, мы вызываем <code>collect()</code> для нашего итератора. <code>collect()</code>
принимает столько значений, сколько выдаст итератор, и возвращает коллекцию
результатов. Так почему же этот код не компилируется? Rust не может определить,
в какую коллекцию (например, вектор, список, и т.д.) вы хотите собрать элементы,
и поэтому тип необходимо указать явно. Вот версия, которая компилируется:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let one_to_one_hundred = (1..101).collect::&lt;Vec&lt;i32&gt;&gt;();
#}</code></pre></pre>
<p>Если помните, синтаксис <code>::&lt;&gt;</code> позволяет задать подсказку типа. Поэтому в
приведенном примере мы указали, что хотим вектор целых чисел. Хотя не всегда
бывает нужно задавать весь тип целиком. Использование символа <code>_</code> позволит вам
задать частичную подсказку типа:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let one_to_one_hundred = (1..101).collect::&lt;Vec&lt;_&gt;&gt;();
#}</code></pre></pre>
<p>Эта запись говорит компилятору Rust: «Пожалуйста, собери элементы в <code>Vec&lt;T&gt;</code>, а
вывод типа <code>T</code> сделай самостоятельно». По этой причине символ <code>_</code> иногда
называют «заполнителем типа».</p>
<p><code>collect()</code> является наиболее распространенным из потребителей, но есть и
другие. Например <code>find()</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let greater_than_forty_two = (0..100)
                             .find(|x| *x &gt; 42);

match greater_than_forty_two {
    Some(_) =&gt; println!(&quot;Мы нашли число!&quot;),
    None =&gt; println!(&quot;Число не найдено :(&quot;),
}
#}</code></pre></pre>
<p><code>find</code> принимает замыкание, которое обрабатывает ссылку на каждый элемент
итератора. Замыкание возвращает <code>true</code>, если элемент является искомым элементом,
и <code>false</code> в противном случае. Так как нам не всегда удается найти
соответствующий элемент, <code>find</code> возвращает <code>Option</code>, а не сам элемент.</p>
<p>Еще один важный потребитель — <code>fold</code>. Вот как он выглядит:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let sum = (1..4).fold(0, |sum, x| sum + x);
#}</code></pre></pre>
<p><code>fold()</code> — это потребитель, который схематично можно представить в виде:
<code>fold(base, |accumulator, element| ...)</code>. Он принимает два аргумента: первый -
это элемент, называемый <em>базой</em>; второй — это замыкание, которое, в свою очередь,
само принимает два аргумента: первый называется <em>аккумулятор</em>, а второй -
<em>элемент</em>. На каждой итерации вызывается замыкание, результат выполнения
которого становится значением аккумулятора на следующей итерации. На первой
итерации значение аккумулятора равно базе.</p>
<p>Это немного запутанно. Давайте рассмотрим значения всех элементов итератора:</p>
<table><thead><tr><th>база</th><th>аккумулятор</th><th>элемент</th><th>результат замыкания</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>1</td><td>1</td></tr>
<tr><td>0</td><td>1</td><td>2</td><td>3</td></tr>
<tr><td>0</td><td>3</td><td>3</td><td>6</td></tr>
</tbody></table>
<p>Мы вызвали <code>fold()</code> с этими аргументами:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# (1..4)
.fold(0, |sum, x| sum + x);
#}</code></pre></pre>
<p>Таким образом, <code>0</code> — это база, <code>sum</code> — это аккумулятор, а <code>x</code> — это элемент. На
первой итерации мы устанавливаем <code>sum</code> равной <code>0</code>, а <code>x</code> становится первым
элементом <code>nums</code>, <code>1</code>. Затем мы прибавляем <code>x</code> к <code>sum</code>, что дает нам <code>0 + 1 = 1</code>. На второй итерации это значение становится значением аккумулятора, <code>sum</code>, а
элемент становится вторым элементом массива, <code>2</code>. <code>1 + 2 = 3</code>, результат этого
выражения становится значением аккумулятора на последней итерации. На этой
итерации, <code>x</code> становится последним элементом, <code>3</code>, а значение выражения <code>3 + 3 = 6</code> является конечным значением нашей суммы. <code>1 + 2 + 3 = 6</code> — это результат,
который мы получили.</p>
<p>Вот так. <code>fold</code> может показаться немного странным, если вы используете его
впервые, но когда вы освоите его, то будете использовать его повсеместно. <code>fold</code>
подходит для случаев, когда у вас есть список элементов, а вам нужно получить
один единственный результат.</p>
<p>Потребители имеют очень большое значение в связи с одним свойством итераторов, о
котором мы еще не говорили: ленивость. Давайте ещё немного поговорим об
итераторах, и вы поймете, почему потребители так важны.</p>
<h2><a class="header" href="#Итераторы" id="Итераторы">Итераторы</a></h2>
<p>Как мы уже говорили ранее, итератор являются сущностью, для которой мы можем
неоднократно вызвать метод <code>.next()</code>, в результате чего мы получим
последовательность элементов. Для получения каждого следующего элемента нужно
вызвать метод, а это означает, что итераторы <em>ленивы</em> — они не обязаны
создавать все значения заранее. Например, этот код на самом деле не генерирует
номера <code>1-99</code>, а просто создает значение, представляющее эту последовательность:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let nums = 1..100;
#}</code></pre></pre>
<p>В этом примере мы никак не использовали диапазон, поэтому он и не создавал
последовательность. Давайте добавим потребителя:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let nums = (1..100).collect::&lt;Vec&lt;i32&gt;&gt;();
#}</code></pre></pre>
<p>Теперь <code>collect()</code> потребует, чтобы диапазон выдавал ему какие-нибудь числа,
поэтому он сгенерирует последовательность.</p>
<p>Диапазоны — это один из двух основных типов итераторов. Другой часто
используемый итератор — <code>iter()</code>. <code>iter()</code> может преобразовать вектор в простой
итератор, который выдает вам каждый элемент по очереди:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let nums = vec![1, 2, 3];

for num in nums.iter() {
   println!(&quot;{}&quot;, num);
}
#}</code></pre></pre>
<p>Эти два основных итератора хорошо послужат вам. Есть и более продвинутые
итераторы, в том числе и те, которые генерируют бесконечную последовательность.</p>
<p>Вот и все, что касается итераторов. Последнее понятие в этой теме, о котором мы
хотели бы рассказать — адаптеры итераторов. Давайте перейдем к нему!</p>
<h2><a class="header" href="#Адаптеры-итераторов" id="Адаптеры-итераторов">Адаптеры итераторов</a></h2>
<p><em>Адаптеры итераторов</em> получают итератор и изменяют его каким-то образом, выдавая
новый итератор. Простейший из них называется <code>map</code>:</p>
<pre><code class="language-rust ignore">(1..100).map(|x| x + 1);
</code></pre>
<p><code>map</code> вызывается для итератора, и создает новый итератор, каждый элемент
которого получается в результате вызова замыкания, в качестве аргумента которому
передается ссылка на исходный элемент. Так что этот код выдаст нам числа
<code>2-100</code>. Ну, почти! Если вы скомпилируете пример, этот код выдаст
предупреждение:</p>
<pre><code class="language-text">warning: unused result which must be used: iterator adaptors are lazy and
         do nothing unless consumed, #[warn(unused_must_use)] on by default
(1..100).map(|x| x + 1);
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>
<p>Причина этого — ленивость итераторов! То замыкание никогда не будет выполнено.
Пример ниже не напечатает ни одного значения:</p>
<pre><code class="language-rust ignore">(1..100).map(|x| println!(&quot;{}&quot;, x));
</code></pre>
<p>Если вы пытаетесь выполнить замыкание ради побочных эффектов (вроде печати), то
вместо этого просто используйте <code>for</code>.</p>
<p>Есть масса интересных адаптеров итераторов. <code>take(n)</code> вернет итератор,
представляющий следующие <code>n</code> элементов исходного итератора. Обратите внимание,
что это не оказывает никакого влияния на оригинальный итератор. Давайте
попробуем применить его для бесконечных итераторов, которые мы упоминали раньше:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #![feature(step_by)]
for i in (1..).step_by(5).take(5) {
    println!(&quot;{}&quot;, i);
}
#}</code></pre></pre>
<p>Этот код напечатает</p>
<pre><code class="language-text">1
6
11
16
21
</code></pre>
<p><code>filter()</code> представляет собой адаптер, который принимает замыкание в качестве
аргумента. Это замыкание возвращает <code>true</code> или <code>false</code>. Новый итератор,
полученный применением <code>filter()</code>, будет выдавать только те элементы, для
которых замыкание возвращает <code>true</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
for i in (1..100).filter(|&amp;x| x % 2 == 0) {
    println!(&quot;{}&quot;, i);
}
#}</code></pre></pre>
<p>Этот пример будет печатать все четные числа от одного до ста. (Обратите
внимание, что мы используем образец <code>&amp;x</code>, чтобы извлечь само целое число. Это
необходимо, поскольку <code>filter</code> не потребляет элементы, которые выдаются во время
итерации, а лишь выдаёт ссылку.)</p>
<p>Вы можете соединить все три понятия вместе: начать с итератора, адаптировать его
несколько раз, а затем потребить результат. Например:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
(1..)
    .filter(|&amp;x| x % 2 == 0)
    .filter(|&amp;x| x % 3 == 0)
    .take(5)
    .collect::&lt;Vec&lt;i32&gt;&gt;();
#}</code></pre></pre>
<p>Этот код выдаст вектор, содержащий <code>6</code>, <code>12</code>, <code>18</code>, <code>24</code>, <code>30</code>.</p>
<p>Это просто небольшой обзор того, как итераторы, адаптеры итераторов и
потребители могут помочь вам. Уже написано множество действительно полезных
итераторов, и вы также можете написать свой собственный итератор. Итераторы
обеспечивают безопасный и эффективный способ работы со всеми видами списков.
Сперва работать с ними немного непривычно, но чем больше вы с ними
сталкиваетесь, тем больше они вас цепляют. Для получения полного списка
различных итераторов, адаптеров и потребителей смотрите
<a href="http://doc.rust-lang.org/std/iter/index.html">документацию модуля iter</a>.</p>
<p>% Многозадачность</p>
<p>Многозадачность и параллелизм являются невероятно важными проблемами в
информатике. Это актуальная тема для современной индустрии. У компьютеров все
больше и больше ядер, но многие программисты не готовы в полной мере
использовать их.</p>
<p>Средства Rust для безопасной работы с памятью в полной мере применимы и при
работе в многозадачной среде. Даже многозадачные программы на Rust должны
безопасно работать с памятью, и не создавать состояний гонок по данным. Система
типов Rust достаточно мощна, чтобы справиться с этими задачами на этапе
компиляции.</p>
<p>Прежде чем мы поговорим об особенностях многозадачности в Rust, важно понять вот
что: Rust — достаточно низкоуровневый язык, поэтому вся поддержка
многозадачности реализована в стандартной библиотеке, а не в самом языке. Это
означает, что если вам не нравится какой-то аспект реализации многозадачности в
Rust, вы всегда можете создать альтернативную библиотеку.
<a href="https://github.com/carllerche/mio">mio</a> — реально существующий пример такого
подхода.</p>
<h2><a class="header" href="#Справочная-информация-send-и-sync" id="Справочная-информация-send-и-sync">Справочная информация: <code>Send</code> и <code>Sync</code></a></h2>
<p>Рассуждать о многозадачности довольно трудно. Rust строго статически
типизирован, и это помогает нам делать выводы о коде. В связи с этим Rust
предоставляет два типажа, помогающих нам разбираться в любом коде, который
вообще может быть многозадачным.</p>
<h3><a class="header" href="#send" id="send"><code>Send</code></a></h3>
<p>Первый типаж, о котором мы будем говорить, называется
<a href="http://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a>. Когда тип <code>T</code>
реализует <code>Send</code>, это указывает компилятору, что владение переменными этого типа
можно безопасно перемещать между потоками.</p>
<p>Это важно для соблюдения некоторых ограничений. Например, это имеет значение,
когда у нас есть канал, соединяющий два потока, и мы хотим отправлять некоторые
данные по каналу из одного потока в другой. Следовательно, мы должны
гарантировать, что для отправляемого типа данных реализован типаж <code>Send</code>.</p>
<p>И наоборот, если мы оборачиваем библиотеку чужого кода (FFI), и она не является
потокобезопасной, то нам не следует реализовывать типаж <code>Send</code>, и компилятор
поможет нам убедиться в невозможности покинуть текущий поток.</p>
<h3><a class="header" href="#sync" id="sync"><code>Sync</code></a></h3>
<p>Второй из этих типажей называется
<a href="http://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>. Когда тип <code>T</code>
реализует <code>Sync</code>, это указывает компилятору, что использование переменных этого
типа не приводит к небезопасной работе с памятью в многопоточной среде.</p>
<p>Например, совместное использование неизменяемых данных с помощью атомарного
счетчика ссылок является потокобезопасным. Rust обеспечивает такой тип,
<code>Arc&lt;T&gt;</code>, и он реализует <code>Sync</code>, так что при помощи этого типа можно безопасно
обмениваться данными между потоками.</p>
<p>Эти два типажа позволяют использовать систему типов, чтобы получить надежные
гарантии о свойствах вашего кода в условиях многозадачности. Прежде чем мы
покажем, как этого достигнуть, сначала мы должны узнать, как вообще написать
многозадачную программу в Rust!</p>
<h2><a class="header" href="#Потоки" id="Потоки">Потоки</a></h2>
<p>Стандартная библиотека Rust предоставляет библиотеку многопоточности, которая
позволяет запускать код на Rust параллельно. Вот простой пример использования
<code>std::thread</code>:</p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;

fn main() {
    thread::spawn(|| {
        println!(&quot;Hello from a thread!&quot;);
    });
}
</code></pre></pre>
<p>Метод <code>thread::spawn()</code> в качестве единственного аргумента принимает замыкание,
которое выполняется в новом потоке. Он возвращает дескриптор потока, который
используется для ожидания завершения этого потока и извлечения его результата:</p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;

fn main() {
    let handle = thread::spawn(|| {
        &quot;Hello from a thread!&quot;
    });

    println!(&quot;{}&quot;, handle.join().unwrap());
}
</code></pre></pre>
<p>Многие языки имеют возможность выполнять потоки, но это дико опасно. Есть целые
книги о том, как избежать ошибок, которые происходят от совместного
использования изменяемого состояния. В Rust снова помогает система типов,
которая предотвращает гонки данных на этапе компиляции. Давайте поговорим о том,
как же на самом деле обеспечивается совместное использование чего-либо в
условиях нескольких потоков.</p>
<h2><a class="header" href="#Безопасное-совместное-использование-изменяемого-состояния" id="Безопасное-совместное-использование-изменяемого-состояния">Безопасное совместное использование изменяемого состояния</a></h2>
<p>Вчитайтесь: «безопасное совместное использование изменяемого состояния». Похоже
на ложь, не так ли? Многие программисты считают, что организовать многопоточную
работу с изменяемым состоянием очень сложно и почти невозможно. Но благодаря
системе типов Rust, это всё же правда — безопасно работать с изменяемыми данными
можно.</p>
<p>Кто-то однажды сказал это:</p>
<blockquote>
<p>Совместно используемое изменяемое состояние является корнем всех зол.
Большинство языков пытаются решить эту проблему через часть, отвечающую за
«изменяемое», но Rust решает ее через часть, отвечающую за «совместно
используемое».</p>
</blockquote>
<p>Та же самая <a href="ownership.html">система владения</a>, которая помогает предотвратить
неправильное использование указателей, также помогает исключить гонки по данным,
один из худших видов ошибок многозадачности.</p>
<p>В качестве примера приведем программу на Rust, которая входила бы в состояние
гонки по данным на многих языках. На Rust она не скомпилируется:</p>
<pre><code class="language-ignore">use std::thread;

fn main() {
    let mut data = vec![1u32, 2, 3];

    for i in 0..3 {
        thread::spawn(move || {
            data[i] += 1;
        });
    }

    thread::sleep_ms(50);
}
</code></pre>
<p>Она выдает ошибку:</p>
<pre><code class="language-text">8:17 error: capture of moved value: `data`
        data[i] += 1;
        ^~~~
</code></pre>
<p>В данном случае мы знаем, что наш код <em>должен</em> быть безопасным, но Rust в этом
не уверен. И, на самом деле, он не является безопасным: мы работаем с <code>data</code> в
каждом потоке. При этом, поток становится владельцем того, что он получает как
часть окружения замыкания. А это значит, что у нас есть три владельца! Это
плохо. Мы можем исправить это с помощью типа <code>Arc&lt;T&gt;</code>, который является
атомарным указателем со счетчиком ссылок. «Атомарный» означает, что им безопасно
обмениваться между потоками.</p>
<p>Чтобы гарантировать, что его можно безопасно использовать из нескольких потоков,
<code>Arc&lt;T&gt;</code> предполагает наличие еще одного свойства у вложенного типа. Он
предполагает, что <code>T</code> реализует типаж <code>Sync</code>. В нашем случае мы также хотим,
чтобы была возможность изменять вложенное значение. Нам нужен тип, который может
обеспечить изменение своего содержимого лишь одним пользователем одновременно.
Для этого мы можем использовать тип <code>Mutex&lt;T&gt;</code>. Вот вторая версия нашего кода.
Она по-прежнему не работает, но по другой причине:</p>
<pre><code class="language-ignore">use std::thread;
use std::sync::Mutex;

fn main() {
    let mut data = Mutex::new(vec![1u32, 2, 3]);

    for i in 0..3 {
        let data = data.lock().unwrap();
        thread::spawn(move || {
            data[i] += 1;
        });
    }

    thread::sleep_ms(50);
}
</code></pre>
<p>Вот ошибка:</p>
<pre><code class="language-text">&lt;anon&gt;:9:9: 9:22 error: the trait `core::marker::Send` is not implemented for the type `std::sync::mutex::MutexGuard&lt;'_, collections::vec::Vec&lt;u32&gt;&gt;` [E0277]
&lt;anon&gt;:11         thread::spawn(move || {
                  ^~~~~~~~~~~~~
&lt;anon&gt;:9:9: 9:22 note: `std::sync::mutex::MutexGuard&lt;'_, collections::vec::Vec&lt;u32&gt;&gt;` cannot be sent between threads safely
&lt;anon&gt;:11         thread::spawn(move || {
                  ^~~~~~~~~~~~~
</code></pre>
<p>Вы можете видеть, что <a href="http://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a> содержит метод
<a href="http://doc.rust-lang.org/std/sync/struct.Mutex.html#method.lock"><code>lock</code></a>, который имеет следующую
сигнатуру:</p>
<pre><code class="language-ignore">fn lock(&amp;self) -&gt; LockResult&lt;MutexGuard&lt;T&gt;&gt;
</code></pre>
<p>Так как типаж <code>Send</code> не был реализован для <code>MutexGuard&lt;T&gt;</code>, мы не можем
перемещать охранное значение мьютекса через границы потоков, что и сказано в
сообщении об ошибке.</p>
<p>Мы можем использовать <code>Arc&lt;T&gt;</code>, чтобы исправить это. Вот рабочая версия:</p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let data = Arc::new(Mutex::new(vec![1u32, 2, 3]));

    for i in 0..3 {
        let data = data.clone();
        thread::spawn(move || {
            let mut data = data.lock().unwrap();
            data[i] += 1;
        });
    }

    thread::sleep_ms(50);
}
</code></pre></pre>
<p>Теперь мы вызываем <code>clone()</code> для нашего <code>Arc</code>, что увеличивает внутренний
счетчик. Затем полученная ссылка перемещается в новый поток. Давайте более
подробно рассмотрим тело потока:</p>
<pre><pre class="playpen"><code class="language-rust"># use std::sync::{Arc, Mutex};
# use std::thread;
# fn main() {
#     let data = Arc::new(Mutex::new(vec![1u32, 2, 3]));
#     for i in 0..3 {
#         let data = data.clone();
thread::spawn(move || {
    let mut data = data.lock().unwrap();
    data[i] += 1;
});
#     }
#     thread::sleep_ms(50);
# }
</code></pre></pre>
<p>Во-первых, мы вызываем метод <code>lock()</code>, который захватывает блокировку мьютекса.
Так как вызов данного метода может потерпеть неудачу, он возвращает <code>Result&lt;T, E&gt;</code>, но, поскольку это просто пример, мы используем <code>unwrap()</code>, чтобы получить
ссылку на данные. Реальный код должен иметь более надежную обработку ошибок в
такой ситуации. После этого мы свободно изменяем данные, так как у нас есть
блокировка.</p>
<p>Под конец мы ждём какое-то время, пока потоки отработают. Это не идеальный
способ дождаться окончания их работы: возможно, мы выбрали разумное время
ожидания но, скорее всего, мы будем ждать либо больше чем нужно, либо меньше чем
нужно, в зависимости от того, сколько на самом деле времени потребуется
потокам, чтобы закончить вычисления.</p>
<p>Есть более точные способы синхронизации потоков, и несколько из них реализовано
в стандартной библиотеке Rust. Давайте поговорим об одном из них: каналах.</p>
<h2><a class="header" href="#Каналы" id="Каналы">Каналы</a></h2>
<p>Вот версия нашего кода, которая использует для синхронизации каналы, вместо
того, чтобы ждать в течение определенного времени:</p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::{Arc, Mutex};
use std::thread;
use std::sync::mpsc;

fn main() {
    let data = Arc::new(Mutex::new(0u32));

    let (tx, rx) = mpsc::channel();

    for _ in 0..10 {
        let (data, tx) = (data.clone(), tx.clone());

        thread::spawn(move || {
            let mut data = data.lock().unwrap();
            *data += 1;

            tx.send(());
        });
    }

    for _ in 0..10 {
        rx.recv();
    }
}
</code></pre></pre>
<p>Мы используем метод <code>mpsc::channel()</code>, чтобы создать новый канал. В этом примере
мы в каждом из десяти потоков вызываем метод <code>send</code>, который передает по каналу
пустой кортеж <code>()</code>, а затем в главном потоке ждем, пока не будут приняты все
десять значений.</p>
<p>Хотя по этому каналу посылается просто сигнал (пустой кортеж <code>()</code> не несёт
никаких данных), в общем случае мы можем отправить по каналу любое значение,
которое реализует типаж <code>Send</code>!</p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    for _ in 0..10 {
        let tx = tx.clone();

        thread::spawn(move || {
            let answer = 42u32;

            tx.send(answer);
        });
    }

   rx.recv().ok().expect(&quot;Could not receive answer&quot;);
}
</code></pre></pre>
<p><code>u32</code> реализует <code>Send</code>, потому что мы можем сделать копию. Итак, создаётся
поток, в котором вычисляется ответ, а затем этот ответ с помощью метода <code>send()</code>
передаётся обратно по каналу.</p>
<h2><a class="header" href="#Паника" id="Паника">Паника</a></h2>
<p><code>panic!</code> аварийно завершает выполняемый в данный момент поток. Вы можете
использовать потоки Rust как простой механизм изоляции:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::thread;

let result = thread::spawn(move || {
    panic!(&quot;oops!&quot;);
}).join();

assert!(result.is_err());
#}</code></pre></pre>
<p>Используемый в коде выше метод <code>join()</code> структуры <code>Thread</code> возвращает <code>Result</code>,
что позволяет нам проверить, паниковал ли поток, или он завершился нормально.</p>
<p>% Обработка ошибок</p>
<p>Как и многие языки программирования, Rust призывает разработчика определенным
способом обрабатывать ошибки. Вообще, существует два общих подхода
обработки ошибок: с помощью исключений и через возвращаемые значения. И Rust
предпочитает возвращаемые значения.</p>
<p>В этой главе мы намерены подробно изложить работу с ошибками в Rust. Более того,
мы попробуем раз за разом погружаться в обработку ошибок с различных сторон, так
что под конец у вас будет уверенное практическое представление о том, как все
это сходится воедино.</p>
<p>В наивной реализации обработка ошибок в Rust может выглядеть многословной и
раздражающей. Мы рассмотрим основные камни преткновения, а также
продемонстрируем, как сделать обработку ошибок лаконичной и удобной, пользуясь
стандартной библиотекой.</p>
<h1><a class="header" href="#Содержание" id="Содержание">Содержание</a></h1>
<p>Эта глава очень длинная, в основном потому, что мы начнем с самого начала
— рассмотрения типов-сумм (sum type) и комбинаторов, и далее попытаемся
последовательно объяснить подход Rust к обработке ошибок. Так что разработчики,
которые имеют опыт работы с другими выразительными системами типов, могут
свободно перескакивать от раздела к разделу.</p>
<ul>
<li><a href="error-handling.html#the-basics">Основы</a>
<ul>
<li><a href="error-handling.html#unwrapping-explained">Объяснение <code>unwrap</code></a></li>
<li><a href="error-handling.html#the-option-type">Тип <code>Option</code></a>
<ul>
<li><a href="error-handling.html#composing-optiont-values">Совмещение значений <code>Option&lt;T&gt;</code></a></li>
</ul>
</li>
<li><a href="error-handling.html#the-result-type">Тип <code>Result</code></a>
<ul>
<li><a href="error-handling.html#parsing-integers">Преобразование строки в число</a></li>
<li><a href="error-handling.html#the-result-type-alias-idiom">Создание псевдонима типа <code>Result</code></a></li>
</ul>
</li>
<li><a href="error-handling.html#a-brief-interlude-unwrapping-isnt-evil">Короткое отступление: <code>unwrap</code> — не обязательно зло</a></li>
</ul>
</li>
<li><a href="error-handling.html#working-with-multiple-error-types">Работа с несколькими типами ошибок</a>
<ul>
<li><a href="error-handling.html#composing-option-and-result">Совмещение <code>Option</code> и <code>Result</code></a></li>
<li><a href="error-handling.html#the-limits-of-combinators">Ограничения комбинаторов</a></li>
<li><a href="error-handling.html#early-returns">Преждевременный <code>return</code></a></li>
<li><a href="error-handling.html#the-try-macro">Макрос <code>try!</code></a></li>
<li><a href="error-handling.html#defining-your-own-error-type">Объявление собственного типа ошибки</a></li>
</ul>
</li>
<li><a href="error-handling.html#standard-library-traits-used-for-error-handling">Типажи из стандартной библиотеки, используемые для обработки ошибок</a>
<ul>
<li><a href="error-handling.html#the-error-trait">Типаж <code>Error</code></a></li>
<li><a href="error-handling.html#the-from-trait">Типаж <code>From</code></a></li>
<li><a href="error-handling.html#the-real-try-macro">Настоящий макрос <code>try!</code></a></li>
<li><a href="error-handling.html#composing-custom-error-types">Совмещение собственных типов ошибок</a></li>
<li><a href="error-handling.html#advice-for-library-writers">Рекомендации для авторов библиотек</a></li>
</ul>
</li>
<li>Практический пример: Программа для чтения демографических данных</li>
<li><a href="error-handling.html#the-short-story">Заключение</a></li>
</ul>
<p><a name="the-basics"></a></p>
<h1><a class="header" href="#Основы-1" id="Основы-1">Основы</a></h1>
<p>Обработку ошибок можно рассматривать как <em>вариативный анализ</em> того, было ли
некоторое вычисление выполнено успешно или нет. Как будет показано далее,
ключом к удобству обработки ошибок является сокращение количества явного
вариативного анализа, который должен выполнять разработчик, сохраняя при этом
код легко сочетаемым с другим кодом (composability).</p>
<p><em>(Примечание переводчика: Вариативный анализ – это один из наиболее
общеприменимых методов аналитического  мышления, который заключается в
рассмотрении проблемы, вопроса или некоторой ситуации с точки зрения каждого
возможного конкретного случая. При этом рассмотрение по отдельности каждого
такого случая является достаточным для того, чтобы решить первоначальный
вопрос.</em></p>
<p><em>Важным аспектом такого подхода к решению проблем является то, что такой анализ
должен быть исчерпывающим (exhaustive). Другими словами, при использовании
вариативного анализа должны быть рассмотрены все возможные случаи.</em></p>
<p><em>В Rust вариативный анализ реализуется с помощью синтаксической конструкции
<a href="match.html"><code>match</code></a>. При этом компилятор гарантирует, что такой анализ будет
исчерпывающим: если разработчик не рассмотрит все возможные варианты заданного
значения, программа не будет скомпилирована.)</em></p>
<p>Сохранять сочетаемость кода важно, потому что без этого требования
мы могли бы просто получать <a href="http://doc.rust-lang.org/std/macro.panic!.html"><code>panic</code></a> всякий раз,
когда мы сталкивались бы с чем-то неожиданным. (<code>panic</code> вызывает прерывание
текущего потока и, в большинстве случаев, приводит к завершению всей программы.)
Вот пример:</p>
<pre><pre class="playpen"><code class="language-rust should_panic">// Попробуйте угадать число от 1 до 10.
// Если заданное число соответствует тому, что мы загадали, возвращается true.
// В противном случае возвращается false.
fn guess(n: i32) -&gt; bool {
    if n &lt; 1 || n &gt; 10 {
        panic!(&quot;Неверное число: {}&quot;, n);
    }
    n == 5
}

fn main() {
    guess(11);
}
</code></pre></pre>
<p>Если попробовать запустить этот код, то программа аварийно завершится с
сообщением вроде этого:</p>
<pre><code class="language-text">thread '&lt;main&gt;' panicked at 'Неверное число: 11', src/bin/panic-simple.rs:6
</code></pre>
<p>Вот другой, менее надуманный пример. Программа, которая принимает число в
качестве аргумента, удваивает его значение и печатает на экране.</p>
<p><a name="code-unwrap-double"></a></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::env;

fn main() {
    let mut argv = env::args();
    let arg: String = argv.nth(1).unwrap(); // ошибка 1
    let n: i32 = arg.parse().unwrap();      // ошибка 2
    println!(&quot;{}&quot;, 2 * n);
}
</code></pre></pre>
<p>Если вы запустите эту программу без параметров (ошибка 1) или если первый
параметр будет не целым числом (ошибка 2), программа завершится паникой, так же,
как и в первом примере.</p>
<p>Обработка ошибок в подобном стиле подобна слону в посудной лавке. Слон будет
нестись в направлении, в котором ему вздумается, и крушить все на своем пути.</p>
<p><a name="unwrapping-explained"></a></p>
<h2><a class="header" href="#Объяснение-unwrap" id="Объяснение-unwrap">Объяснение <code>unwrap</code></a></h2>
<p>В предыдущем примере мы утверждали, что программа будет просто паниковать,
если будет выполнено одно из двух условий для возникновения ошибки, хотя,
в отличии от первого примера, в коде программы нет явного вызова <code>panic</code>.
Тем не менее, вызов <code>panic</code> встроен в вызов <code>unwrap</code>.</p>
<p>Вызывать <code>unwrap</code> в Rust подобно тому, что сказать: &quot;Верни мне результат
вычислений, а если произошла ошибка, просто паникуй и останавливай программу&quot;.
Мы могли бы просто показать исходный код функции <code>unwrap</code>, ведь это довольно
просто, но перед этим мы должны разобраться с типами <code>Option</code> и <code>Result</code>. Оба
этих типа имеют определенный для них метод <code>unwrap</code>.</p>
<p><a name="the-option-type"></a></p>
<h3><a class="header" href="#Тип-option" id="Тип-option">Тип <code>Option</code></a></h3>
<p>Тип <code>Option</code> <a href="http://doc.rust-lang.org/std/option/enum.Option.html">объявлен в стандартной библиотеке</a>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    None,
    Some(T),
}
#}</code></pre></pre>
<p>Тип <code>Option</code> — это способ выразить <em>возможность отсутствия</em> чего бы то ни было,
используя систему типов Rust. Выражение <em>возможности отсутствия</em> через систему
типов является важной концепцией, поскольку такой подход позволяет компилятору
требовать от разработчика обрабатывать такое отсутствие. Давайте взглянем на
пример, который пытается найти символ в строке:</p>
<p><a name="code-option-ex-string-find"></a></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Поиск Unicode-символа `needle` в `haystack`. Когда первый символ найден,
// возвращается побайтовое смещение для этого символа. Иначе возвращается `None`.
fn find(haystack: &amp;str, needle: char) -&gt; Option&lt;usize&gt; {
    for (offset, c) in haystack.char_indices() {
        if c == needle {
            return Some(offset);
        }
    }
    None
}
#}</code></pre></pre>
<p>Обратите внимание, что когда эта функция находит соответствующий символ, она
возвращает не просто <code>offset</code>. Вместо этого она возвращает <code>Some(offset)</code>.
<code>Some</code> — это вариант или <em>конструктор значения</em> для типа <code>Option</code>.
Его можно интерпретировать как функцию типа <code>fn&lt;T&gt;(value: T) -&gt; Option&lt;T&gt;</code>.
Соответственно, <code>None</code> — это также конструктор значения, только у него нет
параметров. Его можно интерпретировать как функцию типа <code>fn&lt;T&gt;() -&gt; Option&lt;T&gt;</code>.</p>
<p>Может показаться, что мы подняли много шума из ничего, но это только половина
истории. Вторая половина — это <em>использование</em> функции <code>find</code>, которую мы
написали. Давайте попробуем использовать ее, чтобы найти расширение
в имени файла.</p>
<pre><pre class="playpen"><code class="language-rust"># fn find(_: &amp;str, _: char) -&gt; Option&lt;usize&gt; { None }
fn main() {
    let file_name = &quot;foobar.rs&quot;;
    match find(file_name, '.') {
        None =&gt; println!(&quot;Расширение файла не найдено.&quot;),
        Some(i) =&gt; println!(&quot;Расширение файла: {}&quot;, &amp;file_name[i+1..]),
    }
}
</code></pre></pre>
<p>Этот код использует <a href="patterns.html">сопоставление с образцом</a> чтобы выполнить <em>вариативный
анализ</em> для возвращаемого функцией <code>find</code> значения <code>Option&lt;usize&gt;</code>. На самом
деле, вариативный анализ является единственным способом добраться до значения,
сохраненного внутри <code>Option&lt;T&gt;</code>. Это означает, что вы, как разработчик, обязаны
обработать случай, когда значение <code>Option&lt;T&gt;</code> равно <code>None</code>, а не <code>Some(t)</code>.</p>
<p>Но подождите, как насчет <code>unwrap</code>, который мы <a href="error-handling.html#code-unwrap-double"><code>до этого</code></a>
использовали? Там не было никакого вариативного анализа! Вместо этого,
вариативный анализ был перемещен внутрь метода <code>unwrap</code>. Вы можете сделать это
самостоятельно, если захотите:</p>
<p><a name="code-option-def-unwrap"></a></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Option&lt;T&gt; {
    None,
    Some(T),
}

impl&lt;T&gt; Option&lt;T&gt; {
    fn unwrap(self) -&gt; T {
        match self {
            Option::Some(val) =&gt; val,
            Option::None =&gt;
              panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}
#}</code></pre></pre>
<p>Метод <code>unwrap</code> <em>абстрагирует вариативный анализ</em>. Это именно то, что делает
<code>unwrap</code> удобным в использовании. К сожалению, <code>panic!</code> означает, что <code>unwrap</code>
неудобно сочетать с другим кодом: это слон в посудной лавке.</p>
<p><a name="composing-optiont-values"></a></p>
<h3><a class="header" href="#Совмещение-значений-optiont" id="Совмещение-значений-optiont">Совмещение значений <code>Option&lt;T&gt;</code></a></h3>
<p>В <a href="error-handling.html#code-option-ex-string-find">предыдущем примере</a> мы рассмотрели, как
можно воспользоваться <code>find</code> для того, чтобы получить расширение имени файла.
Конечно, не во всех именах файлов можно найти <code>.</code>, так что существует
вероятность, что имя некоторого файла не имеет расширения. Эта <em>возможность
отсутствия</em> интерпретируется на уровне типов через использование <code>Option&lt;T&gt;</code>.
Другими словами, компилятор заставит нас рассмотреть возможность того, что
расширение не существует. В нашем случае мы просто печатаем сообщение об этом.</p>
<p>Получение расширения имени файла — довольно распространенная операция,
так что имеет смысл вынести код в отдельную функцию:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn find(_: &amp;str, _: char) -&gt; Option&lt;usize&gt; { None }
// Возвращает расширение заданного имени файла, а именно все символы,
// идущие за первым вхождением `.` в имя файла.
// Если в `file_name` нет ни одного вхождения `.`, возвращается `None`.
fn extension_explicit(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    match find(file_name, '.') {
        None =&gt; None,
        Some(i) =&gt; Some(&amp;file_name[i+1..]),
    }
}
#}</code></pre></pre>
<p>(Подсказка: не используйте этот код. Вместо этого используйте метод
<a href="http://doc.rust-lang.org/std/path/struct.Path.html#method.extension"><code>extension</code></a> из стандартной
библиотеки.)</p>
<p>Код выглядит простым, но его важный аспект заключается в том, что функция <code>find</code>
заставляет нас рассмотреть вероятность отсутствия значения. Это хорошо,
поскольку это означает, что компилятор не позволит нам случайно забыть о том
варианте, когда в имени файла отсутствует расширение. С другой стороны, каждый
раз выполнять явный вариативный анализ, подобно тому, как мы делали это в
<code>extension_explicit</code>, может стать немного утомительным.</p>
<p>На самом деле, вариативный анализ в <code>extension_explicit</code> является очень
распространенным паттерном: если <code>Option&lt;T&gt;</code> владеет определенным значением <code>T</code>,
то выполнить его преобразование с помощью функции, а если нет — то просто
вернуть <code>None</code>.</p>
<p>Rust поддерживает параметрический полиморфизм, так что можно очень легко
объявить комбинатор, который абстрагирует это поведение:</p>
<p><a name="code-option-map"></a></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn map&lt;F, T, A&gt;(option: Option&lt;T&gt;, f: F) -&gt; Option&lt;A&gt; where F: FnOnce(T) -&gt; A {
    match option {
        None =&gt; None,
        Some(value) =&gt; Some(f(value)),
    }
}
#}</code></pre></pre>
<p>В действительности, <code>map</code> <a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.map">определен в стандартной библиотеке</a> как метод <code>Option&lt;T&gt;</code>.</p>
<p>Вооружившись нашим новым комбинатором, мы можем переписать наш метод
<code>extension_explicit</code> так, чтобы избавиться от вариативного анализа:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn find(_: &amp;str, _: char) -&gt; Option&lt;usize&gt; { None }
// Возвращает расширение заданного имени файла, а именно все символы,
// идущие за первым вхождением `.` в имя файла.
// Если в `file_name` нет ни одного вхождения `.`, возвращается `None`.
fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    find(file_name, '.').map(|i| &amp;file_name[i+1..])
}
#}</code></pre></pre>
<p>Есть еще одно поведение, которое можно часто встретить — это использование
значения по умолчанию в случае, когда значение <code>Option</code> равно <code>None</code>.
К примеру, ваша программа может считать, что расширение файла равно <code>rs</code>
в случае, если на самом деле оно отсутствует.</p>
<p>Легко представить, что этот случай вариативного анализа не специфичен
только для расширений файлов — такой подход может работать с любым <code>Option&lt;T&gt;</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn unwrap_or&lt;T&gt;(option: Option&lt;T&gt;, default: T) -&gt; T {
    match option {
        None =&gt; default,
        Some(value) =&gt; value,
    }
}
#}</code></pre></pre>
<p>Хитрость только в том, что значение по умолчанию должно иметь тот же тип, что и
значение, которое может находится внутри  <code>Option&lt;T&gt;</code>. Использование этого
метода элементарно:</p>
<pre><pre class="playpen"><code class="language-rust"># fn find(haystack: &amp;str, needle: char) -&gt; Option&lt;usize&gt; {
#     for (offset, c) in haystack.char_indices() {
#         if c == needle {
#             return Some(offset);
#         }
#     }
#     None
# }
#
# fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; {
#     find(file_name, '.').map(|i| &amp;file_name[i+1..])
# }
fn main() {
    assert_eq!(extension(&quot;foobar.csv&quot;).unwrap_or(&quot;rs&quot;), &quot;csv&quot;);
    assert_eq!(extension(&quot;foobar&quot;).unwrap_or(&quot;rs&quot;), &quot;rs&quot;);
}
</code></pre></pre>
<p>(Обратите внимание, что <code>unwrap_or</code> <a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or">объявлен как метод</a> <code>Option&lt;T&gt;</code> в
стандартной библиотеке, так что мы воспользовались им вместо функции, которую
мы объявили ранее. Не забудьте также изучить более общий метод
<a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else"><code>unwrap_or_else</code></a>).</p>
<p>Существует еще один комбинатор, на который, как мы думаем, стоит обратить
особое внимание: <code>and_then</code>. Он позволяет легко сочетать различные вычисления,
которые допускают <em>возможность отсутствия</em>. Пример — большая часть кода в
этом разделе, который связан с определением расширения заданного имени файла.
Чтобы делать это, нам для начала необходимо узнать имя файла, которое как правило
извлекается из <em>файлового пути</em>. Хотя большинство файловых путей содержат имя
файла, подобное нельзя сказать обо <em>всех</em> файловых путях. Примером могут
послужить пути <code>.</code>, <code>..</code> или <code>/</code>.</p>
<p>Таким образом, мы определили задачу нахождения расширения заданного <em>файлового
пути</em>. Начнем с явного вариативного анализа:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; { None }
fn file_path_ext_explicit(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    match file_name(file_path) {
        None =&gt; None,
        Some(name) =&gt; match extension(name) {
            None =&gt; None,
            Some(ext) =&gt; Some(ext),
        }
    }
}

fn file_name(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {
  unimplemented!() // опустим реализацию
}
#}</code></pre></pre>
<p>Можно подумать, мы могли бы просто использовать комбинатор <code>map</code>, чтобы
уменьшить вариативный анализ, но его тип не совсем подходит. Дело в том, что
<code>map</code> принимает функцию, которая делает что-то только с внутренним значением.
Результат такой функции <em>всегда</em> <a href="error-handling.html#code-option-map">оборачивается в <code>Some</code></a>.
Вместо этого, нам нужен метод, похожий <code>map</code>, но который позволяет вызывающему
передать еще один <code>Option</code>. Его общая реализация даже проще, чем <code>map</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn and_then&lt;F, T, A&gt;(option: Option&lt;T&gt;, f: F) -&gt; Option&lt;A&gt;
        where F: FnOnce(T) -&gt; Option&lt;A&gt; {
    match option {
        None =&gt; None,
        Some(value) =&gt; f(value),
    }
}
#}</code></pre></pre>
<p>Теперь мы можем переписать нашу функцию <code>file_path_ext</code> без явного вариативного
анализа:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# fn extension(file_name: &amp;str) -&gt; Option&lt;&amp;str&gt; { None }
# fn file_name(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; { None }
fn file_path_ext(file_path: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    file_name(file_path).and_then(extension)
}
#}</code></pre></pre>
<p>Тип <code>Option</code> имеет много других комбинаторов <a href="http://doc.rust-lang.org/std/option/enum.Option.html">определенных в стандартной
библиотеке</a>. Очень полезно просмотреть этот список и ознакомиться с
доступными методами — они не раз помогут вам сократить количество вариативного
анализа. Ознакомление с этими комбинаторами окупится еще и потому, что многие
из них определены с аналогичной семантикой и для типа <code>Result</code>, о котором мы
поговорим далее.</p>
<p>Комбинаторы упрощают использование типов вроде <code>Option</code>, ведь
они сокращают явный вариативный анализ. Они также соответствуют требованиям
сочетаемости, поскольку они позволяют вызывающему обрабатывать возможность
отсутствия результата собственным способом. Такие методы, как <code>unwrap</code>,
лишают этой возможности, ведь они будут паниковать в случае, когда <code>Option&lt;T&gt;</code>
равен <code>None</code>.</p>
<p><a name="the-result-type"></a></p>
<h2><a class="header" href="#Тип-result" id="Тип-result">Тип <code>Result</code></a></h2>
<p>Тип <code>Result</code> также <a href="http://doc.rust-lang.org/std/result/">определен в стандартной библиотеке</a>:</p>
<p><a name="code-result-def"></a></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
#}</code></pre></pre>
<p>Тип <code>Result</code> — это продвинутая версия <code>Option</code>. Вместо того, чтобы выражать
возможность <em>отсутствия</em>, как это делает <code>Option</code>, <code>Result</code> выражает возможность
<em>ошибки</em>. Как правило, <em>ошибки</em> необходимы для объяснения того, почему
результат определенного вычисления не был получен. Строго говоря, это более
общая форма <code>Option</code>. Рассмотрим следующий псевдоним типа, который во всех
смыслах семантически эквивалентен реальному <code>Option&lt;T&gt;</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type Option&lt;T&gt; = Result&lt;T, ()&gt;;
#}</code></pre></pre>
<p>Здесь второй параметр типа <code>Result</code> фиксируется и определяется через <code>()</code>
(произносится как &quot;unit&quot; или &quot;пустой кортеж&quot;). Тип <code>()</code> имеет ровно одно
значение — <code>()</code>. (Да, это тип и значение этого типа, которые выглядят
одинаково!)</p>
<p>Тип <code>Result</code> — это способ выразить один из двух возможных исходов вычисления.
По соглашению, один исход означает ожидаемый результат или &quot;<code>Ok</code>&quot;, в то время
как другой исход означает исключительную ситуацию или &quot;<code>Err</code>&quot;.</p>
<p>Подобно <code>Option</code>, тип <code>Result</code> имеет метод <code>unwrap</code>,
<a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap">определенный в стандартной библиотеке</a>. Давайте объявим его самостоятельно:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum Result&lt;T, E&gt; { Ok(T), Err(E) }
impl&lt;T, E: ::std::fmt::Debug&gt; Result&lt;T, E&gt; {
    fn unwrap(self) -&gt; T {
        match self {
            Result::Ok(val) =&gt; val,
            Result::Err(err) =&gt;
              panic!(&quot;called `Result::unwrap()` on an `Err` value: {:?}&quot;, err),
        }
    }
}
#}</code></pre></pre>
<p>Это фактически то же самое, что и
<a href="error-handling.html#code-option-def-unwrap">определение <code>Option::unwrap</code></a>, за исключением
того, что мы добавили значение ошибки в сообщение <code>panic!</code>. Это упрощает
отладку, но это также вынуждает нас требовать от типа-параметра <code>E</code>
(который представляет наш тип ошибки) реализации <a href="http://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a>. Поскольку
подавляющее большинство типов должны реализовывать <code>Debug</code>, обычно на практике
такое ограничение не мешает. (Реализация <code>Debug</code> для некоторого типа
просто означает, что существует разумный способ печати удобочитаемого описания
значения этого типа.)</p>
<p>Окей, давайте перейдем к примеру.</p>
<p><a name="parsing-integers"></a></p>
<h3><a class="header" href="#Преобразование-строки-в-число" id="Преобразование-строки-в-число">Преобразование строки в число</a></h3>
<p>Стандартная библиотека Rust позволяет элементарно преобразовывать строки
в целые числа. На самом деле это настолько просто, что возникает соблазн написать
что-то вроде:</p>
<pre><pre class="playpen"><code class="language-rust">fn double_number(number_str: &amp;str) -&gt; i32 {
    2 * number_str.parse::&lt;i32&gt;().unwrap()
}

fn main() {
    let n: i32 = double_number(&quot;10&quot;);
    assert_eq!(n, 20);
}
</code></pre></pre>
<p>Здесь вы должны быть скептически настроены по-поводу вызова <code>unwrap</code>.
Если строку нельзя преобразовать в число, вы получите панику:</p>
<pre><code class="language-text">thread '&lt;main&gt;' panicked at 'called `Result::unwrap()` on an `Err` value: ParseIntError { kind: InvalidDigit }', /home/rustbuild/src/rust-buildbot/slave/beta-dist-rustc-linux/build/src/libcore/result.rs:729
</code></pre>
<p>Это довольно неприятно, и если бы подобное произошло в используемой вами
библиотеке, вы могли бы небезосновательно разгневаться. Так что нам стоит
попытаться обработать ошибку в нашей функции, и пусть вызывающий сам решит что
с этим делать. Это означает необходимость изменения типа, который возвращается
<code>double_number</code>. Но на какой? Чтобы понять это, необходимо посмотреть на
сигнатуру <a href="http://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>метода parse</code></a> из стандартной библиотеки:</p>
<pre><code class="language-rust ignore">impl str {
    fn parse&lt;F: FromStr&gt;(&amp;self) -&gt; Result&lt;F, F::Err&gt;;
}
</code></pre>
<p>Хмм. По крайней мере мы знаем, что должны использовать <code>Result</code>. Вполне
возможно, что метод мог возвращать <code>Option</code>. В конце концов, строка
либо парсится как число, либо нет, не так ли? Это, конечно, разумный путь, но
внутренняя реализация знает <em>почему</em> строка не может быть преобразована в целое число.
(Это может быть пустая строка, или неправильные цифры, слишком большая или
слишком маленькая длина и т.д.) Таким образом, использование <code>Result</code> имеет
смысл, ведь мы хотим предоставить больше информации, чем просто &quot;отсутствие&quot;.
Мы хотим сказать, <em>почему</em> преобразование не удалось. Вам стоит рассуждать похожим
образом, когда вы сталкиваетесь с выбором между <code>Option</code> и <code>Result</code>.
Если вы можете предоставить подробную информацию об ошибке, то вам, вероятно,
следует это сделать. (Позже мы поговорим об этом подробнее.)</p>
<p>Хорошо, но как мы запишем наш тип возвращаемого значения? Метод <code>parse</code>
является обобщенным (generic) для всех различных типов чисел из
стандартной библиотеки. Мы могли бы (и, вероятно, должны) также сделать
нашу функцию обобщенной, но давайте пока остановимся на конкретной
реализации. Нас интересует только тип <code>i32</code>, так что нам стоит <a href="http://doc.rust-lang.org/std/primitive.i32.html">найти его
реализацию <code>FromStr</code></a> (выполните поиск в вашем
браузере по строке &quot;FromStr&quot;) и посмотреть на его <a href="associated-types.html">ассоциированный тип</a>
<code>Err</code>. Мы делаем это, чтобы определить конкретный тип ошибки. В данном
случае, это <a href="http://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>std::num::ParseIntError</code></a>.
Наконец, мы можем переписать нашу функцию:</p>
<pre><pre class="playpen"><code class="language-rust">use std::num::ParseIntError;

fn double_number(number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    match number_str.parse::&lt;i32&gt;() {
        Ok(n) =&gt; Ok(2 * n),
        Err(err) =&gt; Err(err),
    }
}

fn main() {
    match double_number(&quot;10&quot;) {
        Ok(n) =&gt; assert_eq!(n, 20),
        Err(err) =&gt; println!(&quot;Error: {:?}&quot;, err),
    }
}
</code></pre></pre>
<p>Неплохо, но нам пришлось написать гораздо больше кода! И нас опять раздражает
вариативный анализ.</p>
<p>Комбинаторы спешат на помощь! Подобно <code>Option</code>, <code>Result</code> имеет много
комбинаторов, определенных в качестве методов. Существует большой
список комбинаторов, общих между <code>Result</code> и <code>Option</code>. И <code>map</code> входит в этот
список:</p>
<pre><pre class="playpen"><code class="language-rust">use std::num::ParseIntError;

fn double_number(number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    number_str.parse::&lt;i32&gt;().map(|n| 2 * n)
}

fn main() {
    match double_number(&quot;10&quot;) {
        Ok(n) =&gt; assert_eq!(n, 20),
        Err(err) =&gt; println!(&quot;Error: {:?}&quot;, err),
    }
}
</code></pre></pre>
<p>Все ожидаемые методы реализованы для <code>Result</code>, включая
<a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or"><code>unwrap_or</code></a> и
<a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.and_then"><code>and_then</code></a>. Кроме того,
поскольку <code>Result</code> имеет второй параметр типа, существуют комбинаторы,
которые влияют только на значение ошибки, такие как
<a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"><code>map_err</code></a> (аналог <code>map</code>) и
<a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.or_else"><code>or_else</code></a> (аналог <code>and_then</code>).</p>
<p><a name="the-result-type-alias-idiom"></a></p>
<h3><a class="header" href="#Создание-псевдонима-типа-result" id="Создание-псевдонима-типа-result">Создание псевдонима типа <code>Result</code></a></h3>
<p>В стандартной библиотеке можно часто увидеть типы вроде <code>Result&lt;i32&gt;</code>.
Но постойте, ведь <a href="error-handling.html#code-result-def">мы определили <code>Result</code></a> с двумя
параметрами типа. Как мы можем обойти это, указывая только один из них? Ответ
заключается в определении псевдонима типа <code>Result</code>, который <em>фиксирует</em> один из
параметров конкретным типом. Обычно фиксируется тип ошибки. Например, наш
предыдущий пример с преобразованием строк в числа можно переписать так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::num::ParseIntError;
use std::result;

type Result&lt;T&gt; = result::Result&lt;T, ParseIntError&gt;;

fn double_number(number_str: &amp;str) -&gt; Result&lt;i32&gt; {
    unimplemented!();
}
#}</code></pre></pre>
<p>Зачем мы это делаем? Что ж, если у нас есть много функций, которые могут вернуть
<code>ParseIntError</code>, то гораздо удобнее определить псевдоним, который всегда
использует <code>ParseIntError</code>, так что мы не будем повторяться все время.</p>
<p>Самый заметный случай использования такого подхода в стандартной библиотеке —
псевдоним <a href="http://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a>. Как правило, достаточно
писать <code>io::Result&lt;T&gt;</code>, чтобы было понятно, что вы используете псевдоним типа
из модуля <code>io</code>, а не обычное определение из <code>std::result</code>. (Этот подход также
используется для <a href="http://doc.rust-lang.org/std/fmt/type.Result.html"><code>fmt::Result</code></a>)</p>
<p><a name="a-brief-interlude-unwrapping-isnt-evil"></a></p>
<h2><a class="header" href="#Короткое-отступление-unwrap--не-обязательно-зло" id="Короткое-отступление-unwrap--не-обязательно-зло">Короткое отступление: <code>unwrap</code> — не обязательно зло</a></h2>
<p>Если вы были внимательны, то возможно заметили, что я занял довольно жесткую
позицию по отношению к методам вроде <code>unwrap</code>, которые могут вызвать <code>panic</code> и
прервать исполнение вашей программы. <em>В основном</em>, это хороший совет.</p>
<p>Тем не менее, <code>unwrap</code> все-таки можно использовать разумно. Факторы, которые
оправдывают использование <code>unwrap</code>, являются несколько туманными, и разумные люди
могут со мной не согласиться. Я кратко изложу свое <em>мнение</em> по этому вопросу:</p>
<ul>
<li><strong>Примеры и &quot;грязный&quot; код.</strong> Когда вы пишете просто пример или быстрый
скрипт, обработка ошибок просто не требуется. Для подобных случаев трудно
найти что-либо удобнее чем <code>unwrap</code>, так что здесь его использование очень
привлекательно.</li>
<li><strong>Паника указывает на ошибку в программе.</strong> Если логика вашего кода
должна предотвращать определенное поведение (скажем, получение элемента из
пустого стека), то использование <code>panic</code> также допустимо. Дело в том, что в
этом случае паника будет сообщать о баге в вашей программе. Это может
происходить явно, например от неудачного вызова <code>assert!</code>, или происходить
потому, что индекс по массиву находится за пределами выделенной памяти.</li>
</ul>
<p>Вероятно, это не исчерпывающий список. Кроме того, при использовании
<code>Option</code> зачастую лучше использовать метод
<a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.expect"><code>expect</code></a>. Этот метод делает
ровно то же, что и <code>unwrap</code>, за исключением того, что в случае паники
напечатает ваше сообщение. Это позволит лучше понять причину ошибки, ведь
будет показано конкретное сообщение, а не просто &quot;called unwrap on a <code>None</code>
value&quot;.</p>
<p>Мой совет сводится к следующему: используйте здравый смысл. Есть причины, по
которым слова вроде &quot;никогда не делать X&quot; или &quot;Y считается вредным&quot; не появятся
в этой статье. У любых решений существуют компромиссы, и это ваша задача,
как разработчика, определить, что именно является приемлемым для вашего случая.
Моя цель состоит только в том, чтобы помочь вам оценить компромиссы как можно
точнее.</p>
<p>Теперь, когда мы рассмотрели основы обработки ошибок в Rust и разобрались с
<code>unwrap</code>, давайте подробнее изучим стандартную библиотеку.</p>
<p><a name="working-with-multiple-error-types"></a></p>
<h1><a class="header" href="#Работа-с-несколькими-типами-ошибок" id="Работа-с-несколькими-типами-ошибок">Работа с несколькими типами ошибок</a></h1>
<p>До этого момента мы рассматривали обработку ошибок только для случаев, когда все
сводилось либо только к <code>Option&lt;T&gt;</code>, либо только к <code>Result&lt;T, SomeError&gt;</code>.
Но что делать, когда у вас есть и <code>Option</code>, и <code>Result</code>? Или если у вас есть
<code>Result&lt;T, Error1&gt;</code> и <code>Result&lt;T, Error2&gt;</code>? Наша следующая задача — обработка
<em>композиции различных типов ошибок</em>, и это будет главной темой на протяжении
всей этой главы.</p>
<p><a name="composing-option-and-result"></a></p>
<h2><a class="header" href="#Совмещение-option-и-result" id="Совмещение-option-и-result">Совмещение <code>Option</code> и <code>Result</code></a></h2>
<p>Пока что мы говорили о комбинаторах, определенных для <code>Option</code>, и комбинаторах,
определенных для <code>Result</code>. Эти комбинаторы можно использовать для того, чтобы
сочетать результаты различных вычислений, не делая подробного вариативного
анализа.</p>
<p>Конечно, в реальном коде все происходит не так гладко. Иногда у вас
есть сочетания типов <code>Option</code> и <code>Result</code>. Должны ли мы прибегать к явному
вариативному анализу, или можно продолжить использовать комбинаторы?</p>
<p>Давайте на время вернемся к одному из первых примеров в этой главе:</p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::env;

fn main() {
    let mut argv = env::args();
    let arg: String = argv.nth(1).unwrap(); // ошибка 1
    let n: i32 = arg.parse().unwrap(); // ошибка 2
    println!(&quot;{}&quot;, 2 * n);
}
</code></pre></pre>
<p>Учитывая наши знания о типах <code>Option</code> и <code>Result</code>, а также их различных
комбинаторах, мы можем попытаться переписать этот код так, чтобы ошибки
обрабатывались должным образом, и программа не паниковала в случае ошибки.</p>
<p>Нюанс заключается в том, что <code>argv.nth(1)</code> возвращает <code>Option</code>, в
то время как <code>arg.parse()</code> возвращает <code>Result</code>. Они не могут быть скомпонованы
непосредственно. Когда вы сталкиваетесь одновременно с <code>Option</code> и<code> Result</code>,
<em>обычно</em> наилучшее решение — преобразовать <code>Option</code> в <code>Result</code>. В нашем случае,
отсутствие параметра командной строки (из <code>env::args()</code>) означает, что
пользователь не правильно вызвал программу. Мы могли бы просто использовать
<code>String</code> для описания ошибки. Давайте попробуем:</p>
<p><a name="code-error-double-string"></a></p>
<pre><pre class="playpen"><code class="language-rust">use std::env;

fn double_arg(mut argv: env::Args) -&gt; Result&lt;i32, String&gt; {
    argv.nth(1)
        .ok_or(&quot;Please give at least one argument&quot;.to_owned())
        .and_then(|arg| arg.parse::&lt;i32&gt;().map_err(|err| err.to_string()))
}

fn main() {
    match double_arg(env::args()) {
        Ok(n) =&gt; println!(&quot;{}&quot;, n),
        Err(err) =&gt; println!(&quot;Error: {}&quot;, err),
    }
}
</code></pre></pre>
<p>Раcсмотрим пару новых моментов на этом примере. Во-первых, использование
комбинатора <a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or"><code>Option::ok_or</code></a>.
Это один из способов преобразования <code>Option</code> в <code>Result</code>. Такое преобразование
требует явного определения ошибки, которую необходимо вернуть в случае, когда
значение <code>Option</code> равно <code>None</code>. Как и для всех комбинаторов, которые мы
рассматривали, его объявление очень простое:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn ok_or&lt;T, E&gt;(option: Option&lt;T&gt;, err: E) -&gt; Result&lt;T, E&gt; {
    match option {
        Some(val) =&gt; Ok(val),
        None =&gt; Err(err),
    }
}
#}</code></pre></pre>
<p>Второй новый комбинатор, который мы использовали —
<a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.map_err"><code>Result::map_err</code></a>. Это то же
самое, что и <code>Result::map</code>, за исключением того, функция применяется к
<em>ошибке</em> внутри <code>Result</code>. Если значение <code>Result</code> равно <code>Оk(...)</code>, то оно
возвращается без изменений.</p>
<p>Мы используем <code>map_err</code>, потому что нам необходимо привести все ошибки к
одинаковому типу (из-за нашего использования <code>and_then</code>). Поскольку мы решили
преобразовывать <code>Option&lt;String&gt;</code> (из <code>argv.nth(1)</code>) в <code>Result&lt;String, String&gt;</code>,
мы также обязаны преобразовывать <code>ParseIntError</code> из <code>arg.parse()</code> в <code>String</code>.</p>
<p><a name="the-limits-of-combinators"></a></p>
<h2><a class="header" href="#Ограничения-комбинаторов" id="Ограничения-комбинаторов">Ограничения комбинаторов</a></h2>
<p>Работа с IO и анализ входных данных — очень типичные задачи, и это то, чем
лично я много занимаюсь с Rust. Так что мы будем использовать IO и различные
процедуры анализа как примеры обработки ошибок.</p>
<p>Давайте начнем с простого. Поставим задачу открыть файл, прочесть все его
содержимое и преобразовать это содержимое в число. После этого нужно будет
умножить значение на <code>2</code> и распечатать результат.</p>
<p>Хоть я и пытался убедить вас не использовать <code>unwrap</code>, иногда бывает
полезным для начала написать код с <code>unwrap</code>. Это позволяет сосредоточиться
на проблеме, а не на обработке ошибок, и это выявляет места, где надлежащая
обработка ошибок необходима. Давайте начнем с того, что напишем просто
работающий код, а затем отрефакторим его для лучшей обработки ошибок.</p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; i32 {
    let mut file = File::open(file_path).unwrap(); // ошибка 1
    let mut contents = String::new();
    file.read_to_string(&amp;mut contents).unwrap();   // ошибка 2
    let n: i32 = contents.trim().parse().unwrap(); // ошибка 3
    2 * n
}

fn main() {
    let doubled = file_double(&quot;foobar&quot;);
    println!(&quot;{}&quot;, doubled);
}
</code></pre></pre>
<p>(Замечание: Мы используем <code>AsRef</code> по <a href="http://doc.rust-lang.org/std/fs/struct.File.html#method.open">тем же причинам, почему он используется в
<code>std::fs::File::open</code></a>. Это позволяет
удобно использовать любой тип строки в качестве пути к файлу.)</p>
<p>У нас есть три потенциальные ошибки, которые могут возникнуть:</p>
<ol>
<li>Проблема при открытии файла.</li>
<li>Проблема при чтении данных из файла.</li>
<li>Проблема при преобразовании данных в число.</li>
</ol>
<p>Первые две проблемы определяются типом
<a href="http://doc.rust-lang.org/std/io/struct.Error.html"><code>std::io::Error</code></a>. Мы знаем это из типа
возвращаемого значения методов
<a href="http://doc.rust-lang.org/std/fs/struct.File.html#method.open"><code>std::fs::File::open</code></a> и
<a href="http://doc.rust-lang.org/std/io/trait.Read.html#method.read_to_string"><code>std::io::Read::read_to_string</code></a>.
(Обратите внимание, что они оба используют
<a href="error-handling.html#the-result-type-alias-idiom">концепцию с псевдонимом типа <code>Result</code></a>,
описанную ранее. Если вы кликните на тип <code>Result</code>, вы
<a href="http://doc.rust-lang.org/std/io/type.Result.html">увидите псевдоним типа</a>, и следовательно, лежащий
в основе тип <code>io::Error</code>.) Третья проблема определяется типом
<a href="http://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>std::num::ParseIntError</code></a>. Кстати, тип
<code>io::Error</code> <em>часто</em> используется по всей стандартной библиотеке. Вы будете
видеть его снова и снова.</p>
<p>Давайте начнем рефакторинг функции <code>file_double</code>. Для того, чтобы эту функцию
можно было сочетать с остальным кодом, она <em>не должна</em> паниковать, если какие-либо
из перечисленных выше ошибок действительно произойдут. Фактически, это
означает, что функция должна <em>возвращать ошибку</em>, если любая из возможных
операций завершилась неудачей. Проблема состоит в том, что тип возвращаемого
значения сейчас <code>i32</code>, который не дает нам никакого разумного способа сообщить
об ошибке. Таким образом, мы должны начать с изменения типа возвращаемого
значения с <code>i32</code> на что-то другое.</p>
<p>Первое, что мы должны решить: какой из типов использовать: <code>Option</code> или
<code>Result</code>? Мы, конечно, могли бы с легкостью использовать <code>Option</code>. Если
какая-либо из трех ошибок происходит, мы могли бы просто вернуть <code>None</code>. Это
будет работать, и <em>это лучше, чем просто паниковать</em>, но мы можем сделать
гораздо лучше. Вместо этого, мы будем сообщать некоторые детали о возникшей
проблеме. Поскольку мы хотим выразить <em>возможность ошибки</em>, мы должны
использовать <code>Result&lt;i32, E&gt;</code>. Но каким должен быть тип <code>E</code>? Поскольку может
возникнуть два <em>разных</em> типа ошибок, мы должны преобразовать их к общему типу.
Одним из таких типов является <code>String</code>. Давайте посмотрим, как это отразится на
нашем коде:</p>
<pre><pre class="playpen"><code class="language-rust">use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {
    File::open(file_path)
         .map_err(|err| err.to_string())
         .and_then(|mut file| {
              let mut contents = String::new();
              file.read_to_string(&amp;mut contents)
                  .map_err(|err| err.to_string())
                  .map(|_| contents)
         })
         .and_then(|contents| {
              contents.trim().parse::&lt;i32&gt;()
                      .map_err(|err| err.to_string())
         })
         .map(|n| 2 * n)
}

fn main() {
    match file_double(&quot;foobar&quot;) {
        Ok(n) =&gt; println!(&quot;{}&quot;, n),
        Err(err) =&gt; println!(&quot;Ошибка: {}&quot;, err),
    }
}
</code></pre></pre>
<p>Выглядит немного запутанно. Может потребоваться довольно много практики,
прежде вы сможете писать такое. Написание кода в таком стиле называется
<em>следованием за типом</em>. Когда мы изменили тип возвращаемого значения
<code>file_double</code> на <code>Result&lt;i32, String&gt;</code>, нам пришлось начать подбирать
правильные комбинаторы. В данном случае мы использовали только три различных
комбинатора: <code>and_then</code>, <code>map</code> и <code>map_err</code>.</p>
<p>Комбинатор <code>and_then</code> используется для объединения по цепочке нескольких
вычислений, где каждое вычисление может вернуть ошибку. После открытия файла
есть еще два вычисления, которые могут завершиться неудачей: чтение из файла и
преобразование содержимого в число. Соответственно, имеем два вызова <code>and_then</code>.</p>
<p>Комбинатор <code>map</code> используется, чтобы применить функцию к значению <code>Ok(...)</code>
типа <code>Result</code>. Например, в самом последнем вызове, <code>map</code> умножает значение
<code>Ok(...)</code> (типа <code>i32</code>) на <code>2</code>. Если ошибка произошла до этого
момента, эта операция была бы пропущена. Это следует из определения <code>map</code>.</p>
<p>Комбинатор <code>map_err</code> — это уловка, которая позволяют всему этому заработать.
Этот комбинатор, такой же, как и <code>map</code>, за исключением того, что применяет
функцию к <code>Err(...)</code> значению <code>Result</code>. В данном случае мы хотим привести
все наши ошибки к одному типу — <code>String</code>. Поскольку как <code>io::Error</code>, так и
<code>num::ParseIntError</code> реализуют <code>ToString</code>, мы можем вызвать метод <code>to_string</code>,
чтобы выполнить преобразование.</p>
<p>Не смотря на все сказанное, код по-прежнему выглядит запутанным. Мастерство
использования комбинаторов является важным, но у них есть свои недостатки.
Давайте попробуем другой подход: преждевременный возврат.</p>
<p><a name="early-returns"></a></p>
<h2><a class="header" href="#Преждевременный-return" id="Преждевременный-return">Преждевременный <code>return</code></a></h2>
<p>Давайте возьмем код из предыдущего раздела и перепишем его с применением
<em>раннего возврата</em>. Ранний <code>return</code> позволяет выйти из функции досрочно. Мы не
можем выполнить <code>return</code> для <code>file_double</code> внутри замыкания, поэтому нам
необходимо вернуться к явному вариативному анализу.</p>
<pre><pre class="playpen"><code class="language-rust">use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {
    let mut file = match File::open(file_path) {
        Ok(file) =&gt; file,
        Err(err) =&gt; return Err(err.to_string()),
    };
    let mut contents = String::new();
    if let Err(err) = file.read_to_string(&amp;mut contents) {
        return Err(err.to_string());
    }
    let n: i32 = match contents.trim().parse() {
        Ok(n) =&gt; n,
        Err(err) =&gt; return Err(err.to_string()),
    };
    Ok(2 * n)
}

fn main() {
    match file_double(&quot;foobar&quot;) {
        Ok(n) =&gt; println!(&quot;{}&quot;, n),
        Err(err) =&gt; println!(&quot;Ошибка: {}&quot;, err),
    }
}
</code></pre></pre>
<p>Кто-то может обосновано не согласиться с тем, что этот код лучше,
чем тот, который использует комбинаторы, но если вы не знакомы с комбинаторами,
на мой взгляд, этот код будет выглядеть проще. Он выполняет явный вариативный
анализ с помощью <code>match</code> и <code>if let</code>. Если происходит ошибка, мы просто
прекращаем выполнение функции и возвращаем ошибку (после преобразования
в строку).</p>
<p>Разве это не шаг назад? Ранее мы говорили, что ключ к удобной обработке ошибок
— сокращение явного вариативного анализа, но здесь мы вернулись к тому, с чего
начинали. Оказывается, существует <em>несколько</em> способов его уменьшения.
И комбинаторы — не единственный путь.</p>
<p><a name="the-try-macro"></a></p>
<h2><a class="header" href="#Макрос-try" id="Макрос-try">Макрос <code>try!</code></a></h2>
<p>Краеугольный камень обработки ошибок в Rust — это макрос <code>try!</code>. Этот макрос
абстрагирует анализ вариантов так же, как и комбинаторы, но в отличие от них,
он также абстрагирует <em>поток выполнения</em>. А именно, он умеет абстрагировать
идею <em>досрочного возврата</em>, которую мы только что реализовали.</p>
<p>Вот упрощенное определение макроса `try!:</p>
<p><a name="code-try-def-simple"></a></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
macro_rules! try {
    ($e:expr) =&gt; (match $e {
        Ok(val) =&gt; val,
        Err(err) =&gt; return Err(err),
    });
}
#}</code></pre></pre>
<p>(<a href="http://doc.rust-lang.org/std/macro.try!.html">Реальное определение</a> выглядит немного сложнее. Мы
обсудим это далее).</p>
<p>Использование макроса <code>try!</code> может очень легко упростить наш последний
пример. Поскольку он выполняет анализ вариантов и досрочной возврат из функции,
мы получаем более плотный код, который легче читать:</p>
<pre><pre class="playpen"><code class="language-rust">use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {
    let mut file = try!(File::open(file_path).map_err(|e| e.to_string()));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents).map_err(|e| e.to_string()));
    let n = try!(contents.trim().parse::&lt;i32&gt;().map_err(|e| e.to_string()));
    Ok(2 * n)
}

fn main() {
    match file_double(&quot;foobar&quot;) {
        Ok(n) =&gt; println!(&quot;{}&quot;, n),
        Err(err) =&gt; println!(&quot;Ошибка: {}&quot;, err),
    }
}
</code></pre></pre>
<p>Вызов <code>map_err</code> по-прежнему необходим, учитывая
<a href="error-handling.html#code-try-def-simple">наше определение <code>try!</code></a>, поскольку ошибки все еще
должны быть преобразованы в <code>String</code>. Хорошей новостью является то, что в
ближайшее время мы узнаем, как убрать все эти вызовы <code>map_err</code>! Плохая новость
состоит в том, что для этого нам придется кое-что узнать о паре важных типажей
из стандартной библиотеки.</p>
<p><a name="defining-your-own-error-type"></a></p>
<h2><a class="header" href="#Объявление-собственного-типа-ошибки" id="Объявление-собственного-типа-ошибки">Объявление собственного типа ошибки</a></h2>
<p>Прежде чем мы погрузимся в аспекты некоторых типажей из стандартной библиотеки,
связанных с ошибками, я бы хотел завершить этот раздел отказом от использования
<code>String</code> как типа ошибки в наших примерах.</p>
<p>Использование <code>String</code> в том стиле, в котором мы использовали его в предыдущих
примерах удобно потому, что достаточно легко конвертировать любые ошибки в
строки, или даже создавать свои собственные ошибки на ходу. Тем не менее,
использование типа <code>String</code> для ошибок имеет некоторые недостатки.</p>
<p>Первый недостаток в том, что сообщения об ошибках, как правило, загромождают
код. Можно определять сообщения об ошибках в другом месте, но это поможет
только если вы необыкновенно дисциплинированны, поскольку очень заманчиво
вставлять сообщения об ошибках прямо в код. На самом деле, мы именно этим и
занимались в <a href="error-handling.html#code-error-double-string">предыдущем примере</a>.</p>
<p>Второй и более важный недостаток заключается в том, что использование <code>String</code>
чревато <em>потерей информации</em>. Другими словами, если все ошибки будут
преобразованы в строки, то когда мы будем возвращать их вызывающей стороне, они
не будут иметь никакого смысла. Единственное разумное, что вызывающая сторона
может сделать с ошибкой типа <code>String</code> — это показать ее пользователю.
Безусловно, можно проверить строку по значению, чтобы определить тип ошибки, но
такой подход не может похвастаться надежностью. (Правда, в гораздо большей
степени это недостаток для библиотек, чем для конечных приложений).</p>
<p>Например, тип <code>io::Error</code> включает в себя тип
<a href="http://doc.rust-lang.org/std/io/enum.ErrorKind.html"><code>io::ErrorKind</code></a>, который является
<em>структурированными данными</em>, представляющими то, что пошло не так во время
выполнения операции ввода-вывода. Это важно, поскольку может возникнуть
необходимость по-разному реагировать на различные причины ошибки. (Например,
ошибка <code>BrokenPipe</code> может изящно завершать программу, в то время как ошибка
<code>NotFound</code> будет завершать программу с кодом ошибки и показывать соответствующее
сообщение пользователю.) Благодаря <code>io::ErrorKind</code>, вызывающая сторона может
исследовать тип ошибки с помощью вариативного анализа, и это значительно лучше
попытки вычленить детали об ошибке из <code>String</code>.</p>
<p>Вместо того, чтобы использовать <code>String</code> как тип ошибки в нашем предыдущем
примере про чтение числа из файла, мы можем определить свой собственный тип,
который представляет ошибку в виде <em>структурированных данных</em>. Мы постараемся
не потерять никакую информацию от изначальных ошибок на тот случай, если
вызывающая сторона захочет исследовать детали.</p>
<p>Идеальным способом представления <em>одного варианта из многих</em> является
определение нашего собственного типа-суммы с помощью <code>enum</code>. В нашем случае,
ошибка представляет собой либо <code>io::Error</code>, либо <code>num::ParseIntError</code>, из чего
естественным образом вытекает определение:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::num;

// Мы реализуем `Debug` поскольку, по всей видимости, все типы должны реализовывать `Debug`.
// Это дает нам возможность получить адекватное и читаемое описание значения CliError
#[derive(Debug)]
enum CliError {
    Io(io::Error),
    Parse(num::ParseIntError),
}
#}</code></pre></pre>
<p>Осталось только немного подогнать наш код из примера. Вместо преобразования
ошибок в строки, мы будем просто конвертировать их в наш тип <code>CliError</code>,
используя соответствующий конструктор значения:</p>
<pre><pre class="playpen"><code class="language-rust"># #[derive(Debug)]
# enum CliError { Io(::std::io::Error), Parse(::std::num::ParseIntError) }
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, CliError&gt; {
    let mut file = try!(File::open(file_path).map_err(CliError::Io));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents).map_err(CliError::Io));
    let n: i32 = try!(contents.trim().parse().map_err(CliError::Parse));
    Ok(2 * n)
}

fn main() {
    match file_double(&quot;foobar&quot;) {
        Ok(n) =&gt; println!(&quot;{}&quot;, n),
        Err(err) =&gt; println!(&quot;Ошибка: {:?}&quot;, err),
    }
}
</code></pre></pre>
<p>Единственное изменение здесь — замена вызова <code>map_err(|e| e.to_string())</code>
(который преобразовывал ошибки в строки) на <code>map_err(CliError::Io)</code> или
<code>map_err(CliError::Parse)</code>. Теперь <em>вызывающая сторона</em> определяет уровень
детализации сообщения об ошибке для конечного пользователя. В действительности,
использование <code>String</code> как типа ошибки лишает вызывающего возможности
выбора, в то время использование собственного типа <code>enum</code>, на подобие
<code>CliError</code>, дает вызывающему тот же уровень удобства, который был ранее, и
кроме этого <em>структурированные данные</em>, описывающие ошибку.</p>
<p>Практическое правило заключается в том, что необходимо определять свой
собственный тип ошибки, а тип <code>String</code> для ошибок использовать в крайнем случае,
в основном когда вы пишете конечное приложение. Если вы пишете библиотеку,
определение своего собственного типа ошибки наиболее предпочтительно. Таким
образом, вы не лишите пользователя вашей библиотеки возможности выбирать
наиболее предпочтительное для его конкретного случая поведение.</p>
<p><a name="standard-library-traits-used-for-error-handling"></a></p>
<h1><a class="header" href="#Типажи-из-стандартной-библиотеки-используемые-для-обработки-ошибок" id="Типажи-из-стандартной-библиотеки-используемые-для-обработки-ошибок">Типажи из стандартной библиотеки, используемые для обработки ошибок</a></h1>
<p>Стандартная библиотека определяет два встроенных типажа, полезных для
обработки ошибок <a href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code></a> и
<a href="http://doc.rust-lang.org/std/convert/trait.From.html"><code>std::convert::From</code></a>. И если <code>Error</code>
разработан специально для создания общего описания ошибки, то типаж <code>From</code>
играет широкую роль в преобразовании значений между различными типами.</p>
<p><a name="the-error-trait"></a></p>
<h2><a class="header" href="#Типаж-error" id="Типаж-error">Типаж <code>Error</code></a></h2>
<p>Типаж <code>Error</code>
<a href="http://doc.rust-lang.org/std/error/trait.Error.html">объявлен в стандартной библиотеке</a>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fmt::{Debug, Display};

trait Error: Debug + Display {
  /// A short description of the error.
  fn description(&amp;self) -&gt; &amp;str;

  /// The lower level cause of this error, if any.
  fn cause(&amp;self) -&gt; Option&lt;&amp;Error&gt; { None }
}
#}</code></pre></pre>
<p>Этот типаж очень обобщенный, поскольку предполагается, что он должен быть
реализован для <em>всех</em> типов, которые представляют собой ошибки. Как мы увидим
дальше, он нам очень пригодится для написания сочетаемого кода. Этот типаж,
как минимум, позволяет выполнять следующие вещи:</p>
<ul>
<li>Получать строковое представление ошибки для разработчика (<code>Debug</code>).</li>
<li>Получать понятное для пользователя представление ошибки (<code>Display</code>).</li>
<li>Получать краткое описание ошибки (метод <code>description</code>).</li>
<li>Изучать по цепочке первопричину ошибки, если она существует (метод <code>cause</code>).</li>
</ul>
<p>Первые две возможности возникают в результате того, что типаж <code>Error</code> требует
в свою очередь реализации типажей <code>Debug</code> и <code>Display</code>. Последние два факта
исходят из двух методов, определенных в самом <code>Error</code>. Мощь <code>Еrror</code> заключается
в том, что все существующие типы ошибок его реализуют, что в свою очередь
означает что любые ошибки могут быть сохранены как
<a href="trait-objects.html">типажи-объекты</a> (trait
object). Обычно это выглядит как <code>Box&lt;Error&gt;</code>, либо <code>&amp;Error</code>. Например, метод
<code>cause</code> возвращает <code>&amp;Error</code>, который как раз является типажом-объектом. Позже мы
вернемся к применению <code>Error</code> как типажа-объекта.</p>
<p>В настоящее время достаточно показать пример, реализующий типаж <code>Error</code>.
Давайте воспользуемся для этого типом ошибки, который мы определили в
<a href="error-handling.html#defining-your-own-error-type">предыдущем разделе</a>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::num;

// Мы реализуем `Debug` поскольку, по всей видимости, все типы должны реализовывать `Debug`.
// Это дает нам возможность получить адекватное и читаемое описание значения CliError
#[derive(Debug)]
enum CliError {
    Io(io::Error),
    Parse(num::ParseIntError),
}
#}</code></pre></pre>
<p>Данный тип ошибки отражает возможность возникновения двух других типов ошибок:
ошибка работы с IО или ошибка преобразования строки в число. Определение ошибки может
отражать столько других видов ошибок, сколько необходимо, за счет добавления
новых вариантов в объявлении <code>enum</code>.</p>
<p>Реализация <code>Error</code> довольно прямолинейна и главным образом состоит из явного
анализа вариантов:</p>
<pre><code class="language-rust ignore">use std::error;
use std::fmt;

impl fmt::Display for CliError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match *self {
            // Оба изначальных типа ошибок уже реализуют `Display`,
            // так что мы можем использовать их реализации
            CliError::Io(ref err) =&gt; write!(f, &quot;IO error: {}&quot;, err),
            CliError::Parse(ref err) =&gt; write!(f, &quot;Parse error: {}&quot;, err),
        }
    }
}

impl error::Error for CliError {
    fn description(&amp;self) -&gt; &amp;str {
        // Оба изначальных типа ошибок уже реализуют `Error`,
        // так что мы можем использовать их реализацией
        match *self {
            CliError::Io(ref err) =&gt; err.description(),
            CliError::Parse(ref err) =&gt; err.description(),
        }
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {
        match *self {
            // В обоих случаях происходит неявное преобразование значения `err`
            // из конкретного типа (`&amp;io::Error` или `&amp;num::ParseIntError`)
            // в типаж-обьект `&amp;Error`. Это работает потому что оба типа реализуют `Error`.
            CliError::Io(ref err) =&gt; Some(err),
            CliError::Parse(ref err) =&gt; Some(err),
        }
    }
}
</code></pre>
<p>Хочется отметить, что это очень типичная реализация <code>Error</code>: реализация
методов <code>description</code> и <code>cause</code> в соответствии с каждым возможным видом ошибки.</p>
<p><a name="the-from-trait"></a></p>
<h2><a class="header" href="#Типаж-from" id="Типаж-from">Типаж <code>From</code></a></h2>
<p>Типаж <code>std::convert::From</code> объявлен в
<a href="http://doc.rust-lang.org/std/convert/trait.From.html">стандартной библиотеке</a>:</p>
<p><a name="code-from-def"></a></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
trait From&lt;T&gt; {
    fn from(T) -&gt; Self;
}
#}</code></pre></pre>
<p>Очень просто, не правда ли? Типаж <code>From</code> чрезвычайно полезен, поскольку
создает общий подход для преобразования <em>из</em> определенного типа <code>Т</code> в какой-то
другой тип (в данном случае, &quot;другим типом&quot; является тип, реализующий данный
типаж, или <code>Self</code>). Самое важное в типаже <code>From</code> — <a href="http://doc.rust-lang.org/std/convert/trait.From.html">множество его реализаций,
предоставляемых стандартной библиотекой</a>.</p>
<p>Вот несколько простых примеров, демонстрирующих работу <code>From</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let string: String = From::from(&quot;foo&quot;);
let bytes: Vec&lt;u8&gt; = From::from(&quot;foo&quot;);
let cow: ::std::borrow::Cow&lt;str&gt; = From::from(&quot;foo&quot;);
#}</code></pre></pre>
<p>Итак, <code>From</code> полезен для выполнения преобразований между строками. Но как
насчет ошибок? Оказывается, существует одна важная реализация:</p>
<pre><code class="language-rust ignore">impl&lt;'a, E: Error + 'a&gt; From&lt;E&gt; for Box&lt;Error + 'a&gt;
</code></pre>
<p>Эта реализация говорит, что <em>любой</em> тип, который реализует <code>Error</code>, можно
конвертировать в типаж-объект <code>Box&lt;Error&gt;</code>. Выглядит не слишком впечатляюще, но
это очень полезно в общем контексте.</p>
<p>Помните те две ошибки, с которыми мы имели дело ранее, а именно, <code>io::Error</code>
and <code>num::ParseIntError</code>? Поскольку обе они реализуют <code>Error</code>, они также
работают с <code>From</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::error::Error;
use std::fs;
use std::io;
use std::num;

// Получаем значения ошибок
let io_err: io::Error = io::Error::last_os_error();
let parse_err: num::ParseIntError = &quot;not a number&quot;.parse::&lt;i32&gt;().unwrap_err();

// Собственно, конвертация
let err1: Box&lt;Error&gt; = From::from(io_err);
let err2: Box&lt;Error&gt; = From::from(parse_err);
#}</code></pre></pre>
<p>Здесь нужно разобрать очень важный паттерн. Переменные <code>err1</code> и <code>err2</code> имеют
<em>одинаковый тип</em> — типаж-объект. Это означает, что их реальные типы
скрыты от компилятора, так что по факту он рассматривает <code>err1</code> и <code>err2</code> как
одинаковые сущности. Кроме того, мы создали <code>err1</code> и <code>err2</code>, используя один и
тот же вызов функции — <code>From::from</code>. Мы можем так делать, поскольку функция
<code>From::from</code> перегружена по ее аргументу и возвращаемому типу.</p>
<p>Эта возможность очень важна для нас, поскольку она решает нашу предыдущую
проблему, позволяя эффективно конвертировать разные ошибки в один и тот же тип,
пользуясь только одной функцией.</p>
<p>Настало время вернуться к нашему старому другу — макросу <code>try!</code>.</p>
<p><a name="the-real-try-macro"></a></p>
<h2><a class="header" href="#Настоящий-макрос-try" id="Настоящий-макрос-try">Настоящий макрос <code>try!</code></a></h2>
<p>До этого мы привели такое определение <code>try!</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
macro_rules! try {
    ($e:expr) =&gt; (match $e {
        Ok(val) =&gt; val,
        Err(err) =&gt; return Err(err),
    });
}
#}</code></pre></pre>
<p>Но это не настоящее определение. Реальное определение можно найти
в <a href="http://doc.rust-lang.org/std/macro.try!.html">стандартной библиотеке</a>:</p>
<p><a name="code-try-def"></a></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
macro_rules! try {
    ($e:expr) =&gt; (match $e {
        Ok(val) =&gt; val,
        Err(err) =&gt; return Err(::std::convert::From::from(err)),
    });
}
#}</code></pre></pre>
<p>Здесь есть одно маленькое, но очень важное изменение: значение ошибки
пропускается через вызов <code>From::from</code>. Это делает макрос <code>try!</code> очень мощным
инструментом, поскольку он дает нам возможность бесплатно выполнять
автоматическое преобразование типов.</p>
<p>Вооружившись более мощным макросом <code>try!</code>, давайте взглянем на код, написанный
нами ранее, который читает файл и конвертирует его содержимое в число:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, String&gt; {
    let mut file = try!(File::open(file_path).map_err(|e| e.to_string()));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents).map_err(|e| e.to_string()));
    let n = try!(contents.trim().parse::&lt;i32&gt;().map_err(|e| e.to_string()));
    Ok(2 * n)
}
#}</code></pre></pre>
<p>Ранее мы говорили, что мы можем избавиться от вызовов <code>map_err</code>. На самом деле,
все что мы должны для этого сделать — это найти тип, который работает с
<code>From</code>. Как мы увидели в предыдущем разделе, <code>From</code> имеет реализацию, которая
позволяет преобразовать любой тип ошибки в <code>Box&lt;Error&gt;</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::error::Error;
use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, Box&lt;Error&gt;&gt; {
    let mut file = try!(File::open(file_path));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents));
    let n = try!(contents.trim().parse::&lt;i32&gt;());
    Ok(2 * n)
}
#}</code></pre></pre>
<p>Мы уже очень близки к идеальной обработке ошибок. Наш код имеет очень мало
накладных расходов из-за обработки ошибок, ведь макрос <code>try!</code> инкапсулирует
сразу три вещи:</p>
<ol>
<li>Вариативный анализ.</li>
<li>Поток выполнения.</li>
<li>Преобразование типов ошибок.</li>
</ol>
<p>Когда все эти три вещи объединены вместе, мы получаем код, который не
обременен комбинаторами, вызовами <code>unwrap</code> или постоянным анализом вариантов.</p>
<p>Но осталась одна маленькая деталь: тип <code>Box&lt;Error&gt;</code> <em>не несет никакой
информации</em>. Если мы возвращаем <code>Box&lt;Error&gt;</code> вызывающей стороне, нет никакой
возможности (легко) узнать базовый тип ошибки. Ситуация, конечно, лучше, чем
со <code>String</code>, поскольку появилась возможность вызывать методы, вроде
<a href="http://doc.rust-lang.org/std/error/trait.Error.html#tymethod.description"><code>description</code></a> или
<a href="http://doc.rust-lang.org/std/error/trait.Error.html#method.cause"><code>cause</code></a>, но ограничение
остается: <code>Box&lt;Error&gt;</code> не предоставляет никакой информации о сути ошибки. (Замечание:
Это не совсем верно, поскольку в Rust есть инструменты рефлексии во время
выполнения, которые полезны при некоторых сценариях, но их рассмотрение
<a href="https://crates.io/crates/error">выходит за рамки этой главы</a>).</p>
<p>Настало время вернуться к нашему собственному типу <code>CliError</code> и связать все
в одно целое.</p>
<p><a name="composing-custom-error-types"></a></p>
<h2><a class="header" href="#Совмещение-собственных-типов-ошибок" id="Совмещение-собственных-типов-ошибок">Совмещение собственных типов ошибок</a></h2>
<p>В последнем разделе мы рассмотрели реальный макрос <code>try!</code> и то, как он
выполняет автоматическое преобразование значений ошибок с помощью вызова
<code>From::from</code>. В нашем случае мы конвертировали ошибки в <code>Box&lt;Error&gt;</code>, который
работает, но его значение скрыто для вызывающей стороны.</p>
<p>Чтобы исправить это, мы используем средство, с которым мы уже знакомы:
создание собственного типа ошибки. Давайте вспомним код, который считывает
содержимое файла и преобразует его в целое число:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::fs::File;
use std::io::{self, Read};
use std::num;
use std::path::Path;

// Мы реализуем `Debug` поскольку, по всей видимости, все типы должны реализовывать `Debug`.
// Это дает нам возможность получить адекватное и читаемое описание значения CliError
#[derive(Debug)]
enum CliError {
    Io(io::Error),
    Parse(num::ParseIntError),
}

fn file_double_verbose&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, CliError&gt; {
    let mut file = try!(File::open(file_path).map_err(CliError::Io));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents).map_err(CliError::Io));
    let n: i32 = try!(contents.trim().parse().map_err(CliError::Parse));
    Ok(2 * n)
}
#}</code></pre></pre>
<p>Обратите внимание, что здесь у нас еще остались вызовы <code>map_err</code>. Почему?
Вспомните определения <a href="error-handling.html#code-try-def"><code>try!</code></a> и <a href="error-handling.html#code-from-def"><code>From</code></a>.
Проблема в том, что не существует такой реализации <code>From</code>, которая позволяет
конвертировать типы ошибок <code>io::Error</code> и <code>num::ParseIntError</code> в наш собственный
тип <code>CliError</code>. Но мы можем легко это исправить! Поскольку мы определили тип
<code>CliError</code>, мы можем также реализовать для него типаж <code>From</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #[derive(Debug)]
# enum CliError { Io(io::Error), Parse(num::ParseIntError) }
use std::io;
use std::num;

impl From&lt;io::Error&gt; for CliError {
    fn from(err: io::Error) -&gt; CliError {
        CliError::Io(err)
    }
}

impl From&lt;num::ParseIntError&gt; for CliError {
    fn from(err: num::ParseIntError) -&gt; CliError {
        CliError::Parse(err)
    }
}
#}</code></pre></pre>
<p>Все эти реализации позволяют <code>From</code> создавать значения <code>CliError</code> из других
типов ошибок. В нашем случае такое создание состоит из простого вызова
конструктора значения. <em>Как правило</em>, это все что нужно.</p>
<p>Наконец, мы можем переписать <code>file_double</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# use std::io;
# use std::num;
# enum CliError { Io(::std::io::Error), Parse(::std::num::ParseIntError) }
# impl From&lt;io::Error&gt; for CliError {
#     fn from(err: io::Error) -&gt; CliError { CliError::Io(err) }
# }
# impl From&lt;num::ParseIntError&gt; for CliError {
#     fn from(err: num::ParseIntError) -&gt; CliError { CliError::Parse(err) }
# }

use std::fs::File;
use std::io::Read;
use std::path::Path;

fn file_double&lt;P: AsRef&lt;Path&gt;&gt;(file_path: P) -&gt; Result&lt;i32, CliError&gt; {
    let mut file = try!(File::open(file_path));
    let mut contents = String::new();
    try!(file.read_to_string(&amp;mut contents));
    let n: i32 = try!(contents.trim().parse());
    Ok(2 * n)
}
#}</code></pre></pre>
<p>Единственное, что мы сделали — это удалили вызовы <code>map_err</code>. Они нам больше не
нужны, поскольку макрос <code>try!</code> выполняет <code>From::from</code> над значениями ошибок. И
это работает, поскольку мы предоставили реализации <code>From</code> для всех типов
ошибок, которые могут возникнуть.</p>
<p>Если бы мы изменили нашу функцию <code>file_double</code> таким образом, чтобы она начала
выполнять какие-то другие операции, например, преобразовать строку в число
с плавающей точкой, то мы должны были бы добавить новый вариант к нашему типу
ошибок:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::io;
use std::num;

enum CliError {
    Io(io::Error),
    ParseInt(num::ParseIntError),
    ParseFloat(num::ParseFloatError),
}
#}</code></pre></pre>
<p>И добавить новую реализацию для <code>From</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# enum CliError {
#     Io(::std::io::Error),
#     ParseInt(num::ParseIntError),
#     ParseFloat(num::ParseFloatError),
# }

use std::num;

impl From&lt;num::ParseFloatError&gt; for CliError {
    fn from(err: num::ParseFloatError) -&gt; CliError {
        CliError::ParseFloat(err)
    }
}
#}</code></pre></pre>
<p>Вот и все!</p>
<p><a name="advice-for-library-writers"></a></p>
<h2><a class="header" href="#Рекомендации-для-авторов-библиотек" id="Рекомендации-для-авторов-библиотек">Рекомендации для авторов библиотек</a></h2>
<p>Если в вашей библиотеке могут возникать специфические ошибки, то вы наверняка
должны определить для них свой собственный тип. На ваше усмотрение вы можете
сделать его внутреннее представление публичным (как
<a href="http://doc.rust-lang.org/std/io/enum.ErrorKind.html"><code>ErrorKind</code></a>), или оставить его скрытым
(подобно <a href="http://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>ParseIntError</code></a>). Независимо
от того, что вы предпримете, считается хорошим тоном обеспечить по крайней
мере некоторую информацию об ошибке помимо ее строкового представления. Но,
конечно, все зависит от конкретных случаев использования.</p>
<p>Как минимум, вы скорее всего должны реализовать типаж
<a href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a>. Это даст пользователям вашей
библиотеки некоторую минимальную гибкость при
<a href="error-handling.html#the-real-try-macro">совмещении ошибок</a>. Реализация типажа <code>Error</code> также
означает, что пользователям гарантируется возможность получения строкового
представления ошибки (это следует из необходимости реализации <code>fmt::Debug</code> и
<code>fmt::Display</code>).</p>
<p>Кроме того, может быть полезным реализовать <code>From</code> для ваших типов ошибок. Это
позволит вам (как автору библиотеки) и вашим пользователям
<a href="error-handling.html#composing-custom-error-types">совмещать более детальные ошибки</a>. Например,
<a href="http://burntsushi.net/rustdoc/csv/enum.Error.html"><code>csv::Error</code></a> реализует
<code>From</code> для <code>io::Error</code> и <code>byteorder::Error</code>.</p>
<p>Наконец, на свое усмотрение, вы также можете определить
<a href="error-handling.html#the-result-type-alias-idiom">псевдоним типа <code>Result</code></a>, особенно, если в вашей
библиотеке определен только один тип ошибки. Такой подход используется в
стандартной библиотеке для <a href="http://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a> и
<a href="http://doc.rust-lang.org/std/fmt/type.Result.html"><code>fmt::Result</code></a>.</p>
<p><a name="the-short-story"></a></p>
<h1><a class="header" href="#Заключение-3" id="Заключение-3">Заключение</a></h1>
<p>Поскольку это довольно длинная глава, не будет лишним составить короткий
конспект по обработке ошибок в Rust. Ниже будут приведены некоторые практические
рекомендации. Это совсем <em>не</em> заповеди. Наверняка существуют веские
причины для того, чтобы нарушить любое из этих правил.</p>
<ul>
<li>Если вы пишете короткий пример кода, который может быть перегружен обработкой
ошибок, это, вероятно, отличная возможность использовать <code>unwrap</code> (будь-то
<a href="http://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap"><code>Result::unwrap</code></a>,
<a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap"><code>Option::unwrap</code></a> или
<a href="http://doc.rust-lang.org/std/option/enum.Option.html#method.expect"><code>Option::expect</code></a>).
Те, для кого предназначен пример, должны осознавать, что необходимо
реализовать надлежащую обработку ошибок. (Если нет, отправляйте их сюда!)</li>
<li>Если вы пишете одноразовую программу, также не зазорно использовать <code>unwrap</code>.
Но будьте внимательны: если ваш код попадет в чужие руки, не удивляйтесь, если
кто-то будет расстроен из-за скудных сообщений об ошибках!</li>
<li>Если вы пишете одноразовый код, но вам все-равно стыдно из-за использования
<code>unwrap</code>, воспользуйтесь либо <code>String</code> в качестве типа ошибки, либо
<code>Box&lt;Error + Send + Sync&gt;</code> (из-за
<a href="http://doc.rust-lang.org/std/convert/trait.From.html">доступных реализаций <code>From</code></a>.)</li>
<li>В остальных случаях, определяйте свои собственные типы ошибок с
соответствующими реализациями <a href="http://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> и
<a href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a>, делая использование
<a href="http://doc.rust-lang.org/std/macro.try!.html"><code>try!</code></a> более удобным.</li>
<li>Если вы пишете библиотеку и ваш код может выдавать ошибки, определите ваш
собственный тип ошибки и реализуйте типаж
<a href="http://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code></a>. Там, где это уместно,
реализуйте <a href="http://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>, чтобы вам и вашим
пользователям было легче с ними работать. (Из-за правил когерентности в Rust,
пользователи вашей библиотеки не смогут реализовать <code>From</code> для ваших ошибок,
поэтому это должна сделать ваша библиотека.)</li>
<li>Изучите комбинаторы, определенные для
<a href="http://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a> и
<a href="http://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a>. Писать код, пользуясь только ними
может быть немного утомительно, но я лично нашел для себя хороший баланс
между использованием <code>try!</code> и комбинаторами (<code>and_then</code>, <code>map</code> и <code>unwrap_or</code>
— мои любимые).</li>
</ul>
<p>% Выбор гарантий</p>
<p>Одна из важных черт языка Rust — это то, что он позволяет нам управлять
накладными расходами и гарантиями программы.</p>
<p>В стандартной библиотеке Rust есть различные «обёрточные типы», которые
реализуют множество компромиссов между накладными расходами, эргономикой, и
гарантиями. Многие позволяют выбирать между проверками во время компиляции и
проверками во время исполнения. Эта глава подробно объяснит несколько избранных
абстракций.</p>
<p>Перед тем, как продолжить, крайне рекомендуем познакомиться с
<a href="ownership.html">владением</a> и <a href="references-and-borrowing.html">заимствованием</a> в Rust.</p>
<h1><a class="header" href="#Основные-типы-указателей" id="Основные-типы-указателей">Основные типы указателей</a></h1>
<h2><a class="header" href="#boxt" id="boxt"><code>Box&lt;T&gt;</code></a></h2>
<p><a href="https://doc.rust-lang.org/stable/std/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a> — «владеющий» указатель, или, по-другому, «упаковка». Хотя он и
может выдавать ссылки на содержащиеся в нём данные, он — единственный владелец
этих данных. В частности, когда происходит что-то вроде этого:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = Box::new(1);
let y = x;
// x больше не доступен
#}</code></pre></pre>
<p>Здесь упаковка была <em>перемещена</em> в <code>y</code>. Поскольку <code>x</code> больше не владеет ею, с
этого момента компилятор не позволит использовать <code>x</code>. Упаковка также может быть
перемещена <em>из</em> функции — для этого функция возвращает её как свой результат.</p>
<p>Когда упаковка, которая не была перемещена, выходит из области видимости,
выполняются деструкторы. Эти деструкторы освобождают содержащиеся данные.</p>
<p>Мы абстрагируемся от динамического выделения памяти, и это абстракция без
накладных расходов. Это идеальный способ выделить память в куче и безопасно
передавать указатель на эту память. Заметьте, что вы можете создавать ссылки на
упаковку по обычным правилам заимствования, которые проверяются во время
компиляции.</p>
<h2><a class="header" href="#t-и-mut-t" id="t-и-mut-t"><code>&amp;T</code> и <code>&amp;mut T</code></a></h2>
<p>Это неизменяемые и изменяемые ссылки, соответственно. Они реализуют шаблон
«read-write lock», т.е. вы можете создать или одну изменяемую ссылку на данные,
или любое число неизменяемых, но не оба вида ссылок одновременно. Эта гарантия
проверяется во время компиляции, и ничего не стоит во время исполнения. В
большинстве случаев эти два типа указателей покрывают все нужды по передаче
дешёвых ссылок между частями кода.</p>
<p>При копировании эти указатели сохраняют связанное с ними время жизни — они всё
равно не могут прожить дольше, чем исходное значение, на которое они ссылаются.</p>
<h2><a class="header" href="#const-t-и-mut-t" id="const-t-и-mut-t"><code>*const T</code> и <code>*mut T</code></a></h2>
<p>Это сырые указатели в стиле C, не имеющие связанной информации о времени жизни и
владельце. Они просто указывают на какое-то место в памяти, без дополнительных
ограничений. Они гарантируют только то, что они могут быть разыменованы только в
коде, помеченном как «небезопасный».</p>
<p>Они полезны при создании безопасных низкоуровневых абстракций вроде <code>Vec&lt;T&gt;</code>, но
их следует избегать в безопасном коде.</p>
<h2><a class="header" href="#rct" id="rct"><code>Rc&lt;T&gt;</code></a></h2>
<p>Это первая рассматриваемая обёртка, использование которой влечёт за собой
накладные расходы во время исполнения.</p>
<p><a href="https://doc.rust-lang.org/stable/std/rc/struct.Rc.html"><code>Rc&lt;T&gt;</code></a> — это указатель со счётчиком ссылок. Другими словами, он позволяет
создавать несколько «владеющих» указателей на одни и те же данные, и эти данные
будут уничтожены, когда все указатели выйдут из области видимости.</p>
<p>Собственно, внутри у него счётчик ссылок (reference count, или сокращённо
refcount), который увеличивается каждый раз, когда происходит клонирование <code>Rc</code>,
и уменьшается когда <code>Rc</code> выходит из области видимости. Основная ответственность
<code>Rc&lt;T&gt;</code> — удостовериться в том, что для разделяемых данных вызываются
деструкторы.</p>
<p>Хранимые данные при этом неизменяемы, и если создаётся цикл ссылок, данные
утекут. Если нам нужно отсутствие утечек в присутствие циклов, нужно
использовать сборщик мусора.</p>
<h4><a class="header" href="#Гарантии" id="Гарантии">Гарантии</a></h4>
<p>Здесь главная гарантия в том, что данные не будут уничтожены, пока все ссылки на
них не исчезнут.</p>
<p>Счётчик ссылок нужно использовать, когда мы хотим динамически выделить какие-то
данные и предоставить ссылки на эти данные только для чтения, и при этом неясно,
какая часть программы последней закончит использование ссылки. Это подходящая
альтернатива <code>&amp;T</code>, когда невозможно статически доказать правильность <code>&amp;T</code>, или
когда это создаёт слишком большие неудобства в написании кода, на который
разработчик не хочет тратить своё время.</p>
<p>Этот указатель <em>не</em> является потокобезопасным, и Rust не позволяет передавать
его или делиться им с другими потоками. Это позволяет избежать накладных
расходов от использования атомарных операций там, где они не нужны.</p>
<p>Есть похожий умный указатель, <code>Weak&lt;T&gt;</code>. Это невладеющий, но и не заимствуемый,
умный указатель. Он тоже похож на <code>&amp;T</code>, но не ограничен временем жизни —
<code>Weak&lt;T&gt;</code> можно не отпускать. Однако, возможна ситуация, когда попытка доступа к
хранимым в нём данным провалится и вернёт <code>None</code>, поскольку <code>Weak&lt;T&gt;</code> может
пережить владеющие <code>Rc</code>. Его удобно использовать в случае циклических структур
данных и некоторых других.</p>
<h4><a class="header" href="#Накладные-расходы" id="Накладные-расходы">Накладные расходы</a></h4>
<p>Что касается памяти, <code>Rc&lt;T&gt;</code> — это одно выделение, однако оно будет включать
два лишних слова (т.е. два значения типа <code>usize</code>) по сравнению с обычным
<code>Box&lt;T&gt;</code>. Это верно и для «сильных», и для «слабых» счётчиков ссылок.</p>
<p>Расходы на <code>Rc&lt;T&gt;</code> заключаются в увеличении и уменьшении счётчика ссылок каждый
раз, когда <code>Rc&lt;T&gt;</code> клонируется или выходит из области видимости, соответственно.
Отметим, что клонирование не выполняет глубокое копирование, а просто
увеличивает счётчик и возвращает копию <code>Rc&lt;T&gt;</code>.</p>
<h1><a class="header" href="#Типы-ячейки-cell-types" id="Типы-ячейки-cell-types">Типы-ячейки (cell types)</a></h1>
<p>Типы <code>Cell</code> предоставляют «внутреннюю» изменяемость. Другими словами, они
содержат данные, которые можно изменять даже если тип не может быть получен в
изменяемом виде (например, когда он за указателем <code>&amp;</code> или за <code>Rc&lt;T&gt;</code>).</p>
<p><a href="https://doc.rust-lang.org/stable/std/cell/">Документация модуля <code>cell</code> довольно хорошо объясняет эти вещи</a>.</p>
<p>Эти типы <em>обычно</em> используют в полях структур, но они не ограничены таким
использованием.</p>
<h2><a class="header" href="#cellt" id="cellt"><code>Cell&lt;T&gt;</code></a></h2>
<p><a href="https://doc.rust-lang.org/stable/std/cell/struct.Cell.html"><code>Cell&lt;T&gt;</code></a> — это тип, который обеспечивает внутреннюю изменяемость без
накладных расходов, но только для типов, реализующих типаж <code>Copy</code>. Поскольку
компилятор знает, что все данные, вложенные в <code>Cell&lt;T&gt;</code>, находятся на стеке, их
можно просто заменять без страха утечки ресурсов.</p>
<p>Нарушить инварианты с помощью этой обёртки всё равно можно, поэтому будьте
осторожны при её использовании. Если поле обёрнуто в <code>Cell</code>, это индикатор того,
что эти данные изменяемы и поле может не сохранить своё значение с момента
чтения до момента его использования.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::cell::Cell;

let x = Cell::new(1);
let y = &amp;x;
let z = &amp;x;
x.set(2);
y.set(3);
z.set(4);
println!(&quot;{}&quot;, x.get());
#}</code></pre></pre>
<p>Заметьте, что здесь мы смогли изменить значение через различные ссылки без права
изменения.</p>
<p>В плане затрат во время исполнения, такой код аналогичен нижеследующему:</p>
<pre><code class="language-rust ignore">let mut x = 1;
let y = &amp;mut x;
let z = &amp;mut x;
x = 2;
*y = 3;
*z = 4;
println!(&quot;{}&quot;, x);
</code></pre>
<p>но имеет преимущество в том, что он действительно компилируется.</p>
<h4><a class="header" href="#Гарантии-1" id="Гарантии-1">Гарантии</a></h4>
<p>Этот тип ослабляет правило отсутствия совпадающих указателей с правом записи
там, где оно не нужно. Однако, он также ослабляет гарантии, которые
предоставляет такое ограничение; поэтому если ваши инварианты зависят от данных,
хранимых в <code>Cell</code>, будьте осторожны.</p>
<p>Это применяется при изменении примитивов и других типов, реализующих <code>Copy</code>,
когда нет лёгкого способа сделать это в соответствии с статическими правилами
<code>&amp;</code> и <code>&amp;mut</code>.</p>
<p><code>Cell</code> не позволяет получать внутренние ссылки на данные, что позволяет безопасно
менять его содержимое.</p>
<h4><a class="header" href="#Накладные-расходы-1" id="Накладные-расходы-1">Накладные расходы</a></h4>
<p>Накладные расходы при использовании <code>Cell&lt;T&gt;</code> отсутствуют, однако если вы
оборачиваете в него большие структуры, есть смысл вместо этого обернуть
отдельные поля, поскольку иначе каждая запись будет производить полное
копирование структуры.</p>
<h2><a class="header" href="#refcellt" id="refcellt"><code>RefCell&lt;T&gt;</code></a></h2>
<p><a href="https://doc.rust-lang.org/stable/std/cell/struct.RefCell.html"><code>RefCell&lt;T&gt;</code></a> также предоставляет внутреннюю изменяемость, но не
ограничен только типами, реализующими <code>Copy</code>.</p>
<p>Однако, у этого решения есть накладные расходы. <code>RefCell&lt;T&gt;</code> реализует шаблон
«read-write lock» во время исполнения, а не во время компиляции, как <code>&amp;T</code>/
<code>&amp;mut T</code>. Он похож на однопоточный мьютекс. У него есть функции <code>borrow()</code> и
<code>borrow_mut()</code>, которые изменяют внутренний счётчик ссылок и возвращают умный
указатель, который может быть разыменован без права изменения или с ним,
соответственно. Счётчик ссылок восстанавливается, когда умные указатели выходят
из области видимости. С этой системой мы можем динамически гарантировать, что во
время заимствования с правом изменения никаких других ссылок на значение больше
нет. Если программист пытается позаимствовать значение в этот момент, поток
запаникует.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::cell::RefCell;

let x = RefCell::new(vec![1,2,3,4]);
{
    println!(&quot;{:?}&quot;, *x.borrow())
}

{
    let mut my_ref = x.borrow_mut();
    my_ref.push(1);
}
#}</code></pre></pre>
<p>Как и <code>Cell</code>, это в основном применяется в ситуациях, когда сложно или
невозможно удовлетворить статическую проверку заимствования. В целом мы знаем,
что такие изменения не будут происходить вложенным образом, но это стоит
дополнительно проверить.</p>
<p>Для больших, сложных программ, есть смысл положить некоторые вещи в <code>RefCell</code>,
чтобы упростить работу с ними. Например, многие словари в структуре <code>ctxt</code><a href="../rustc/middle/ty/struct.ctxt.html">ctxt</a>
в компиляторе Rust обёрнуты в этот тип. Они изменяются только однажды — во
время создания, но не во время инициализации, или несколько раз в явно отдельных
местах. Однако, поскольку эта структура повсеместно используется везде,
жонглирование изменяемыми и неизменяемыми указателями было бы очень сложным (или
невозможным), и наверняка создало бы мешанину указателей <code>&amp;</code>, которую сложно
было бы расширять. С другой стороны, <code>RefCell</code> предоставляет дешёвый (но не
бесплатный) способ обращаться к таким данным. В будущем, если кто-то добавит
код, который пытается изменить ячейку, пока она заимствована, это вызовет
панику, источник которой можно отследить. И такая паника обычно происходит
детерминированно.</p>
<p>Похожим образом, в DOM Servo много изменения данных, большая часть которого
происходит внутри типа DOM, но часть выходит за его границы и изменяет
произвольные вещи. Использование <code>RefCell</code> и <code>Cell</code> для ограждения этих
изменений позволяет нам избежать необходимости беспокоиться об изменяемости
везде, и одновременно обозначает места, где изменение <em>действительно</em>
происходит.</p>
<p>Заметьте, что стоит избегать использования <code>RefCell</code>, если возможно достаточно
простое решение с помощью указателей <code>&amp;</code>.</p>
<h4><a class="header" href="#Гарантии-2" id="Гарантии-2">Гарантии</a></h4>
<p><code>RefCell</code> ослабляет <em>статические</em> ограничения, предотвращающие совпадение
изменяемых указателей, и заменяет их на <em>динамические</em> ограничения. Сами
гарантии при этом не изменяются.</p>
<h4><a class="header" href="#Накладные-расходы-2" id="Накладные-расходы-2">Накладные расходы</a></h4>
<p><code>RefCell</code> не выделяет память, но содержит дополнительный индикатор «состояния
заимствования» (размером в одно слово) вместе с данными.</p>
<p>Во время исполнения каждое заимствование вызывает изменение и проверку счётчика
ссылок.</p>
<h1><a class="header" href="#Синхронизированные-типы" id="Синхронизированные-типы">Синхронизированные типы</a></h1>
<p>Многие из вышеперечисленных типов не могут быть использованы потокобезопасным
образом. В частности, <code>Rc&lt;T&gt;</code> и <code>RefCell&lt;T&gt;</code>, оба из которых используют
не-атомарные счётчики ссылок, не могут быть использованы так. (<em>Атомарные</em>
счётчики ссылок — это такие, которые могут быть увеличены из нескольких
потоков, не вызывая при этом гонку данных.) Благодаря этому они привносят меньше
накладных расходов, но нам также потребуются и потокобезопасные варианты этих
типов. Они существуют — это <code>Arc&lt;T&gt;</code> и <code>Mutex&lt;T&gt;</code>/<code>RWLock&lt;T&gt;</code>.</p>
<p>Заметьте, что не-потокобезопасные типы <em>не могут</em> быть переданы между потоками,
и это проверяется во время компиляции.</p>
<p>В модуле <a href="https://doc.rust-lang.org/stable/std/sync/index.html">sync</a> много полезных обёрточных типов для многопоточного
программирования, но мы затронем только главные из них.</p>
<h2><a class="header" href="#arct" id="arct"><code>Arc&lt;T&gt;</code></a></h2>
<p><a href="https://doc.rust-lang.org/stable/std/sync/struct.Arc.html"><code>Arc&lt;T&gt;</code></a> — это вариант <code>Rc&lt;T&gt;</code>, который использует атомарный счётчик
ссылок (поэтому «Arc»). Его можно свободно передавать между потоками.</p>
<p><code>shared_ptr</code> из C++ похож на <code>Arc</code>, но в случае C++ вложенные данные всегда
изменяемы. Чтобы получить семантику, похожую на семантику C++, нужно
использовать <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>, <code>Arc&lt;RwLock&lt;T&gt;&gt;</code>, или <code>Arc&lt;UnsafeCell&lt;T&gt;&gt;</code><sup class="footnote-reference"><a href="#4">1</a></sup>.
(<code>UnsafeCell&lt;T&gt;</code> — это тип-ячейка, который может содержать любые данные и не
имеет накладных расходов, но доступ к его содержимому производится только внутри
небезопасных блоков.) Последний стоит использовать только тогда, когда мы
уверены в том, что наша работа не вызовет нарушения безопасности памяти.
Учитывайте, что запись в структуру не атомарна, а многие функции вроде
<code>vec.push()</code> могут выделять память заново в процессе работы, и тем самым
вызывать небезопасное поведение.</p>
<div class="footnote-definition" id="4"><sup class="footnote-definition-label">1</sup>
<p>На самом деле, <code>Arc&lt;UnsafeCell&lt;T&gt;&gt;</code> не скомпилируется, поскольку
<code>UnsafeCell&lt;T&gt;</code> не реализует <code>Send</code> или <code>Sync</code>, но мы можем обернуть его в
тип и реализовать для него <code>Send</code>/<code>Sync</code> вручную, чтобы получить
<code>Arc&lt;Wrapper&lt;T&gt;&gt;</code>, где <code>Wrapper</code> — это <code>struct Wrapper&lt;T&gt;(UnsafeCell&lt;T&gt;)</code>.</p>
</div>
<h4><a class="header" href="#Гарантии-3" id="Гарантии-3">Гарантии</a></h4>
<p>Как и <code>Rc</code>, этот тип гарантирует, что деструктор хранимых в нём данных будет
вызван, когда последний <code>Arc</code> выходит из области видимости (за исключением
случаев с циклами). В отличие от <code>Rc</code>, <code>Arc</code> предоставляет эту гарантию и в
многопоточном окружении.</p>
<h4><a class="header" href="#Накладные-расходы-3" id="Накладные-расходы-3">Накладные расходы</a></h4>
<p>Накладные расходы увеличиваются по сравнению с <code>Rc</code>, т.к. теперь для изменения
счётчика ссылок используются атомарные операции (которые происходят каждый раз
при клонировании или выходе из области видимости). Когда вы хотите поделиться
данными в пределах одного потока, предпочтительнее использовать простые ссылки
<code>&amp;</code>.</p>
<h2><a class="header" href="#mutext-and-rwlockt" id="mutext-and-rwlockt"><code>Mutex&lt;T&gt;</code> and <code>RwLock&lt;T&gt;</code></a></h2>
<p><a href="https://doc.rust-lang.org/stable/std/sync/struct.Mutex.html"><code>Mutex&lt;T&gt;</code></a> и <a href="https://doc.rust-lang.org/stable/std/sync/struct.RwLock.html"><code>RwLock&lt;T&gt;</code></a> предоставляют механизм
взаимоисключения с помощью охранных значений RAII. Охранные значения — это
объекты, имеющие некоторое состояние, как замок, пока не выполнится их
деструктор. В обоих случаях, мьютекс непрозрачен, пока на нём не вызовут
<code>lock()</code>, после чего поток остановится до момента, когда мьютекс может быть
закрыт, после чего возвращается охранное значение. Оно может быть использовано
для доступа к вложенным данным с правом изменения, а мьютекс будет снова открыт,
когда охранное значение выйдет из области видимости.</p>
<pre><code class="language-rust ignore">{
    let guard = mutex.lock();
    // охранное значение разыменовывается в изменяемое значение
    // вложенного в мьютекс типа
    *guard += 1;
} // мьютекс открывается когда выполняется деструктор
</code></pre>
<p><code>RwLock</code> имеет преимущество — он эффективно работает в случае множественных
чтений. Ведь читать из общих данных всегда безопасно, пока в эти данные никто не
хочет писать; и <code>RwLock</code> позволяет читающим получить «право чтения». Право
чтения может быть получено многими потоками одновременно, и за читающими следит
счётчик ссылок. Тот же, кто хочет записать данные, должен получить «право
записи», а оно может быть получено только когда все читающие вышли из области
видимости.</p>
<h4><a class="header" href="#Гарантии-4" id="Гарантии-4">Гарантии</a></h4>
<p>Оба этих типа предоставляют безопасное изменение данных из разных потоков, но не
защищают от взаимной блокировки (deadlock). Некоторая дополнительная
безопасность протокола работы с данными может быть получена с помощью системы
типов.</p>
<h4><a class="header" href="#Накладные-расходы-4" id="Накладные-расходы-4">Накладные расходы</a></h4>
<p>Для поддержания состояния прав чтения и записи эти типы используют в своей
реализации конструкции, похожие на атомарные типы, и они довольно дороги. Они
могут блокировать все межпроцессорные чтения из памяти, пока не закончат работу.
Ожидание возможности закрытия этих примитивов синхронизации тоже может быть
медленным, когда производится много одновременных попыток доступа к данным.</p>
<h1><a class="header" href="#Сочетание" id="Сочетание">Сочетание</a></h1>
<p>Распространённая жалоба на код на Rust — это сложность чтения типов вроде
<code>Rc&lt;RefCell&lt;Vec&lt;T&gt;&gt;&gt;</code> (или ещё более сложных сочетаний похожих типов). Не всегда
понятно, что делает такая комбинация, или почему автор решил использовать именно
такой тип. Не ясно и то, в каких случаях сам программист должен использовать
похожие сочетания типов.</p>
<p>Обычно, вам понадобятся такие типы, когда вы хотите сочетать гарантии разных
типов, но не хотите переплачивать за то, что вам не нужно.</p>
<p>Например, одно из таких сочетаний — это <code>Rc&lt;RefCell&lt;T&gt;&gt;</code>. Сам по себе <code>Rc&lt;T&gt;</code>
не может быть разыменован с правом изменения; поскольку <code>Rc&lt;T&gt;</code> позволяет
делиться данными и одновременная попытка изменения данных может привести к
небезопасному поведению, мы кладём внутрь <code>RefCell&lt;T&gt;</code>, чтобы получить
динамическую проверку одновременных попыток изменения. Теперь у нас есть
разделяемые изменяемые данные, но одновременный доступ к ним предоставляется
только на чтение, а запись всегда исключительна.</p>
<p>Далее мы можем развить эту мысль и получить <code>Rc&lt;RefCell&lt;Vec&lt;T&gt;&gt;&gt;</code> или
<code>Rc&lt;Vec&lt;RefCell&lt;T&gt;&gt;&gt;</code>. Это — изменяемые, разделяемые между потоками вектора,
но они не одинаковы.</p>
<p>В первом типе <code>RefCell&lt;T&gt;</code> оборачивает <code>Vec&lt;T&gt;</code>, поэтому изменяем весь <code>Vec&lt;T&gt;</code>
целиком. В то же время, это значит, что в каждый момент времени может быть
только одна ссылка на <code>Vec&lt;T&gt;</code> с правом изменения. Поэтому код не может
одновременно работать с разными элементами вектора, обращаясь к ним через разные
<code>Rc</code>. Однако, мы сможем добавлять и удалять элементы вектора в произвольные
моменты времени. Этот тип похож на <code>&amp;mut Vec&lt;T&gt;</code>, с тем различием, что проверка
заимствования делается во время исполнения.</p>
<p>Во втором типе заимствуются отдельные элементы, а вектор в целом неизменяем.
Поэтому мы можем получить ссылки на отдельные элементы, но не можем добавлять
или удалять элементы. Это похоже на <code>&amp;mut [T]</code><sup class="footnote-reference"><a href="#3">2</a></sup>, но, опять-таки, проверка
заимствования производится во время исполнения.</p>
<p>В многопоточных программах возникает похожая ситуация с <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>, который
обеспечивает разделяемое владение и одновременное изменение.</p>
<p>Когда вы читаете такой код, рассматривайте гарантии и накладные расходы каждого
вложенного типа шаг за шагом.</p>
<p>Когда вы выбираете сложный тип, поступайте наоборот: решите, какие гарантии вам
нужны, и в каком «слое» сочетания они понадобятся. Например, если у вас стоит
выбор между <code>Vec&lt;RefCell&lt;T&gt;&gt;</code> и <code>RefCell&lt;Vec&lt;T&gt;&gt;</code>, найдите компромисс путём
рассуждений, как мы делали выше по тексту, и выберите нужный вам тип.</p>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">2</sup>
<p><code>&amp;[T]</code> и <code>&amp;mut [T]</code> — это <em>срезы</em>; они состоят из указателя и длины, и
могут ссылаться на часть вектора или массива. <code>&amp;mut [T]</code> также позволяет
изменять свои элементы, но его длину изменить нельзя.</p>
</div>
<p>% Интерфейс внешних функций (foreign function interface)</p>
<h1><a class="header" href="#Введение" id="Введение">Введение</a></h1>
<p>В данном руководстве в качестве примера мы будем использовать
<a href="https://github.com/google/snappy">snappy</a>, библиотеку для сжатия/распаковки
данных. Мы реализуем Rust-интерфейс к этой библиотеке через вызов внешних
функций. Rust в настоящее время не в состоянии делать вызовы напрямую в
библиотеки C++, но snappy включает в себя интерфейс C (документирован в
<a href="https://github.com/google/snappy/blob/master/snappy-c.h"><code>snappy-c.h</code></a>).</p>
<p>Ниже приведен минимальный пример вызова внешней функции, который будет
скомпилирован при условии, что библиотека snappy установлена:</p>
<pre><code class="language-no_run"># #![feature(libc)]
extern crate libc;
use libc::size_t;

#[link(name = &quot;snappy&quot;)]
extern {
    fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;
}

fn main() {
    let x = unsafe { snappy_max_compressed_length(100) };
    println!(&quot;максимальный размер сжатого буфера длиной 100 байт: {}&quot;, x);
}
</code></pre>
<p>Блок <code>extern</code> содержит список сигнатур функций из внешней библиотеки, в данном
случае для C ABI (application binary interface; двоичный интерфейс приложений)
данной платформы. Чтобы указать, что программу нужно компоновать с библиотекой
snappy, используется атрибут <code>#[link(...)]</code>. Благодаря этому, символы будут
успешно разрешены.</p>
<p>Предполагается, что внешние функции могут быть небезопасными, поэтому их вызовы
должны быть обёрнуты в блок <code>unsafe {}</code> как обещание компилятору, что все внутри
этого блока в действительности безопасно. Библиотеки C часто предоставляют
интерфейсы, которые не являются потоко-безопасными. И почти любая функция,
которая принимает в качестве аргумента указатель, не может принимать любое
входное значений, поскольку указатель может быть висячим; сырые указатели
выходят за пределы безопасной модели памяти в Rust.</p>
<p>При объявлении типов аргументов для внешней функции, компилятор Rust не может
проверить, является ли данное объявление корректным. Поэтому важно правильно
указать тип привязываемой функции — иначе ошибка обнаружится только во время
исполнения.</p>
<p>Блок <code>extern</code> может быть распространён на весь API snappy:</p>
<pre><code class="language-no_run"># #![feature(libc)]
extern crate libc;
use libc::{c_int, size_t};

#[link(name = &quot;snappy&quot;)]
extern {
    fn snappy_compress(input: *const u8,
                       input_length: size_t,
                       compressed: *mut u8,
                       compressed_length: *mut size_t) -&gt; c_int;
    fn snappy_uncompress(compressed: *const u8,
                         compressed_length: size_t,
                         uncompressed: *mut u8,
                         uncompressed_length: *mut size_t) -&gt; c_int;
    fn snappy_max_compressed_length(source_length: size_t) -&gt; size_t;
    fn snappy_uncompressed_length(compressed: *const u8,
                                  compressed_length: size_t,
                                  result: *mut size_t) -&gt; c_int;
    fn snappy_validate_compressed_buffer(compressed: *const u8,
                                         compressed_length: size_t) -&gt; c_int;
}
# fn main() {}
</code></pre>
<h1><a class="header" href="#Создание-безопасного-интерфейса" id="Создание-безопасного-интерфейса">Создание безопасного интерфейса</a></h1>
<p>Сырой C API (application programming interface; интерфейс программирования
приложений) необходимо обернуть, чтобы обеспечить безопасность памяти. Тогда мы
сможем использовать концепции более высокого уровня, такие как векторы.
Библиотека может выборочно открывать только безопасный, высокоуровневый
интерфейс и скрывать небезопасные внутренние детали.</p>
<p>Оборачивание функций, которые принимают в качестве входных параметров буферы,
включает в себя использование модуля <code>slice::raw</code> для управления векторами Rust
как указателями на память. Векторы Rust представляют собой гарантированно
непрерывный блок памяти. Длина — это количество элементов, которое в настоящее
время содержится в векторе, а ёмкость — общее количество выделенной памяти в
элементах. Длина меньше или равна ёмкости.</p>
<pre><pre class="playpen"><code class="language-rust"># #![feature(libc)]
# extern crate libc;
# use libc::{c_int, size_t};
# unsafe fn snappy_validate_compressed_buffer(_: *const u8, _: size_t) -&gt; c_int { 0 }
# fn main() {}
pub fn validate_compressed_buffer(src: &amp;[u8]) -&gt; bool {
    unsafe {
        snappy_validate_compressed_buffer(src.as_ptr(), src.len() as size_t) == 0
    }
}
</code></pre></pre>
<p>Обёртка <code>validate_compressed_buffer</code> использует блок <code>unsafe</code>, но это
гарантирует, что её вызов будет безопасен для всех входных данных, поскольку
модификатор <code>unsafe</code> отсутствует в сигнатуре функции. Т.е. небезопасность скрыта
внутри функции и не видна вызывающему.</p>
<p>Функции <code>snappy_compress</code> и <code>snappy_uncompress</code> являются более сложными, так как
должен быть выделен буфер для хранения выходных данных.</p>
<p>Функция <code>snappy_max_compressed_length</code> может быть использована для выделения
вектора максимальной ёмкости, требуемой для хранения сжатых выходных данных.
Затем этот вектор может быть передан в функцию <code>snappy_compress</code> в качестве
выходного параметра. Ещё один параметр передается, чтобы получить настоящую
длину после сжатия и установить соответствующую длину вектора.</p>
<pre><pre class="playpen"><code class="language-rust"># #![feature(libc)]
# extern crate libc;
# use libc::{size_t, c_int};
# unsafe fn snappy_compress(a: *const u8, b: size_t, c: *mut u8,
#                           d: *mut size_t) -&gt; c_int { 0 }
# unsafe fn snappy_max_compressed_length(a: size_t) -&gt; size_t { a }
# fn main() {}
pub fn compress(src: &amp;[u8]) -&gt; Vec&lt;u8&gt; {
    unsafe {
        let srclen = src.len() as size_t;
        let psrc = src.as_ptr();

        let mut dstlen = snappy_max_compressed_length(srclen);
        let mut dst = Vec::with_capacity(dstlen as usize);
        let pdst = dst.as_mut_ptr();

        snappy_compress(psrc, srclen, pdst, &amp;mut dstlen);
        dst.set_len(dstlen as usize);
        dst
    }
}
</code></pre></pre>
<p>Распаковка аналогична, потому что snappy хранит размер несжатых данных как часть
формата сжатия, и <code>snappy_uncompressed_length</code> будет возвращать точный размер
необходимого буфера.</p>
<pre><pre class="playpen"><code class="language-rust"># #![feature(libc)]
# extern crate libc;
# use libc::{size_t, c_int};
# unsafe fn snappy_uncompress(compressed: *const u8,
#                             compressed_length: size_t,
#                             uncompressed: *mut u8,
#                             uncompressed_length: *mut size_t) -&gt; c_int { 0 }
# unsafe fn snappy_uncompressed_length(compressed: *const u8,
#                                      compressed_length: size_t,
#                                      result: *mut size_t) -&gt; c_int { 0 }
# fn main() {}
pub fn uncompress(src: &amp;[u8]) -&gt; Option&lt;Vec&lt;u8&gt;&gt; {
    unsafe {
        let srclen = src.len() as size_t;
        let psrc = src.as_ptr();

        let mut dstlen: size_t = 0;
        snappy_uncompressed_length(psrc, srclen, &amp;mut dstlen);

        let mut dst = Vec::with_capacity(dstlen as usize);
        let pdst = dst.as_mut_ptr();

        if snappy_uncompress(psrc, srclen, pdst, &amp;mut dstlen) == 0 {
            dst.set_len(dstlen as usize);
            Some(dst)
        } else {
            None // SNAPPY_INVALID_INPUT
        }
    }
}
</code></pre></pre>
<p>Для справки, примеры, используемые здесь, также доступны в библиотеке на
<a href="https://github.com/thestinger/rust-snappy">GitHub</a>.</p>
<h1><a class="header" href="#Деструкторы" id="Деструкторы">Деструкторы</a></h1>
<p>Внешние библиотеки часто передают владение ресурсами в вызывающий код. Когда это
происходит, мы должны использовать деструкторы Rust, чтобы обеспечить
безопасность и гарантировать освобождение этих ресурсов (особенно в случае
паники).</p>
<p>Чтобы получить более подробную информацию о деструкторах, смотрите
<a href="http://doc.rust-lang.org/std/ops/trait.Drop.html">типаж Drop</a>.</p>
<h1><a class="header" href="#Обратные-вызовы-функций-rust-кодом-на-c-callbacks-from-c-code-to-rust" id="Обратные-вызовы-функций-rust-кодом-на-c-callbacks-from-c-code-to-rust">Обратные вызовы функций Rust кодом на C (Callbacks from C code to Rust</a></h1>
<h1><a class="header" href="#functions" id="functions">functions)</a></h1>
<p>Некоторые внешние библиотеки требуют использование обратных вызовов для передачи
вызывающей стороне отчета о своем текущем состоянии или промежуточных данных. Во
внешнюю библиотеку можно передавать функции, которые были определены в Rust. При
создании функции обратного вызова, которую можно вызывать из C кода, необходимо
указать для нее спецификатор <code>extern</code>, за которым следует подходящее соглашение
о вызове.</p>
<p>Затем функция обратного вызова может быть передана в библиотеку C через
регистрационный вызов, и уже затем может быть вызвана оттуда.</p>
<p>Простой пример:</p>
<p>Код на Rust:</p>
<pre><code class="language-no_run">extern fn callback(a: i32) {
    println!(&quot;Меня вызывают из C со значением {0}&quot;, a);
}

#[link(name = &quot;extlib&quot;)]
extern {
   fn register_callback(cb: extern fn(i32)) -&gt; i32;
   fn trigger_callback();
}

fn main() {
    unsafe {
        register_callback(callback);
        trigger_callback(); // Активация функции обратного вызова
    }
}
</code></pre>
<p>Код на C:</p>
<pre><code class="language-c">typedef void (*rust_callback)(int32_t);
rust_callback cb;

int32_t register_callback(rust_callback callback) {
    cb = callback;
    return 1;
}

void trigger_callback() {
  cb(7); // Вызовет callback(7) в Rust
}
</code></pre>
<p>В этом примере функция <code>main()</code> в Rust вызовет функцию <code>trigger_callback()</code> в C,
которая, в свою очередь, выполнит обратный вызов функции <code>callback()</code> в Rust.</p>
<h2><a class="header" href="#Обратные-вызовы-адресованные-объектам-rust-targeting-callbacks-to-rust" id="Обратные-вызовы-адресованные-объектам-rust-targeting-callbacks-to-rust">Обратные вызовы, адресованные объектам Rust (Targeting callbacks to Rust</a></h2>
<h2><a class="header" href="#objects" id="objects">objects)</a></h2>
<p>Предыдущий пример показал, как глобальная функция может быть вызвана из C кода.
Однако зачастую желательно, чтобы обратный вызов был адресован конкретному
объекту в Rust. Это может быть объект, который представляет собой обертку для
соответствующего объекта C.</p>
<p>Такое поведение может быть достигнуто путем передачи небезопасного указателя на
объект в библиотеку C. После чего библиотека C сможет передавать указатель на
объект Rust при обратном вызове. Это позволит получить небезопасный доступ к
объекту Rust, на которой сослались в обратном вызове.</p>
<p>Код на Rust:</p>
<pre><code class="language-no_run">#[repr(C)]
struct RustObject {
    a: i32,
    // другие поля
}

extern &quot;C&quot; fn callback(target: *mut RustObject, a: i32) {
    println!(&quot;Меня вызывают из C со значением {0}&quot;, a);
    unsafe {
        // Меняем значение в RustObject на значение, полученное через функцию обратного вызова
        (*target).a = a;
    }
}

#[link(name = &quot;extlib&quot;)]
extern {
   fn register_callback(target: *mut RustObject,
                        cb: extern fn(*mut RustObject, i32)) -&gt; i32;
   fn trigger_callback();
}

fn main() {
    // Создаём объект, на который будем ссылаться в функции обратного вызова
    let mut rust_object = Box::new(RustObject { a: 5 });

    unsafe {
        register_callback(&amp;mut *rust_object, callback);
        trigger_callback();
    }
}
</code></pre>
<p>Код на C:</p>
<pre><code class="language-c">typedef void (*rust_callback)(void*, int32_t);
void* cb_target;
rust_callback cb;

int32_t register_callback(void* callback_target, rust_callback callback) {
    cb_target = callback_target;
    cb = callback;
    return 1;
}

void trigger_callback() {
  cb(cb_target, 7); // Вызовет callback(&amp;rustObject, 7) в Rust
}
</code></pre>
<h2><a class="header" href="#Асинхронные-обратные-вызовы" id="Асинхронные-обратные-вызовы">Асинхронные обратные вызовы</a></h2>
<p>В приведённых примерах обратные вызовы выполняются как непосредственная реакция
на вызов функции внешней библиотеки на C. Для выполнения обратного вызова поток
исполнения переключался из Rust в C, а затем снова в Rust, но, в конце концов,
обратный вызов выполнялся в том же потоке, из которого была вызвана функция,
инициировавшая обратный вызов.</p>
<p>Более сложная ситуация — это когда внешняя библиотека порождает свои собственные
потоки и осуществляет обратные вызовы из них. В этих случаях доступ к структурам
данных Rust из обратных вызовов особенно опасен, и поэтому нужно использовать
соответствующие механизмы синхронизации. Помимо классических механизмов
синхронизации, таких как мьютексы, в Rust есть еще одна возможность:
использовать каналы (<code>std::sync::mpsc::channel</code>), чтобы направить данные из
потока C, который выполнял обратный вызов, в поток Rust.</p>
<p>Если асинхронный обратный вызов адресован конкретному объекту в адресном
пространстве Rust, то необходимо, чтобы обратные вызовы не выполнялись
библиотекой C после уничтожения этого объекта Rust. Для этого следует,
во-первых, проектировать библиотеку таким образом, чтобы отмена регистрации
обратного вызова гарантировала, что он больше не будет выполняться. Во-вторых,
нужно отменить регистрацию обратного вызова в деструкторе объекта Rust, которому
адресован обратный вызов.</p>
<h1><a class="header" href="#Компоновка" id="Компоновка">Компоновка</a></h1>
<p>Атрибут <code>link</code> для блоков <code>extern</code> предоставляет <code>rustc</code> основные инструкции
относительно того, как он должен компоновать нативные библиотеки. На данный
момент есть две общепринятых формы записи атрибута <code>link</code>:</p>
<ul>
<li><code>#[link(name = &quot;foo&quot;)]</code></li>
<li><code>#[link(name = &quot;foo&quot;, kind = &quot;bar&quot;)]</code></li>
</ul>
<p>В обоих этих случаях <code>foo</code> — это имя нативной библиотеки, с которой мы
компонуемся. Во втором случае <code>bar</code> — это тип нативной библиотеки, с которой
происходит компоновка. В настоящее время <code>rustc</code> известны три типа нативных
библиотек:</p>
<ul>
<li>Динамические — <code>#[link(name = &quot;readline&quot;)]</code></li>
<li>Статические — <code>#[link(name = &quot;my_build_dependency&quot;, kind = &quot;static&quot;)]</code></li>
<li>Фреймворки — <code>#[link(name = &quot;CoreFoundation&quot;, kind = &quot;framework&quot;)]</code></li>
</ul>
<p>Обратите внимание, что фреймворки доступны только для OSX.</p>
<p>Различные значения <code>kind</code> нужны, чтобы определить, как компоновать нативную
библиотеку. С точки зрения компоновки, компилятор Rust создает две разновидности
артефактов: промежуточный (rlib/статическая библиотека) и конечный (динамическая
библиотека/исполняемый файл). (Прим. переводчика: rlib — это формат статической
библиотеки с метаданными в формате Rust) Зависимости от нативных динамических
библиотек и фреймворков распространяются дальше, пока не дойдут до конечного
артефакта, а от статических библиотек — нет.</p>
<p>Вот несколько примеров того, как эта модель может быть использована:</p>
<ul>
<li>
<p>Нативная зависимость при сборке. Иногда написанный на Rust код необходимо
состыковать с некоторым кодом на C/C++, но распространение C/C++ кода в формате
библиотеки вызывает дополнительные трудности. В этом случае, код будут
упакован в <code>libfoo.a</code>, а затем контейнер Rust должен будет объявить
зависимость с помощью <code>#[link(name = &quot;foo&quot;, kind = &quot;static&quot;)]</code>.</p>
<p>Независимо от типа результата (промежуточный или конечный) контейнера,
нативная статическая библиотека будет включена в него на выходе, поэтому нет
необходимости в распространении этой нативной статической библиотеки отдельно.</p>
</li>
<li>
<p>Обычная динамическая зависимость. Общие системные библиотеки (такие, как
<code>readline</code>) доступны на большом количестве систем, и статическую копию этих
библиотек часто сложно найти. Когда такая зависимость включена в контейнер
Rust, промежуточные артефакты (например, rlib'ы) не будут компоноваться с
библиотекой, но когда rlib включается в состав конечного артефакта (например,
исполняемый файл), нативная библиотека будет прикомпонована.</p>
</li>
</ul>
<p>На OSX, фреймворки ведут себя так же, как и динамические библиотеки.</p>
<h1><a class="header" href="#Небезопасные-блоки" id="Небезопасные-блоки">Небезопасные блоки</a></h1>
<p>Некоторые операции, такие как разыменование небезопасных указателей или вызов
функций, которые были отмечены как небезопасные, разрешено использовать только
внутри небезопасных блоков. Небезопасные блоки изолируют опасные ситуации и дают
гарантии компилятору, что опасности не вытекут за пределы блока.</p>
<p>Небезопасные функции же, наоборот, показывают свою опасность всем. Небезопасная
функция записывается в виде:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
unsafe fn kaboom(ptr: *const i32) -&gt; i32 { *ptr }
#}</code></pre></pre>
<p>Эта функция может быть вызвана только из блока <code>unsafe</code> или из другой <code>unsafe</code>
функции.</p>
<h1><a class="header" href="#Доступ-к-внешним-глобальным-переменным" id="Доступ-к-внешним-глобальным-переменным">Доступ к внешним глобальным переменным</a></h1>
<p>Внешние API довольно часто экспортируют глобальные переменные, которые могут
быть использованы, например, для отслеживания глобального состояния. Для того,
чтобы получить доступ к этим переменным, нужно объявить их в блоке <code>extern</code>,
используя ключевое слово <code>static</code>:</p>
<pre><code class="language-no_run"># #![feature(libc)]
extern crate libc;

#[link(name = &quot;readline&quot;)]
extern {
    static rl_readline_version: libc::c_int;
}

fn main() {
    println!(&quot;You have readline version {} installed.&quot;,
             rl_readline_version as i32);
}
</code></pre>
<p>Кроме того, возможно, вам потребуется изменить глобальное состояние,
предоставленное внешним интерфейсом. Для этого при объявлении статических
переменных может быть добавлен модификатор <code>mut</code>, чтобы была возможность
изменять их.</p>
<pre><code class="language-no_run"># #![feature(libc)]
extern crate libc;

use std::ffi::CString;
use std::ptr;

#[link(name = &quot;readline&quot;)]
extern {
    static mut rl_prompt: *const libc::c_char;
}

fn main() {
    let prompt = CString::new(&quot;[my-awesome-shell] $&quot;).unwrap();
    unsafe {
        rl_prompt = prompt.as_ptr();

        println!(&quot;{:?}&quot;, rl_prompt);

        rl_prompt = ptr::null();
    }
}
</code></pre>
<p>Обратите внимание, что любое взаимодействие с <code>static mut</code> небезопасно — как
чтение, так и запись. Работа с изменяемым глобальным состоянием требует
значительно большей осторожности.</p>
<p><a name="foreign-calling-conventions"></a></p>
<h1><a class="header" href="#Соглашение-о-вызове-внешних-функций" id="Соглашение-о-вызове-внешних-функций">Соглашение о вызове внешних функций</a></h1>
<p>Большинство внешнего кода предоставляет C ABI. И Rust при вызове внешних функций
по умолчанию использует соглашение о вызове C для данной платформы. Но некоторые
внешние функции, в первую очередь Windows API, используют другое соглашение о
вызове. Rust обеспечивает способ указать компилятору, какое именно соглашение
использовать:</p>
<pre><pre class="playpen"><code class="language-rust"># #![feature(libc)]
extern crate libc;

#[cfg(all(target_os = &quot;win32&quot;, target_arch = &quot;x86&quot;))]
#[link(name = &quot;kernel32&quot;)]
#[allow(non_snake_case)]
extern &quot;stdcall&quot; {
    fn SetEnvironmentVariableA(n: *const u8, v: *const u8) -&gt; libc::c_int;
}
# fn main() { }
</code></pre></pre>
<p>Это указание относится ко всему блоку <code>extern</code>. Вот список поддерживаемых
ограничений для ABI:</p>
<ul>
<li><code>stdcall</code></li>
<li><code>aapcs</code></li>
<li><code>cdecl</code></li>
<li><code>fastcall</code></li>
<li><code>Rust</code></li>
<li><code>rust-intrinsic</code></li>
<li><code>system</code></li>
<li><code>C</code></li>
<li><code>win64</code></li>
</ul>
<p>Большинство ABI в этом списке не требуют пояснений, но ABI <code>system</code> может
показаться немного странным. Он выбирает такое ABI, которое подходит для
взаимодействия с нативными библиотеками данной платформы. Например, на платформе
win32 с архитектурой x86, это означает, что будет использован ABI <code>stdcall</code>.
Однако, на windows x86_64 используется соглашение о вызове <code>C</code>, поэтому в этом
случае будет использован <code>C</code> ABI. Это означает, что в нашем предыдущем примере
мы могли бы использовать <code>extern &quot;system&quot; { ... }</code>, чтобы определить блок для
всех windows систем, а не только для x86.</p>
<h1><a class="header" href="#Взаимодействие-с-внешним-кодом" id="Взаимодействие-с-внешним-кодом">Взаимодействие с внешним кодом</a></h1>
<p>Rust гарантирует, что размещение полей <code>struct</code> совместимо с представлением в C
только в том случае, если к ней применяется атрибут <code>#[repr(C)]</code>. Атрибут
<code>#[repr(C, packed)]</code> может быть использован для размещения полей структуры без
выравнивания. Атрибут <code>#[repr(C)]</code> также может быть применен и к перечислениям.</p>
<p>Владеющие упаковки в Rust (<code>Box&lt;T&gt;</code>) используют указатели, не допускающие
нулевое значение (non-nullable), как дескрипторы содержащихся в них объектов.
Тем не менее, эти дескрипторы не должны создаваться вручную, так как они
управляются внутренними средствами выделения памяти. Ссылки можно без риска
считать ненулевыми указателями непосредственно на тип. Однако нарушение правил
проверки заимствования или изменяемости может быть небезопасным. Но компилятор
не может сделать так много предположений о сырых указателях. Например, он не
полагается на настоящую неизменяемость данных под неизменяемым сырым указателем.
Поэтому используйте сырые указатели (<code>*</code>), если вам необходимо намеренно
нарушить правила (но так, что при этом всё работает). Это нужно, чтобы
компилятор «случайно» не предположил относительно ссылок чего-то, что мы
собираемся нарушать (возможно, нам нужны несколько указателей с правом
изменения, что не допускается обычными ссылками).</p>
<p>Векторы и строки совместно используют одну и ту же базовую cхему размещения
памяти и утилиты, доступные в модулях <code>vec</code> и <code>str</code>, для работы с C API. Однако,
строки не завершаются нулевым байтом, <code>\0</code>. Если вам нужна строка, завершающаяся
нулевым байтом, для совместимости с C, вы должны использовать тип <code>CString</code> из
модуля <code>std::ffi</code>.</p>
<p>Стандартная библиотека включает в себя псевдонимы типов и определения функций
для стандартной библиотеки C в модуле <code>libc</code>, и Rust компонует <code>libc</code> и <code>libm</code>
по умолчанию.</p>
<h1><a class="header" href="#Оптимизация-указателей-допускающих-нулевое-значение" id="Оптимизация-указателей-допускающих-нулевое-значение">Оптимизация указателей, допускающих нулевое значение</a></h1>
<h1><a class="header" href="#the-nullable-pointer-optimization" id="the-nullable-pointer-optimization">(The nullable pointer optimization)</a></h1>
<p>Некоторые типы по определению не могут быть <code>null</code>. Это ссылки (<code>&amp;T</code>, <code>&amp;mut T</code>),
упаковки (<code>Box&lt;T&gt;</code>), указатели на функции (<code>extern &quot;abi&quot; fn()</code>). При
взаимодействии же с С часто используются указатели, которые могут быть <code>null</code>.
Как особый случай — обобщенный <code>enum</code>, который содержит ровно два варианта, один
из которых не содержит данных, а другой содержит одно поле. Такое использование
перечисления имеет право на «оптимизацию указателя, допускающего нулевое
значение». Когда создан экземпляр такого перечисления с одним из не-обнуляемых
типов, то он представляет собой ненулевой указатель для варианта, содержащего
данные, и нулевой — для варианта без данных. Таким образом, <code>Option&lt;extern &quot;C&quot; fn(c_int) -&gt; c_int&gt;</code> — это представление указателя на функцию, допускающего
нулевое значение, и совместимого с C ABI.</p>
<h1><a class="header" href="#Вызов-кода-на-rust-из-кода-на-c" id="Вызов-кода-на-rust-из-кода-на-c">Вызов кода на Rust из кода на C</a></h1>
<p>Вы можете скомпилировать код на Rust таким образом, чтобы он мог быть вызван из
кода на C. Это довольно легко, но требует нескольких вещей:</p>
<pre><pre class="playpen"><code class="language-rust">#[no_mangle]
pub extern fn hello_rust() -&gt; *const u8 {
    &quot;Hello, world!\0&quot;.as_ptr()
}
# fn main() {}
</code></pre></pre>
<p><code>extern</code> указывает, что эта функцию придерживается соглашения о вызове C, как
описано выше в разделе
«<a href="ffi.html#foreign-calling-conventions">Соглашение о вызове внешних функций</a>».
Атрибут <code>no_mangle</code> выключает изменение имён, применяемое в Rust, чтобы было
легче компоноваться с этим кодом.</p>
<p>% Типажи <code>Borrow</code> и <code>AsRef</code></p>
<p>Типажи <a href="http://doc.rust-lang.org/std/borrow/trait.Borrow.html"><code>Borrow</code></a> и <a href="http://doc.rust-lang.org/std/convert/trait.AsRef.html"><code>AsRef</code></a> очень похожи, но в то же время
отличаются. Ниже приводится небольшая памятка об этих двух типажах.</p>
<h1><a class="header" href="#Типаж-borrow" id="Типаж-borrow">Типаж Borrow</a></h1>
<p>Типаж <code>Borrow</code> используется, когда вы пишете структуру данных и хотите
использовать владение и заимствование типа как синонимы.</p>
<p>Например, <a href="http://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a> имеет метод <a href="http://doc.rust-lang.org/std/collections/struct.HashMap.html#method.get"><code>get</code></a>, который использует
<code>Borrow</code>:</p>
<pre><code class="language-rust ignore">fn get&lt;Q: ?Sized&gt;(&amp;self, k: &amp;Q) -&gt; Option&lt;&amp;V&gt;
    where K: Borrow&lt;Q&gt;,
          Q: Hash + Eq
</code></pre>
<p>Эта сигнатура является довольно сложной. Параметр <code>K</code> — это то, что нас здесь
интересует. Он ссылается на параметр самого <code>HashMap</code>:</p>
<pre><code class="language-rust ignore">struct HashMap&lt;K, V, S = RandomState&gt; {
</code></pre>
<p>Параметр <code>K</code> представляет собой тип <em>ключа</em>, который использует <code>HashMap</code>.
Взглянем на сигнатуру <code>get()</code> еще раз. Использовать <code>get()</code> возможно, когда ключ
реализует <code>Borrow&lt;Q&gt;</code>. Таким образом, мы можем сделать <code>HashMap</code>, который
использует ключи <code>String</code>, но использовать <code>&amp;str</code>, когда мы выполняем поиск:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::HashMap;

let mut map = HashMap::new();
map.insert(&quot;Foo&quot;.to_string(), 42);

assert_eq!(map.get(&quot;Foo&quot;), Some(&amp;42));
#}</code></pre></pre>
<p>Это возможно, так как стандартная библиотека содержит <code>impl Borrow&lt;str&gt; for String</code>.</p>
<p>Для большинства типов, когда вы хотите получить право собственности или
позаимствовать значений, достаточно использовать просто <code>&amp;T</code>. <code>Borrow</code> же
становится полезен, когда есть более одного вида занимаемого значения. Это
особенно верно для ссылок и срезов: у вас может быть как <code>&amp;T</code>, так и <code>&amp;mut T</code>.
Если мы хотим принимать оба этих типа, <code>Borrow</code> как раз для этого подходит:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::borrow::Borrow;
use std::fmt::Display;

fn foo&lt;T: Borrow&lt;i32&gt; + Display&gt;(a: T) {
    println!(&quot;a заимствовано: {}&quot;, a);
}

let mut i = 5;

foo(&amp;i);
foo(&amp;mut i);
#}</code></pre></pre>
<p>Это выведет <code>a заимствовано: 5</code> дважды.</p>
<h1><a class="header" href="#Типаж-asref" id="Типаж-asref">Типаж AsRef</a></h1>
<p>Типаж <code>AsRef</code> является преобразующим типажом. Он используется в обобщённом коде
для преобразования некоторого значения в ссылку. Например:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let s = &quot;Hello&quot;.to_string();

fn foo&lt;T: AsRef&lt;str&gt;&gt;(s: T) {
    let slice = s.as_ref();
}
#}</code></pre></pre>
<h1><a class="header" href="#Что-в-каком-случае-следует-использовать" id="Что-в-каком-случае-следует-использовать">Что в каком случае следует использовать?</a></h1>
<p>Мы видим, что они вроде одинаковы: имеют дело с владением и заимствованием
значения некоторого типа. Тем не менее, эти типажи немного отличаются.</p>
<p>Используйте <code>Borrow</code>, когда вы хотите абстрагироваться от различных видов
заимствований, или когда вы строите структуру данных, которая использует
владеющие и заимствованные значения как эквивалентные. Например, это может
пригодиться в хэшировании и сравнении.</p>
<p>Используйте <code>AsRef</code>, когда вы пишете обобщённый код и хотите непосредственно
преобразовать что-либо в ссылку.</p>
<p>% Каналы сборок</p>
<p>Проект Rust использует концепцию под названием «каналы сборок» для управления
сборками. Важно понять этот процесс, чтобы выбрать, какую версию Rust
использовать в вашем проекте.</p>
<h1><a class="header" href="#Обзор" id="Обзор">Обзор</a></h1>
<p>Есть три канала сборок Rust:</p>
<ul>
<li>Ночной (Nightly)</li>
<li>Бета (Beta)</li>
<li>Стабильный (Stable)</li>
</ul>
<p>Новые ночные сборки создаются раз в день. Каждые шесть недель последняя ночная
сборка переводится в канал «бета». С этого момента она будет получать только
исправления серьёзных ошибок. Шесть недель спустя бета сборка переводится в
канал «стабильный» и становится очередной стабильной сборкой <code>1.x</code>.</p>
<p>Этот процесс происходит параллельно. Так, каждые шесть недель, в один и тот же
день, ночная сборка превращается в бета сборку, а бета сборка превращается в
стабильную сборку. Это произойдёт одновременно: стабильная сборка получит версию
<code>1.x</code>, бета сборка получит версию <code>1.(x + 1)-beta</code>, а ночная сборка станет
первой версией <code>1.(x + 2)-nightly</code>.</p>
<h1><a class="header" href="#Выбор-версии" id="Выбор-версии">Выбор версии</a></h1>
<p>Вообще говоря, если у вас нет особых причин, вы должны использовать канал
стабильных сборок. Эти сборки предназначены для широкой аудитории.</p>
<p>Однако, в зависимости от ваших интересов к Rust, вы можете вместо этого выбрать
ночную сборку. Основной компромисс заключается в следующем: при выборе канала
ночных сборок, вы можете использовать неустойчивые, новые возможности Rust. Тем
не менее, нестабильные возможности могут быть изменены, и поэтому любая новая
ночная сборка может сломать ваш код. Если же вы выберете стабильную сборку, то
не сможете использовать экспериментальные возможности, но следующий релиз Rust
не вызовет существенных проблем с критическими изменениями.</p>
<h1><a class="header" href="#Помощь-экосистеме-с-помощью-непрерывной-интеграции" id="Помощь-экосистеме-с-помощью-непрерывной-интеграции">Помощь экосистеме с помощью непрерывной интеграции</a></h1>
<p>А что насчёт бета канала? Мы призываем всех пользователей Rust, которые
используют канал стабильных сборок, также протестировать работу с использованием
бета канала в их системах непрерывной интеграции. Это поможет предупредить
команду в случае возникновения неожиданных регрессий.</p>
<p>Кроме того, тестирование работы с использованием ночного канала может выявить
регрессии даже раньше, а поэтому, если вас не затруднит создание трех сборок, мы
будем признательны тестированию работы с использованием всех трех каналов.</p>
<p>% Using Rust Without the Standard Library</p>
<p>Rust’s standard library provides a lot of useful functionality, but assumes
support for various features of its host system: threads, networking, heap
allocation, and others. There are systems that do not have these features,
however, and Rust can work with those too! To do so, we tell Rust that we
don’t want to use the standard library via an attribute: <code>#![no_std]</code>.</p>
<blockquote>
<p>Note: This feature is technically stable, but there are some caveats. For
one, you can build a <code>#![no_std]</code> <em>library</em> on stable, but not a <em>binary</em>.
For details on binaries without the standard library, see <a href="no-stdlib.html">the nightly
chapter on <code>#![no_std]</code></a></p>
</blockquote>
<p>To use <code>#![no_std]</code>, add a it to your crate root:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![no_std]

#fn main() {
fn plus_one(x: i32) -&gt; i32 {
    x + 1
}
#}</code></pre></pre>
<p>Much of the functionality that’s exposed in the standard library is also
available via the <a href="(http://doc.rust-lang.org/core/)"><code>core</code> crate</a>. When we’re using the standard
library, Rust automatically brings <code>std</code> into scope, allowing you to use
its features without an explicit import. By the same token, when using
<code>!#[no_std]</code>, Rust will bring <code>core</code> into scope for you, as well as <a href="(http://doc.rust-lang.org/core/prelude/v1/)">its
prelude</a>. This means that a lot of code will Just Work:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![no_std]

#fn main() {
fn may_fail(failure: bool) -&gt; Result&lt;(), &amp;'static str&gt; {
    if failure {
        Err(&quot;this didn’t work!&quot;)
    } else {
        Ok(())
    }
}
#}</code></pre></pre>
<p>% Нестабильные возможности Rust</p>
<p>Rust обеспечивает три канала распространения для Rust: nightly, beta и stable.
Нестабильные функции доступны только в nightly Rust. Для более подробной
информации об этом процессе смотрите «<a href="http://blog.rust-lang.org/2014/10/30/Stability.html">Стабильность как результат</a>».</p>
<p>Чтобы установить nightly Rust, вы можете использовать <code>rustup.sh</code>:</p>
<pre><code class="language-bash">$ curl -s https://static.rust-lang.org/rustup.sh | sh -s -- --channel=nightly
</code></pre>
<p>Если вы беспокоитесь о <a href="http://curlpipesh.tumblr.com">потенциальной безопасности</a> использования
данной команды <code>curl | sh</code>, то продолжайте читать далее. Вы также можете
использовать двухступенчатый вариант установки и изучить наш установочный
скрипт:</p>
<pre><code class="language-bash">$ curl -f -L https://static.rust-lang.org/rustup.sh -O
$ sh rustup.sh --channel=nightly
</code></pre>
<p>Если же вы используете Windows, то, пожалуйста, скачайте один из установочных
пакетов: <a href="https://static.rust-lang.org/dist/rust-1.0.0-beta-i686-pc-windows-gnu.msi">32-битный</a> или <a href="https://static.rust-lang.org/dist/rust-1.0.0-beta-x86_64-pc-windows-gnu.msi">64-битный</a> и запустите его.</p>
<h2><a class="header" href="#Удаление-1" id="Удаление-1">Удаление</a></h2>
<p>Если вы решили, что Rust вам больше не нужен, то мы будем чуть-чуть огорчены, но
это нормально. Не каждый язык программирования отлично подходит для всех. Просто
запустите скрипт деинсталляции:</p>
<pre><code class="language-bash">$ sudo /usr/local/lib/rustlib/uninstall.sh
</code></pre>
<p>Если вы использовали установщик Windows, то просто повторно запустите <code>.msi</code>,
который предложит вам возможность удаления.</p>
<p>Некоторые люди, причём не безосновательно, насторожились, когда мы сказали
использовать <code>curl | sh</code>. Когда вы делаете так, вы должны доверять тем хорошим
людям, которые поддерживают Rust, и не бояться, что они попытаются взломать ваш
компьютер и сделать какие-либо плохие вещи. Озабоченность своей безопасностью -
это очень хорошо. Если вы один из таких людей, пожалуйста посмотрите в
документации как <a href="https://github.com/rust-lang/rust#building-from-source">собрать Rust из исходных кодов</a> или скачайте уже
<a href="http://www.rust-lang.org/install.html">скомпилированный Rust</a>. Мы обещаем, что данный способ не будет
использоваться для установки Rust всегда: скрипт был сделан для быстрого
обновления пока Rust находится в стадии alpha.</p>
<p>Мы так же должны упомянуть официально поддерживаемые платформы:</p>
<ul>
<li>Windows (7, 8, Server 2008 R2)</li>
<li>Linux (2.6.18 и более новые, разные дистрибутивы), x86 и x86-64</li>
<li>OSX 10.7 (Lion) и более новые, x86 и x86-64</li>
</ul>
<p>Rust активно тестируется на всех этих платформах, а также на некоторых других,
например на Android. Но мы указали те, на которых Rust точно должен работать,
ибо для этих платформ он тестируется больше всего.</p>
<p>Напоследок, замечание о Windows. Rust считает, что Windows — это первоклассная
платформа для релиза, но если быть честными, то опыт разработки для Windows не
на столько хорош, как для Linux/OS X. Мы работаем над этим! Если что-то не
работает, то это ошибка. Пожалуйста, дайте нам знать, если такое произойдёт.
Каждый коммит тестируется на Windows, впрочем так же, как и на любой другой
платформе.</p>
<p>Если вы уже установили Rust, то откройте терминал и введите это:</p>
<pre><code class="language-bash">$ rustc --version
</code></pre>
<p>Вы должны увидеть версию, хэш коммита, дату коммита и дату сборки:</p>
<pre><code class="language-bash">rustc 1.0.0-nightly (f11f3e7ba 2015-01-04) (built 2015-01-06)
</code></pre>
<p>Итак, теперь у вас есть установленный Rust! Поздравляем!</p>
<p>Установщик также устанавливает документацию, которая доступна без подключения к
сети. На UNIX системах она располагается в каталоге <code>/usr/local/share/doc/rust</code>.
В Windows — в директории <code>share/doc</code>, относительно того куда вы установили Rust.</p>
<p>Также есть ещё ряд мест, где можно получить помощь. <a href="irc://irc.mozilla.org/#rust">Канал #rust на
irc.mozilla.org</a>, к которому вы можете подключиться через <a href="http://chat.mibbit.com/?server=irc.mozilla.org&amp;channel=%23rust">Mibbit</a>.
Нажмите на эту ссылку, и вы будете общаться в чате с другими Rustaceans (это
дурашливое прозвище, которым мы себя называем), и мы поможем вам. Другие
полезные ресурсы, посвящённые Rust: <a href="http://users.rust-lang.org/">форум пользователей</a>, <a href="http://www.reddit.com/r/rust">/r/rust
subreddit</a>, <a href="http://stackoverflow.com/questions/tagged/rust">stack overflow</a>. Русскоязычные ресурсы:
<a href="irc://irc.mozilla.org/#rust-ru">канал #rust-ru на irc.mozilla.org</a>, <a href="https://groups.google.com/forum/#!forum/rust-russian">google groups</a>.</p>
<p>% Плагины к компилятору</p>
<h1><a class="header" href="#Введение-1" id="Введение-1">Введение</a></h1>
<p><code>rustc</code>, компилятор Rust, поддерживает плагины. Плагины — это разработанные
пользователями библиотеки, которые добавляют новые возможности в компилятор: это
могут быть расширения синтаксиса, дополнительные статические проверки (lints), и
другое.</p>
<p>Плагин — это контейнер, собираемый в динамическую библиотеку, и имеющий
отдельную функцию для регистрации расширения в <code>rustc</code>. Другие контейнеры могут
загружать эти расширения с помощью атрибута <code>#![plugin(...)]</code>. Также смотрите
раздел <a href="http://doc.rust-lang.org/rustc/plugin/index.html"><code>rustc::plugin</code></a> с
подробным описанием механизма определения и загрузки плагина.</p>
<p>Передаваемые в <code>#![plugin(foo(... args ...))]</code> аргументы не обрабатываются самим
<code>rustc</code>. Они передаются плагину с помощью
<a href="http://doc.rust-lang.org/rustc/plugin/registry/struct.Registry.html#method.args">метода <code>args</code></a>
структуры <code>Registry</code>.</p>
<p>В подавляющем большинстве случаев плагин должен использоваться <em>только</em> через
конструкцию <code>#![plugin]</code>, а не через <code>extern crate</code>. Компоновка потянула бы
внутренние библиотеки <code>libsyntax</code> и <code>librustc</code> как зависимости для вашего
контейнера. Обычно это нежелательно, и может потребоваться только если вы
собираете ещё один, другой, плагин. Статический анализ <code>plugin_as_library</code>
проверяет выполнение этой рекомендации.</p>
<p>Обычная практика — помещать плагины в отдельный контейнер, не содержащий
определений макросов (<code>macro_rules!</code>) и обычного кода на Rust, предназначенного
для непосредственно конечных пользователей библиотеки.</p>
<h1><a class="header" href="#Расширения-синтаксиса" id="Расширения-синтаксиса">Расширения синтаксиса</a></h1>
<p>Плагины могут по-разному расширять синтаксис Rust. Один из видов расширения
синтаксиса — это процедурные макросы. Они вызываются так же, как и
<a href="macros.html">обычные макросы</a>, но их раскрытие производится произвольным кодом
на Rust, который оперирует
<a href="http://doc.rust-lang.org/syntax/ast/index.html">синтаксическими деревьями</a> во
время компиляции.</p>
<p>Давайте напишем плагин
<a href="https://github.com/rust-lang/rust/tree/master/src/test/auxiliary/roman_numerals.rs"><code>roman_numerals.rs</code></a>,
который реализует целочисленные литералы с римскими цифрами.</p>
<pre><code class="language-ignore">#![crate_type=&quot;dylib&quot;]
#![feature(plugin_registrar, rustc_private)]

extern crate syntax;
extern crate rustc;

use syntax::codemap::Span;
use syntax::parse::token;
use syntax::ast::{TokenTree, TtToken};
use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};
use syntax::ext::build::AstBuilder;  // типаж для expr_usize
use rustc::plugin::Registry;

fn expand_rn(cx: &amp;mut ExtCtxt, sp: Span, args: &amp;[TokenTree])
        -&gt; Box&lt;MacResult + 'static&gt; {

    static NUMERALS: &amp;'static [(&amp;'static str, u32)] = &amp;[
        (&quot;M&quot;, 1000), (&quot;CM&quot;, 900), (&quot;D&quot;, 500), (&quot;CD&quot;, 400),
        (&quot;C&quot;,  100), (&quot;XC&quot;,  90), (&quot;L&quot;,  50), (&quot;XL&quot;,  40),
        (&quot;X&quot;,   10), (&quot;IX&quot;,   9), (&quot;V&quot;,   5), (&quot;IV&quot;,   4),
        (&quot;I&quot;,    1)];

    let text = match args {
        [TtToken(_, token::Ident(s, _))] =&gt; token::get_ident(s).to_string(),
        _ =&gt; {
            cx.span_err(sp, &quot;аргумент должен быть единственным идентификатором&quot;);
            return DummyResult::any(sp);
        }
    };

    let mut text = &amp;*text;
    let mut total = 0;
    while !text.is_empty() {
        match NUMERALS.iter().find(|&amp;&amp;(rn, _)| text.starts_with(rn)) {
            Some(&amp;(rn, val)) =&gt; {
                total += val;
                text = &amp;text[rn.len()..];
            }
            None =&gt; {
                cx.span_err(sp, &quot;неправильное римское число&quot;);
                return DummyResult::any(sp);
            }
        }
    }

    MacEager::expr(cx.expr_u32(sp, total))
}

#[plugin_registrar]
pub fn plugin_registrar(reg: &amp;mut Registry) {
    reg.register_macro(&quot;rn&quot;, expand_rn);
}
</code></pre>
<p>Теперь мы можем использовать <code>rn!()</code> как любой другой макрос:</p>
<pre><code class="language-ignore">#![feature(plugin)]
#![plugin(roman_numerals)]

fn main() {
    assert_eq!(rn!(MMXV), 2015);
}
</code></pre>
<p>У этого подхода есть преимущества относительно простой функции <code>fn(&amp;str) -&gt; u32</code>:</p>
<ul>
<li>Преобразование (в общем случае, произвольной сложности) выполняется во время
компиляции;</li>
<li>Проверка правильности записи литерала также производится во время компиляции;</li>
<li>Можно добавить возможность использования литерала в образцах (patterns), что
по сути позволяет создавать литералы для любого типа данных.</li>
</ul>
<p>В дополнение к процедурным макросам, вы можете определять новые атрибуты
<a href="http://doc.rust-lang.org/reference.html#derive"><code>derive</code></a> и другие виды
расширений. Смотрите раздел
<a href="http://doc.rust-lang.org/rustc/plugin/registry/struct.Registry.html#method.register_syntax_extension"><code>Registry::register_syntax_extension</code></a>
и документацию
<a href="http://doc.rust-lang.org/syntax/ext/base/enum.SyntaxExtension.html">перечисления <code>SyntaxExtension</code></a>.
В качестве более продвинутого примера с макросами, можно ознакомиться с
макросами регулярных выражений
<a href="https://github.com/rust-lang/regex/blob/master/regex_macros/src/lib.rs"><code>regex_macros</code></a>.</p>
<h2><a class="header" href="#Советы-и-хитрости" id="Советы-и-хитрости">Советы и хитрости</a></h2>
<p>Некоторые <a href="macros.html#debugging-macro-code">советы по отладке макросов</a>
применимы и в случае плагинов.</p>
<p>Можно использовать
<a href="http://doc.rust-lang.org/syntax/parse/index.html"><code>syntax::parse</code></a>, чтобы
преобразовать деревья токенов в высокоуровневые элементы синтаксиса, вроде
выражений:</p>
<pre><code class="language-ignore">fn expand_foo(cx: &amp;mut ExtCtxt, sp: Span, args: &amp;[TokenTree])
        -&gt; Box&lt;MacResult+'static&gt; {

    let mut parser = cx.new_parser_from_tts(args);

    let expr: P&lt;Expr&gt; = parser.parse_expr();
</code></pre>
<p>Можно просмотреть код
<a href="https://github.com/rust-lang/rust/blob/master/src/libsyntax/parse/parser.rs">парсера <code>libsyntax</code></a>,
чтобы получить представление о работе инфраструктуры разбора.</p>
<p>Сохраняйте <a href="http://doc.rust-lang.org/syntax/codemap/struct.Span.html"><code>Span</code>ы</a>
всего, что вы разбираете, чтобы лучше сообщать об ошибках. Вы можете обернуть
ваши структуры данных в
<a href="http://doc.rust-lang.org/syntax/codemap/struct.Spanned.html"><code>Spanned</code></a>.</p>
<p>Вызов
<a href="http://doc.rust-lang.org/syntax/ext/base/struct.ExtCtxt.html#method.span_fatal"><code>ExtCtxt::span_fatal</code></a>
сразу прервёт компиляцию. Вместо этого, лучше вызвать
<a href="http://doc.rust-lang.org/syntax/ext/base/struct.ExtCtxt.html#method.span_err"><code>ExtCtxt::span_err</code></a>
и вернуть
<a href="http://doc.rust-lang.org/syntax/ext/base/struct.DummyResult.html"><code>DummyResult</code></a>,
чтобы компилятор мог продолжить работу и обнаружить дальнейшие ошибки.</p>
<p>Вы можете использовать
<a href="http://doc.rust-lang.org/syntax/ext/base/struct.ExtCtxt.html#method.span_note"><code>span_note</code></a>
и
<a href="http://doc.rust-lang.org/syntax/print/pprust/index.html#functions"><code>syntax::print::pprust::*_to_string</code></a>
чтобы напечатать синтаксический фрагмент для отладки.</p>
<p>Пример выше создавал целочисленный литерал с помощью
<a href="http://doc.rust-lang.org/syntax/ext/build/trait.AstBuilder.html#tymethod.expr_usize"><code>AstBuilder::expr_usize</code></a>.
В качестве альтернативы типажу <code>AstBuilder</code>, <code>libsyntax</code> предоставляет набор
<a href="http://doc.rust-lang.org/syntax/ext/quote/index.html">макросов квазицитирования</a>.
Они не документированы и совсем не отполированы. Однако, эта реализация может
стать неплохой основой для улучшенной библиотеки квазицитирования, которая
работала бы как обычный плагин.</p>
<h1><a class="header" href="#Плагины-статических-проверок" id="Плагины-статических-проверок">Плагины статических проверок</a></h1>
<p>Плагины могут расширять
<a href="http://doc.rust-lang.org/reference.html#lint-check-attributes">инфраструктуру статических проверок Rust</a>,
предоставляя новые проверки стиля кодирования, безопасности, и т.д. Полный
пример можно найти в
<a href="https://github.com/rust-lang/rust/blob/master/src/test/auxiliary/lint_plugin_test.rs"><code>src/test/auxiliary/lint_plugin_test.rs</code></a>.
Здесь мы приводим его суть:</p>
<pre><code class="language-ignore">declare_lint!(TEST_LINT, Warn,
              &quot;Предупреждать об элементах, названных 'lintme'&quot;);

struct Pass;

impl LintPass for Pass {
    fn get_lints(&amp;self) -&gt; LintArray {
        lint_array!(TEST_LINT)
    }

    fn check_item(&amp;mut self, cx: &amp;Context, it: &amp;ast::Item) {
        let name = token::get_ident(it.ident);
        if name.get() == &quot;lintme&quot; {
            cx.span_lint(TEST_LINT, it.span, &quot;элемент называется 'lintme'&quot;);
        }
    }
}

#[plugin_registrar]
pub fn plugin_registrar(reg: &amp;mut Registry) {
    reg.register_lint_pass(box Pass as LintPassObject);
}
</code></pre>
<p>Тогда код вроде</p>
<pre><code class="language-ignore">#![plugin(lint_plugin_test)]

fn lintme() { }
</code></pre>
<p>выдаст предупреждение компилятора:</p>
<pre><code class="language-txt">foo.rs:4:1: 4:16 warning: item is named 'lintme', #[warn(test_lint)] on by default
foo.rs:4 fn lintme() { }
         ^~~~~~~~~~~~~~~
</code></pre>
<p>Плагин статического анализа состоит из следующих частей:</p>
<ul>
<li>
<p>один или больше вызовов <code>declare_lint!</code>, которые определяют статические
структуры <a href="http://doc.rust-lang.org/rustc/lint/struct.Lint.html"><code>Lint</code></a>;</p>
</li>
<li>
<p>структура, содержащая состояние, необходимое анализатору (в данном случае, его
нет);</p>
</li>
<li>
<p>реализация типажа
<a href="http://doc.rust-lang.org/rustc/lint/trait.LintPass.html"><code>LintPass</code></a>,
определяющая, как проверять каждый элемент синтаксиса. Один <code>LintPass</code> может
вызывать <code>span_lint</code> для нескольких различных <code>Lint</code>, но он должен
зарегистрировать их все через метод <code>get_lints</code>.</p>
</li>
</ul>
<p>Проходы статического анализатора — это обходы синтаксического дерева, но они
выполняются на поздних стадиях компиляции, когда уже доступа информация о типах.
Встроенные в <code>rustc</code>
<a href="https://github.com/rust-lang/rust/blob/master/src/librustc/lint/builtin.rs">анализы</a>
в основном используют ту же инфраструктуру, что и плагины статического анализа.
Смотрите их исходный код, чтобы понять, как получать информацию о типах.</p>
<p>Статические проверки, определяемые плагинами, управляются обычными
<a href="http://doc.rust-lang.org/reference.html#lint-check-attributes">атрибутами и флагами компилятора</a>,
т.е. <code>#[allow(test_lint)]</code> или <code>-A test-lint</code>. Эти идентификаторы выводятся из
первого аргумента <code>declare_lint!</code>, с учётом соответствующих преобразований
регистра букв и пунктуации.</p>
<p>Вы можете выполнить команду <code>rustc -W help foo.rs</code>, чтобы увидеть весь список
статических проверок, известных <code>rustc</code>, включая те, что загружаются
из<code>foo.rs</code>.</p>
<p>% Встроенный ассемблерный код</p>
<p>Если вам нужно работать на самом низком уровне или повысить производительность
программы, то у вас может возникнуть необходимость управлять процессором
напрямую. Rust поддерживает использование встроенного ассемблера и делает это с
помощью с помощью макроса <code>asm!</code>. Синтаксис примерно соответствует синтаксису
GCC и Clang:</p>
<pre><code class="language-ignore">asm!(assembly template
   : output operands
   : input operands
   : clobbers
   : options
   );
</code></pre>
<p>Использование <code>asm</code> является закрытой возможностью (требуется указать
<code>#![feature(asm)]</code> для контейнера, чтобы разрешить ее использование) и, конечно
же, требует <code>unsafe</code> блока.</p>
<blockquote>
<p><strong>Примечание</strong>: здесь примеры приведены для x86/x86-64 ассемблера, но
поддерживаются все платформы.</p>
</blockquote>
<h2><a class="header" href="#Шаблон-инструкции-ассемблера" id="Шаблон-инструкции-ассемблера">Шаблон инструкции ассемблера</a></h2>
<p>Шаблон инструкции ассемблера (assembly template) является единственным
обязательным параметром, и он должен быть представлен строкой символов (т.е.
<code>&quot;&quot;</code>)</p>
<pre><pre class="playpen"><code class="language-rust">#![feature(asm)]

#[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
fn foo() {
    unsafe {
        asm!(&quot;NOP&quot;);
    }
}

// other platforms
#[cfg(not(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;)))]
fn foo() { /* ... */ }

fn main() {
    // ...
    foo();
    // ...
}
</code></pre></pre>
<p>(Далее атрибуты <code>feature(asm)</code> и <code>#[cfg]</code> будут опущены.)</p>
<p>Выходные операнды (output operands), входные операнды (input operands),
затираемое (clobbers) и опции (options) не являются обязательными, но вы должны
будете добавить соответствующее количество <code>:</code> если хотите пропустить их:</p>
<pre><pre class="playpen"><code class="language-rust"># #![feature(asm)]
# #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
# fn main() { unsafe {
asm!(&quot;xor %eax, %eax&quot;
    :
    :
    : &quot;{eax}&quot;
   );
# } }
</code></pre></pre>
<p>Пробелы и отступы также не имеют значения:</p>
<pre><pre class="playpen"><code class="language-rust"># #![feature(asm)]
# #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
# fn main() { unsafe {
asm!(&quot;xor %eax, %eax&quot; ::: &quot;{eax}&quot;);
# } }
</code></pre></pre>
<h2><a class="header" href="#Операнды" id="Операнды">Операнды</a></h2>
<p>Входные и выходные операнды имеют одинаковый формат:
<code>:&quot;ограничение1&quot;(выражение1), &quot;ограничение2&quot;(выражение2), ...&quot;</code>. Выражения для
выходных операндов должны быть либо изменяемыми, либо неизменяемыми, но еще не
инициализированными, L-значениями:</p>
<pre><pre class="playpen"><code class="language-rust"># #![feature(asm)]
# #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
fn add(a: i32, b: i32) -&gt; i32 {
    let c: i32;
    unsafe {
        asm!(&quot;add $2, $0&quot;
             : &quot;=r&quot;(c)
             : &quot;0&quot;(a), &quot;r&quot;(b)
             );
    }
    c
}
# #[cfg(not(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;)))]
# fn add(a: i32, b: i32) -&gt; i32 { a + b }

fn main() {
    assert_eq!(add(3, 14159), 14162)
}
</code></pre></pre>
<p>Однако, если вы захотите использовать реальные операнды (регистры) в этой
позиции, то вам потребуется заключить используемый регистр в фигурные скобки
<code>{}</code>, и вы должны будете указать конкретный размер операнда. Это полезно для
очень низкоуровневого программирования, когда важны регистры, которые вы
используете:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# #![feature(asm)]
# #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
# unsafe fn read_byte_in(port: u16) -&gt; u8 {
let result: u8;
asm!(&quot;in %dx, %al&quot; : &quot;={al}&quot;(result) : &quot;{dx}&quot;(port));
result
# }
#}</code></pre></pre>
<h2><a class="header" href="#Затираемое-clobbers" id="Затираемое-clobbers">Затираемое (Clobbers)</a></h2>
<p>Некоторые инструкции могут изменять значения регистров, поэтому мы используем
список затираемого. Он указывает компилятору, что тот не должен допускать
какого-либо изменение значений этих регистров, чтобы они оставались корректными.</p>
<pre><pre class="playpen"><code class="language-rust"># #![feature(asm)]
# #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
# fn main() { unsafe {
// Put the value 0x200 in eax
asm!(&quot;mov $$0x200, %eax&quot; : /* no outputs */ : /* no inputs */ : &quot;{eax}&quot;);
# } }
</code></pre></pre>
<p>Если входные и выходные регистры уже заданы в ограничениях, то их не нужно
перечислять здесь. В противном случае, любые другие регистры, используемые явно
или неявно, должны быть перечислены.</p>
<p>Если ассемблер изменяет регистр кода условия <code>cc</code>, то он должен быть указан в
качестве одного из затираемых. Точно так же, если ассемблер модифицирует память,
то должно быть указано <code>memory</code>.</p>
<h2><a class="header" href="#Опции" id="Опции">Опции</a></h2>
<p>Последний раздел, <code>options</code>, специфичен для Rust. Формат представляет собой
разделенные запятыми текстовые строки (т.е. <code>:&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;</code>). Он
используется для того, чтобы задать некоторые дополнительные данные для
встроенного ассемблера:</p>
<p>На текущий момент разрешены следующие опции:</p>
<ol>
<li>
<p><em>volatile</em> — эта опция аналогична <code>__asm__ __volatile__ (...)</code> в gcc/clang;</p>
</li>
<li>
<p><em>alignstack</em> — некоторые инструкции ожидают, что стек был выровнен
определенным образом (т.е. SSE), и эта опция указывает компилятору вставить
свой обычный код выравнивания стека;</p>
</li>
<li>
<p><em>intel</em> — эта опция указывает использовать синтаксис Intel вместо
используемого по умолчанию синтаксиса AT&amp;T.</p>
</li>
</ol>
<pre><pre class="playpen"><code class="language-rust"># #![feature(asm)]
# #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
# fn main() {
let result: i32;
unsafe {
   asm!(&quot;mov eax, 2&quot; : &quot;={eax}&quot;(result) : : : &quot;intel&quot;)
}
println!(&quot;eax is currently {}&quot;, result);
# }
</code></pre></pre>
<h2><a class="header" href="#Больше-информации" id="Больше-информации">Больше информации</a></h2>
<p>Текущая реализация макроса <code>asm!</code> --- это прямое связывание с
<a href="http://llvm.org/docs/LangRef.html#inline-assembler-expressions">встроенным ассемблером LLVM</a>, поэтому изучите и их
<a href="http://llvm.org/docs/LangRef.html#inline-assembler-expressions">документацию</a>, чтобы лучше понять список затираемого, ограничения и
др.</p>
<p>% Без stdlib</p>
<p>По умолчанию, <code>std</code> компонуется с каждым контейнером Rust. В некоторых случаях это
нежелательно, и этого можно избежать с помощью атрибута <code>#![no_std]</code>,
примененного (привязанного) к контейнеру.</p>
<pre><code class="language-ignore">// a minimal library
#![crate_type=&quot;lib&quot;]
#![feature(no_std)]
#![no_std]
# // fn main() {} tricked you, rustdoc!
</code></pre>
<p>Очевидно, должно быть нечто большее, чем просто библиотеки: <code>#[no_std]</code> можно
использовать с исполняемыми контейнерами, а управлять точкой входа можно двумя
способами: с помощью атрибута <code>#[start]</code>, или с помощью переопределения
прокладки (shim) для C функции <code>main</code> по умолчанию на вашу собственную.</p>
<p>В функцию, помеченную атрибутом <code>#[start]</code>, передаются параметры командной
строки в том же формате, что и в C:</p>
<pre><pre class="playpen"><code class="language-rust">#![feature(lang_items, start, no_std, libc)]
#![no_std]

// Pull in the system libc library for what crt0.o likely requires
extern crate libc;

// Entry point for this program
#[start]
fn start(_argc: isize, _argv: *const *const u8) -&gt; isize {
    0
}

// These functions and traits are used by the compiler, but not
// for a bare-bones hello world. These are normally
// provided by libstd.
#[lang = &quot;stack_exhausted&quot;] extern fn stack_exhausted() {}
#[lang = &quot;eh_personality&quot;] extern fn eh_personality() {}
#[lang = &quot;panic_fmt&quot;] fn panic_fmt() -&gt; ! { loop {} }
# // fn main() {} tricked you, rustdoc!
</code></pre></pre>
<p>Чтобы переопределить вставленную компилятором прокладку <code>main</code>, нужно сначала
отключить ее с помощью <code>#![no_main]</code>, а затем создать соответствующий символ с
правильным ABI и правильным именем, что также потребует переопределение
искажения (коверкания) имен компилятором (<code>#[no_mangle]</code>):</p>
<pre><code class="language-ignore">#![feature(no_std)]
#![no_std]
#![no_main]
#![feature(lang_items, start)]

extern crate libc;

#[no_mangle] // для уверенности в том, что этот символ будет называться `main` на выходе
pub extern fn main(argc: i32, argv: *const *const u8) -&gt; i32 {
    0
}

#[lang = &quot;stack_exhausted&quot;] extern fn stack_exhausted() {}
#[lang = &quot;eh_personality&quot;] extern fn eh_personality() {}
#[lang = &quot;panic_fmt&quot;] fn panic_fmt() -&gt; ! { loop {} }
# // fn main() {} tricked you, rustdoc!
</code></pre>
<p>В настоящее время компилятор делает определенные предположения о символах,
которые доступны для вызова в исполняемом контейнере. Как правило, эти функции
предоставляются стандартной библиотекой, но если она не используется, то вы
должны определить их самостоятельно.</p>
<p>Первая из этих трех функций, <code>stack_exhausted</code>, вызывается тогда, когда
обнаруживается (происходит) переполнение стека. Эта функция имеет ряд
ограничений, касающихся того, как она может быть вызвана и того, что она должна
делать, но если регистр предела стека не поддерживается, то поток всегда имеет
«бесконечный стек» и эта функция не должна быть вызвана (получить управление,
срабатывать).</p>
<p>Вторая из этих трех функций, <code>eh_personality</code>, используется в механизме
обработки ошибок компилятора. Она часто отображается на функцию personality
(специализации) GCC (для получения дополнительной информации смотри <a href="http://doc.rust-lang.org/std/rt/unwind/index.html">реализацию
libstd</a>), но можно с
уверенностью сказать, что для контейнеров, которые не вызывают панику, эта
функция никогда не будет вызвана. Последняя функция, <code>panic_fmt</code>, также
используются в механизме обработки ошибок компилятора.</p>
<h2><a class="header" href="#Использование-основной-библиотеки-libcore" id="Использование-основной-библиотеки-libcore">Использование основной библиотеки (libcore)</a></h2>
<blockquote>
<p><strong>Примечание</strong>: структура основной библиотеки (core) является нестабильной, и
поэтому рекомендуется использовать стандартную библиотеку (std) там, где это
возможно.</p>
</blockquote>
<p>С учетом указанных выше методов, у нас есть чисто-металлический исполняемый код
работает Rust. Стандартная библиотека предоставляет немало функциональных
возможностей, однако, для Rust также важна производительность. Если стандартная
библиотека не соответствует этим требованиям, то вместо нее может быть
использована <a href="http://doc.rust-lang.org/core/index.html">libcore</a>.</p>
<p>Основная библиотека имеет очень мало зависимостей и гораздо более компактна, чем
стандартная библиотека. Кроме того, основная библиотека имеет большую часть
необходимой функциональности для написания идиоматического и эффективного кода
на Rust.</p>
<p>В качестве примера приведем программу, которая вычисляет скалярное произведение
двух векторов, предоставленных из кода C, и использует идиоматические практики
Rust.</p>
<pre><code class="language-ignore">#![feature(lang_items, start, no_std, core, libc)]
#![no_std]

# extern crate libc;
extern crate core;

use core::prelude::*;

use core::mem;

#[no_mangle]
pub extern fn dot_product(a: *const u32, a_len: u32,
                          b: *const u32, b_len: u32) -&gt; u32 {
    use core::raw::Slice;

    // Convert the provided arrays into Rust slices.
    // The core::raw module guarantees that the Slice
    // structure has the same memory layout as a &amp;[T]
    // slice.
    //
    // This is an unsafe operation because the compiler
    // cannot tell the pointers are valid.
    let (a_slice, b_slice): (&amp;[u32], &amp;[u32]) = unsafe {
        mem::transmute((
            Slice { data: a, len: a_len as usize },
            Slice { data: b, len: b_len as usize },
        ))
    };

    // Iterate over the slices, collecting the result
    let mut ret = 0;
    for (i, j) in a_slice.iter().zip(b_slice.iter()) {
        ret += (*i) * (*j);
    }
    return ret;
}

#[lang = &quot;panic_fmt&quot;]
extern fn panic_fmt(args: &amp;core::fmt::Arguments,
                    file: &amp;str,
                    line: u32) -&gt; ! {
    loop {}
}

#[lang = &quot;stack_exhausted&quot;] extern fn stack_exhausted() {}
#[lang = &quot;eh_personality&quot;] extern fn eh_personality() {}
# #[start] fn start(argc: isize, argv: *const *const u8) -&gt; isize { 0 }
# fn main() {}
</code></pre>
<p>Обратите внимание, что здесь, в отличае от примеров, рассмотренных выше, есть
один дополнительный lang элемент <code>panic_fmt</code>. Он должен быть определён
потребителями libcore, потому что основная библиотека объявляет панику, но не
определяет её. lang элемент <code>panic_fmt</code> определяет панику для этого
контейнера, и необходимо гарантировать, что он никогда не возвращает значение.</p>
<p>Как видно в этом примере, основная библиотека предназначена для предоставления
всей мощи Rust при любых обстоятельствах, независимо от требований платформы.
Дополнительные библиотеки, такие как liballoc, добавляют функциональность для
libcore, для работы которой нужно сделать некоторые платформо-зависимые
предположения; но эти библиотеки всё равно более переносимы, чем стандартная
библиотека в целом.</p>
<p>% Внутренние средства (intrinsics)</p>
<blockquote>
<p><strong>Примечание</strong>: внутренние средства всегда будут иметь нестабильный интерфейс,
рекомендуется использовать стабильные интерфейсы libcore, а не внутренние
напрямую.</p>
</blockquote>
<p>Они импортируются как если бы они были FFI функциями, со специальным <code>rust- intrinsic</code> ABI. Например, если, находясь в отдельном (автономном) контексте,
хочется иметь возможность <code>transmute</code> между типами, а также использовать
эффективную арифметику указателей, то можно импортировать эти функции через
объявление, такое как</p>
<pre><pre class="playpen"><code class="language-rust"># #![feature(intrinsics)]
# fn main() {}

extern &quot;rust-intrinsic&quot; {
    fn transmute&lt;T, U&gt;(x: T) -&gt; U;

    fn offset&lt;T&gt;(dst: *const T, offset: isize) -&gt; *const T;
}
</code></pre></pre>
<p>Как и с любыми другими FFI функциями, их вызов всегда небезопасен и помечен как
<code>unsafe</code>.</p>
<p>% Элементы языка (lang items)</p>
<blockquote>
<p><strong>Замечание</strong>: многие элементы языка предоставляются контейнерами в
стандартной поставке Rust, а у самих элементов языка нестабильный
интерфейс. Рекомендуется использовать официально распространяемые контейнеры,
вместо того, чтобы определять свои собственные элементы языка.</p>
</blockquote>
<p>У компилятора <code>rustc</code> есть некоторые подключаемые операции, т.е. функционал, не
встроенный жёстко в язык, а реализованный в библиотеках и специально помеченный
как элемент языка. Метка — это атрибут <code>#[lang=&quot;...&quot;]</code>. Есть различные значения
<code>...</code>, т.е.  разные «элементы языка».</p>
<p>Например, для указателей <code>Box</code> нужны два элемента языка — для выделения памяти и
для освобождения. Вот программа, не использующая стандартную библиотеку, и
реализующая <code>Box</code> через <code>malloc</code> и <code>free</code>:</p>
<pre><pre class="playpen"><code class="language-rust">#![feature(lang_items, box_syntax, start, no_std, libc)]
#![no_std]

extern crate libc;

extern {
    fn abort() -&gt; !;
}

#[lang = &quot;owned_box&quot;]
pub struct Box&lt;T&gt;(*mut T);

#[lang=&quot;exchange_malloc&quot;]
unsafe fn allocate(size: usize, _align: usize) -&gt; *mut u8 {
    let p = libc::malloc(size as libc::size_t) as *mut u8;

    // malloc завершился ошибкой
    if p as usize == 0 {
        abort();
    }

    p
}
#[lang=&quot;exchange_free&quot;]
unsafe fn deallocate(ptr: *mut u8, _size: usize, _align: usize) {
    libc::free(ptr as *mut libc::c_void)
}

#[start]
fn main(argc: isize, argv: *const *const u8) -&gt; isize {
    let x = box 1;

    0
}

#[lang = &quot;stack_exhausted&quot;] extern fn stack_exhausted() {}
#[lang = &quot;eh_personality&quot;] extern fn eh_personality() {}
#[lang = &quot;panic_fmt&quot;] fn panic_fmt() -&gt; ! { loop {} }
</code></pre></pre>
<p>Заметьте, что <code>exchange_malloc</code> должен возвращать допустимый указатель, поэтому
он производит проверку внутри и делает <code>abort</code>, если она не прошла.</p>
<p>Ниже перечислены другие возможности, предоставляемые элементами языка:</p>
<ul>
<li>перегружаемые операторы через типажи: типажи, соответствующие <code>==</code>, <code>&lt;</code>,
разыменованию (<code>*</code>), <code>+</code> и другим операторам, помечены как элементы языка;
конкретно эти типажи помечены как <code>eq</code>, <code>ord</code>, <code>deref</code> и <code>add</code>;</li>
<li>раскрутка стека и общая ошибка; это элементы <code>eh_personality</code>, <code>fail</code> и
<code>fail_bounds_check</code>;</li>
<li>типажи в модуле <code>std::marker</code>, используемые чтобы помечать различные типы;
элементы <code>send</code>, <code>sync</code> и <code>copy</code>;</li>
<li>типы-метки и индикаторы вариантности из <code>std::marker</code>; это элементы
<code>covariant_type</code>, <code>contravariant_lifetime</code> и другие.</li>
</ul>
<p>Элементы языка загружаются компилятором лениво, т.е. если программа не
использует <code>Box</code>, вам не нужно определять элементы <code>exchange_malloc</code> и
<code>exchange_free</code>. <code>rustc</code> выдаст ошибку, если элемент языка необходим, но не
найден ни в текущем контейнере, ни в его зависимостях.</p>
<p>% Продвинутое руководстве по компоновке (advanced linking)</p>
<p>Распространённые ситуации, в которых требовалась компоновка с кодом на Rust, уже
были рассмотрены в предыдущих главах книги. Однако для поддержки прозрачного
взаимодействия с нативными библиотеками требуется более широкая поддержка разных
вариантов компоновки.</p>
<h1><a class="header" href="#Аргументы-компоновки-link-args" id="Аргументы-компоновки-link-args">Аргументы компоновки (link args)</a></h1>
<p>Есть только один способ тонкой настройки компоновки — атрибут <code>link_args</code>.
Этот атрибут применяется к блокам <code>extern</code>, и указывает сырые аргументы, которые
должны быть переданы компоновщику при создании артефакта. Например:</p>
<pre><code class="language-no_run">#![feature(link_args)]

#[link_args = &quot;-foo -bar -baz&quot;]
extern {}
# fn main() {}
</code></pre>
<p>Обратите внимание, что эта возможность скрыта за <code>feature(link_args)</code>, так как
это нештатный способ компоновки. В данный момент <code>rustc</code> вызывает системный
компоновщик (на большинстве систем это <code>gcc</code>, на Windows — <code>link.exe</code>),
поэтому передача аргументов командной строки имеет смысл. Но реализация не
всегда будет такой — в будущем <code>rustc</code> может напрямую использовать LLVM для
связывания с нативными библиотеками, и тогда <code>link_args</code> станет бессмысленным.
Того же эффекта можно достигнуть с помощью передачи <code>rustc</code> аргумента <code>-C link-args</code>.</p>
<p>Крайне рекомендуется <em>не</em> использовать этот атрибут, и пользоваться вместо него
более точно определённым атрибутом <code>#link(...)</code> для блоков <code>extern</code>.</p>
<h1><a class="header" href="#Статическое-связывание" id="Статическое-связывание">Статическое связывание</a></h1>
<p>Статическое связывание — это процесс создания артефакта, который содержит все
нужные библиотеки, и потому не потребует установленных библиотек на целевой
системе. Библиотеки на Rust по умолчанию связываются статически, поэтому
приложения и библиотеки на Rust можно использовать без установки Rust повсюду.
Напротив, нативные библиотеки (например, <code>libc</code> и <code>libm</code>) обычно связываются
динамически, но это можно изменить, и сделать чтобы они также связывались
статически.</p>
<p>Компоновка — это процесс, который реализуется по-разному на разных платформах.
На некоторых из них статическое связывание вообще не возможно! Этот раздел
предполагает знакомство с процессом компоновки на вашей платформе.</p>
<h2><a class="header" href="#linux" id="linux">Linux</a></h2>
<p>По умолчанию, программы на Rust для Linux компонуются с системной <code>libc</code> и ещё
некоторыми библиотеками. Давайте посмотрим на пример на 64-битной машине с
Linux, GCC и <code>glibc</code> (самой популярной <code>libc</code> на Linux):</p>
<pre><code class="language-text">$ cat example.rs
fn main() {}
$ rustc example.rs
$ ldd example
        linux-vdso.so.1 =&gt;  (0x00007ffd565fd000)
        libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fa81889c000)
        libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fa81867e000)
        librt.so.1 =&gt; /lib/x86_64-linux-gnu/librt.so.1 (0x00007fa818475000)
        libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007fa81825f000)
        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fa817e9a000)
        /lib64/ld-linux-x86-64.so.2 (0x00007fa818cf9000)
        libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007fa817b93000)
</code></pre>
<p>Иногда динамическое связывание на Linux нежелательно: например, если вы хотите
использовать возможности из новых библиотек на старых системах или на целевых
системах нет таких библиотек.</p>
<p>Статическое связывание возможно с альтернативной <code>libc</code>, <code>musl</code>. Вы можете
скомпилировать свою версию Rust, которая будет использовать <code>musl</code>, и установить
её в отдельную директорию, с помощью инструкции, приведённой ниже:</p>
<pre><code class="language-text">$ mkdir musldist
$ PREFIX=$(pwd)/musldist
$
$ # Build musl
$ wget http://www.musl-libc.org/releases/musl-1.1.10.tar.gz
[...]
$ tar xf musl-1.1.10.tar.gz
$ cd musl-1.1.10/
musl-1.1.10 $ ./configure --disable-shared --prefix=$PREFIX
[...]
musl-1.1.10 $ make
[...]
musl-1.1.10 $ make install
[...]
musl-1.1.10 $ cd ..
$ du -h musldist/lib/libc.a
2.2M    musldist/lib/libc.a
$
$ # Build libunwind.a
$ wget http://llvm.org/releases/3.6.1/llvm-3.6.1.src.tar.xz
$ tar xf llvm-3.6.1.src.tar.xz
$ cd llvm-3.6.1.src/projects/
llvm-3.6.1.src/projects $ svn co http://llvm.org/svn/llvm-project/libcxxabi/trunk/ libcxxabi
llvm-3.6.1.src/projects $ svn co http://llvm.org/svn/llvm-project/libunwind/trunk/ libunwind
llvm-3.6.1.src/projects $ sed -i 's#^\(include_directories\).*$#\0\n\1(../libcxxabi/include)#' libunwind/CMakeLists.txt
llvm-3.6.1.src/projects $ mkdir libunwind/build
llvm-3.6.1.src/projects $ cd libunwind/build
llvm-3.6.1.src/projects/libunwind/build $ cmake -DLLVM_PATH=../../.. -DLIBUNWIND_ENABLE_SHARED=0 ..
llvm-3.6.1.src/projects/libunwind/build $ make
llvm-3.6.1.src/projects/libunwind/build $ cp lib/libunwind.a $PREFIX/lib/
llvm-3.6.1.src/projects/libunwind/build $ cd cd ../../../../
$ du -h musldist/lib/libunwind.a
164K    musldist/lib/libunwind.a
$
$ # Build musl-enabled rust
$ git clone https://github.com/rust-lang/rust.git muslrust
$ cd muslrust
muslrust $ ./configure --target=x86_64-unknown-linux-musl --musl-root=$PREFIX --prefix=$PREFIX
muslrust $ make
muslrust $ make install
muslrust $ cd ..
$ du -h musldist/bin/rustc
12K     musldist/bin/rustc
</code></pre>
<p>Теперь у вас есть сборка Rust с <code>musl</code>! Поскольку мы установили её в отдельную
корневую директорию, надо удостовериться в том, что система может найти
исполняемые файлы и библиотеки:</p>
<pre><code class="language-text">$ export PATH=$PREFIX/bin:$PATH
$ export LD_LIBRARY_PATH=$PREFIX/lib:$LD_LIBRARY_PATH
</code></pre>
<p>Давайте попробуем!</p>
<pre><code class="language-text">$ echo 'fn main() { println!(&quot;hi!&quot;); panic!(&quot;failed&quot;); }' &gt; example.rs
$ rustc --target=x86_64-unknown-linux-musl example.rs
$ ldd example
        not a dynamic executable
$ ./example
hi!
thread '&lt;main&gt;' panicked at 'failed', example.rs:1
</code></pre>
<p>Успех! Эта программа может быть скопирована на почти любую машину с Linux с той
же архитектурой процессора и будет работать без проблем.</p>
<p><code>cargo build</code> также принимает опцию <code>--target</code>, так что вы можете собирать
контейнеры как обычно. Однако, возможно вам придётся пересобрать нативные
библиотеки с <code>musl</code>, чтобы иметь возможность скомпоноваться с ними.</p>
<p>% Тесты производительности</p>
<p>Rust поддерживает тесты производительности, которые помогают измерить
производительность вашего кода. Давайте изменим наш <code>src/lib.rs</code>, чтобы он
выглядел следующим образом (комментарии опущены):</p>
<pre><code class="language-rust ignore">#![feature(test)]

extern crate test;

pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;
    use test::Bencher;

    #[test]
    fn it_works() {
        assert_eq!(4, add_two(2));
    }

    #[bench]
    fn bench_add_two(b: &amp;mut Bencher) {
        b.iter(|| add_two(2));
    }
}
</code></pre>
<p>Обратите внимание на включение возможности (feature gate) <code>test</code>, что включает
эту нестабильную возможность.</p>
<p>Мы импортировали контейнер <code>test</code>, который включает поддержку измерения
производительности. У нас есть новая функция, аннотированная с помощью атрибута
<code>bench</code>. В отличие от обычных тестов, которые не принимают никаких аргументов,
тесты производительности в качестве аргумента принимают <code>&amp;mut Bencher</code>.
<code>Bencher</code> предоставляет метод <code>iter</code>, который в качестве аргумента принимает
замыкание. Это замыкание содержит код, производительность которого мы хотели бы
протестировать.</p>
<p>Запуск тестов производительности осуществляется командой <code>cargo bench</code>:</p>
<pre><code class="language-bash">$ cargo bench
   Compiling adder v0.0.1 (file:///home/steve/tmp/adder)
     Running target/release/adder-91b3e234d4ed382a

running 2 tests
test tests::it_works ... ignored
test tests::bench_add_two ... bench:         1 ns/iter (+/- 0)

test result: ok. 0 passed; 0 failed; 1 ignored; 1 measured
</code></pre>
<p>Все тесты, не относящиеся к тестам производительности, были проигнорированы. Вы,
наверное, заметили, что выполнение <code>cargo bench</code> занимает немного больше времени
чем <code>cargo test</code>. Это происходит потому, что Rust запускает наш тест несколько
раз, а затем выдает среднее значение. Так как мы выполняем слишком мало полезной
работы в этом примере, у нас получается <code>1 ns/iter (+/- 0)</code>, но была бы выведена
дисперсия, если бы был один.</p>
<p>Советы по написанию тестов производительности:</p>
<ul>
<li>Внутри <code>iter</code> цикла пишите только тот код, производительность которого вы
хотите измерить; инициализацию выполняйте за пределами <code>iter</code> цикла</li>
<li>Внутри <code>iter</code> цикла пишите код, который будет идемпотентным (будет делать «то
же самое» на каждой итерации); не накапливайте и не изменяйте состояние</li>
<li>Вне <code>iter</code> цикла пишите код который также будет идемпотентным; скорее всего,
он будет запущен много раз во время теста</li>
<li>Внутри <code>iter</code> цикла пишите код, который будет коротким и быстрым, так чтобы
запуски тестов происходили быстро и калибратор мог настроить длину пробега с
точным разрешением</li>
<li>Внутри <code>iter</code> цикла пишите код, делающий что-то простое, чтобы помочь в
выявлении улучшения (или уменьшения) производительности</li>
</ul>
<h2><a class="header" href="#Особенности-оптимизации" id="Особенности-оптимизации">Особенности оптимизации</a></h2>
<p>А вот другой сложный момент, относящийся к написанию тестов производительности:
тесты, скомпилированные с оптимизацией, могут быть значительно изменены
оптимизатором, после чего тест будет мерить производительность не так, как мы
этого ожидаем. Например, компилятор может определить, что некоторые выражения не
оказывают каких-либо внешних эффектов и просто удалит их полностью.</p>
<pre><code class="language-rust ignore">#![feature(test)]

extern crate test;
use test::Bencher;

#[bench]
fn bench_xor_1000_ints(b: &amp;mut Bencher) {
    b.iter(|| {
        (0..1000).fold(0, |old, new| old ^ new);
    });
}
</code></pre>
<p>выведет следующие результаты</p>
<pre><code class="language-text">running 1 test
test bench_xor_1000_ints ... bench:         0 ns/iter (+/- 0)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured
</code></pre>
<p>Движок для запуска тестов производительности оставляет две возможности,
позволяющие этого избежать. Либо использовать замыкание, передаваемое в метод
<code>iter</code>, которое возвращает какое-либо значение; тогда это заставит оптимизатор
думать, что возвращаемое значение будет использовано, из-за чего удалить
вычисления полностью будет не возможно. Для примера выше этого можно достигнуть,
изменив вызова <code>b.iter</code></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct X;
# impl X { fn iter&lt;T, F&gt;(&amp;self, _: F) where F: FnMut() -&gt; T {} } let b = X;
b.iter(|| {
    // note lack of `;` (could also use an explicit `return`).
    (0..1000).fold(0, |old, new| old ^ new)
});
#}</code></pre></pre>
<p>Либо использовать вызов функции <code>test::black_box</code>, которая представляет собой
«черный ящик», непрозрачный для оптимизатора, тем самым заставляя его
рассматривать любой аргумент как используемый.</p>
<pre><pre class="playpen"><code class="language-rust">#![feature(test)]

extern crate test;

# fn main() {
# struct X;
# impl X { fn iter&lt;T, F&gt;(&amp;self, _: F) where F: FnMut() -&gt; T {} } let b = X;
b.iter(|| {
    let n = test::black_box(1000);

    (0..n).fold(0, |a, b| a ^ b)
})
# }
</code></pre></pre>
<p>В этом примере не происходит ни чтения, ни изменения значения, что очень дешево
для малых значений. Большие значения могут быть переданы косвенно для уменьшения
издержек (например, <code>black_box(&amp;huge_struct)</code>).</p>
<p>Выполнение одного из вышеперечисленных изменений дает следующие результаты
измерения производительности</p>
<pre><code class="language-text">running 1 test
test bench_xor_1000_ints ... bench:       131 ns/iter (+/- 3)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured
</code></pre>
<p>Тем не менее, оптимизатор все еще может вносить нежелательные изменения в
определенных случаях, даже при использовании любого из вышеописанных приемов.</p>
<p>% Синтаксис упаковки и шаблоны <code>match</code></p>
<p>В настоящее время единственный стабильный способ создания <code>Box</code> — это создание с
помощью метода <code>Box::new</code>. В стабильной сборке Rust также невозможно
деструктурировать <code>Box</code> при использовании сопоставления с шаблоном. В
нестабильной сборке может быть использовано ключевое слово <code>box</code>, как для
создания, так и для деструктуризации <code>Box</code>. Ниже представлен пример
использования:</p>
<pre><pre class="playpen"><code class="language-rust">#![feature(box_syntax, box_patterns)]

fn main() {
    let b = Some(box 5);
    match b {
        Some(box n) if n &lt; 0 =&gt; {
            println!(&quot;Box contains negative number {}&quot;, n);
        },
        Some(box n) if n &gt;= 0 =&gt; {
            println!(&quot;Box contains non-negative number {}&quot;, n);
        },
        None =&gt; {
            println!(&quot;No box&quot;);
        },
        _ =&gt; unreachable!()
    }
}
</code></pre></pre>
<p>Обратите внимание, что эти возможности в настоящее время являются скрытыми:
<code>box_syntax</code> (создание упаковки) и <code>box_patterns</code> (деструктурирование и
сопоставление с образцом), потому что синтаксис все еще может измениться в
будущем.</p>
<h1><a class="header" href="#Возврат-указателей" id="Возврат-указателей">Возврат указателей</a></h1>
<p>Во многих языках с указателями, вы можете вернуть указатель из функции, чтобы
таким образом избежать копирования большой структуры данных. Например:</p>
<pre><pre class="playpen"><code class="language-rust">struct BigStruct {
    one: i32,
    two: i32,
    // etc
    one_hundred: i32,
}

fn foo(x: Box&lt;BigStruct&gt;) -&gt; Box&lt;BigStruct&gt; {
    Box::new(*x)
}

fn main() {
    let x = Box::new(BigStruct {
        one: 1,
        two: 2,
        one_hundred: 100,
    });

    let y = foo(x);
}
</code></pre></pre>
<p>Идея состоит в том, что, при передаче упаковки, происходит копирование только
указателя, а не всех <code>int</code>, из которых состоит <code>BigStruct</code>.</p>
<p>Это антипаттерн в Rust. Вместо этого следует написать так:</p>
<pre><pre class="playpen"><code class="language-rust">#![feature(box_syntax)]

struct BigStruct {
    one: i32,
    two: i32,
    // etc
    one_hundred: i32,
}

fn foo(x: Box&lt;BigStruct&gt;) -&gt; BigStruct {
    *x
}

fn main() {
    let x = Box::new(BigStruct {
        one: 1,
        two: 2,
        one_hundred: 100,
    });

    let y: Box&lt;BigStruct&gt; = box foo(x);
}
</code></pre></pre>
<p>Это дает вам гибкость без ущерба для производительности.</p>
<p>Вы можете подумать, что такое использование даст нам ужасную производительность:
возвращается значение, а затем оно сразу упаковывается?! Разве это не паттерн
худшего из двух миров? Rust намного умнее. В этом коде не происходит
копирование. <code>main</code> выделяет достаточно места для <code>box</code>, передает указатель на
эту память в <code>foo</code> в виде <code>x</code>, а затем <code>foo</code> записывает значение прямо в
<code>Box&lt;T&gt;</code>.</p>
<p>Это достаточно важно, поэтому стоит повторить: указатели не для оптимизации
возвращаемых значений в коде. Позвольте вызывающей стороне самой выбрать, как
она хочет использовать выход.</p>
<p>% Шаблоны <code>match</code> для срезов</p>
<p>Если вы хотите в качестве шаблона для сопоставления использовать срез или
массив, то вы можете использовать <code>&amp;</code> и активировать возможность
<code>slice_patterns</code>:</p>
<pre><pre class="playpen"><code class="language-rust">#![feature(slice_patterns)]

fn main() {
    let v = vec![&quot;match_this&quot;, &quot;1&quot;];

    match &amp;v[..] {
        [&quot;match_this&quot;, second] =&gt; println!(&quot;The second element is {}&quot;, second),
        _ =&gt; {},
    }
}
</code></pre></pre>
<p>Отключаемая возможность <code>advanced_slice_patterns</code> позволяет использовать <code>..</code>,
чтобы обозначить любое число элементов в шаблоне. Этот символ подстановки можно
использовать в массиве один раз. Если перед <code>..</code> есть идентификатор, результат
среза будет связан с этим именем. Например:</p>
<pre><pre class="playpen"><code class="language-rust">#![feature(advanced_slice_patterns, slice_patterns)]

fn is_symmetric(list: &amp;[u32]) -&gt; bool {
    match list {
        [] | [_] =&gt; true,
        [x, inside.., y] if x == y =&gt; is_symmetric(inside),
        _ =&gt; false
    }
}

fn main() {
    let sym = &amp;[0, 1, 4, 2, 4, 1, 0];
    assert!(is_symmetric(sym));

    let not_sym = &amp;[0, 1, 7, 2, 4, 1, 0];
    assert!(!is_symmetric(not_sym));
}
</code></pre></pre>
<p>% Ассоциированные константы</p>
<p>С включенной возможностью <code>associated_consts</code> вы можете определить константы
вроде этой:</p>
<pre><pre class="playpen"><code class="language-rust">#![feature(associated_consts)]

trait Foo {
    const ID: i32;
}

impl Foo for i32 {
    const ID: i32 = 1;
}

fn main() {
    assert_eq!(1, i32::ID);
}
</code></pre></pre>
<p>Любая реализация <code>Foo</code> должна будет определить <code>ID</code>. Без этого определения:</p>
<pre><code class="language-rust ignore">#![feature(associated_consts)]

trait Foo {
    const ID: i32;
}

impl Foo for i32 {
}
</code></pre>
<p>выдаст ошибку</p>
<pre><code class="language-text">error: not all trait items implemented, missing: `ID` [E0046]
     impl Foo for i32 {
     }
</code></pre>
<p>Также может быть реализовано значение по умолчанию:</p>
<pre><pre class="playpen"><code class="language-rust">#![feature(associated_consts)]

trait Foo {
    const ID: i32 = 1;
}

impl Foo for i32 {
}

impl Foo for i64 {
    const ID: i32 = 5;
}

fn main() {
    assert_eq!(1, i32::ID);
    assert_eq!(5, i64::ID);
}
</code></pre></pre>
<p>Как вы можете видеть, при реализации <code>Foo</code>, можно оставить константу
неопределенной, как в случае для <code>i32</code>. Тогда будет использовано значение по
умолчанию. Но также можно и добавить собственное определение, как в случае для
<code>i64</code>.</p>
<p>Ассоциированные константы могут быть ассоциированы не только с типажом. Это
также прекрасно работает и с блоком <code>impl</code> для <code>struct</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#![feature(associated_consts)]

#fn main() {
struct Foo;

impl Foo {
    pub const FOO: u32 = 3;
}
#}</code></pre></pre>
<p>% Пользовательские менеджеры памяти</p>
<p>Выделение памяти — это не самая простая задача, и Rust обычно заботится об этом
сам, но часто нужно тонко управлять выделением памяти. Компилятор и стандартная
библиотека в настоящее время позволяют глобально переключить используемый
менеджер во время компиляции. Описание сейчас находится в <a href="https://github.com/rust-lang/rfcs/blob/master/text/1183-swap-out-jemalloc.md">RFC 1183</a>, но
здесь мы рассмотрим как сделать ваш собственный менеджер.</p>
<h1><a class="header" href="#Стандартный-менеджер-памяти" id="Стандартный-менеджер-памяти">Стандартный менеджер памяти</a></h1>
<p>В настоящее время компилятор содержит два стандартных менеджера: <code>alloc_system</code>
и <code>alloc_jemalloc</code> (однако у некоторых платформ отсутствует jemalloc).
Эти менеджеры стандартны для контейнеров Rust и содержат реализацию подпрограмм
для выделения и освобождения памяти. Стандартная библиотека не компилируется
специально для использования только одного из них. Компилятор будет решать какой
менеджер использовать во время компиляции в зависимости от типа производимых
выходных артефактов.</p>
<p>По умолчанию исполняемые файлы сгенерированные компилятором будут использовать
<code>alloc_jemalloc</code> (там где возможно). В таком случае компилятор &quot;контролирует
весь мир&quot;, в том смысле что у него есть власть над окончательной компоновкой.</p>
<p>Однако динамические и статические библиотеки по умолчанию будут использовать
<code>alloc_system</code>. Здесь Rust обычно в роли гостя в другом приложении или вообще в
другом мире, где он не может авторитетно решать какой менеджер использовать.
В результате он возвращается назад к стандартным API (таких как <code>malloc</code> и
<code>free</code>), для получения и освобождения памяти.</p>
<h1><a class="header" href="#Переключение-менеджеров-памяти" id="Переключение-менеджеров-памяти">Переключение менеджеров памяти</a></h1>
<p>Несмотря на то что в большинстве случаев нам подойдёт то, что компилятор выбирает
по умолчанию, часто бывает необходимо настроить определенные аспекты. Для того,
чтобы переопределить решение компилятора о том, какой именно менеджер
использовать, достаточно просто скомпоновать с желаемым менеджером:</p>
<pre><pre class="playpen"><code class="language-rust no_run">#![feature(alloc_system)]

extern crate alloc_system;

fn main() {
    let a = Box::new(4); // выделение памяти с помощью системного менеджера
    println!(&quot;{}&quot;, a);
}
</code></pre></pre>
<p>В этом примере сгенерированный исполняемый файл будет скомпонован с системным
менеджером, вместо менеджера по умолчанию — jemalloc. И наоборот, чтобы
сгенерировать динамическую библиотеку, которая использует jemalloc по умолчанию
нужно написать:</p>
<pre><code class="language-rust ignore">#![feature(alloc_jemalloc)]
#![crate_type = &quot;dylib&quot;]

extern crate alloc_jemalloc;

pub fn foo() {
    let a = Box::new(4); // выделение памяти с помощью jemalloc
    println!(&quot;{}&quot;, a);
}
# fn main() {}
</code></pre>
<h1><a class="header" href="#Написание-своего-менеджера-памяти" id="Написание-своего-менеджера-памяти">Написание своего менеджера памяти</a></h1>
<p>Иногда даже выбора между jemalloc и системным менеджером недостаточно и
необходим совершенно новый менеджер памяти. В этом случае мы напишем наш
собственный контейнер, который будет предоставлять API менеджера памяти (также
как и <code>alloc_system</code> или <code>alloc_jemalloc</code>). Для примера давайте рассмотрим
упрощенную и аннотированную версию <code>alloc_system</code>:</p>
<pre><pre class="playpen"><code class="language-rust no_run"># // only needed for rustdoc --test down below
# #![feature(lang_items)]
// Компилятору нужно указать, что этот контейнер является менеджером памяти, для
// того что бы при компоновке он не использовал другой менеджер.
#![feature(allocator)]
#![allocator]

// Менеджерам памяти не позволяют зависеть от стандартной библиотеки, которая в
// свою очередь зависит от менеджера, чтобы избежать циклической зависимости.
// Однако этот контейнер может использовать все из libcore.
#![no_std]

// Давайте дадим какое-нибудь уникальное имя нашему менеджеру.
#![crate_name = &quot;my_allocator&quot;]
#![crate_type = &quot;rlib&quot;]

// Наш системный менеджер будет использовать поставляемый вместе с компилятором
// контейнер libc для связи с FFI. Имейте ввиду, что на данный момент внешний
// (crates.io) libc не может быть использован, поскольку он компонуется со
// стандартной библиотекой (`#![no_std]` все еще нестабилен).
#![feature(libc)]
extern crate libc;

// Ниже перечислены пять функций, необходимые пользовательскому менеджеру памяти.
// Их сигнатуры и имена на данный момент не проверяются компилятором, но это
// вскоре будет реализовано, так что они должны соответствовать тому, что
// находится ниже.
//
// Имейте ввиду, что стандартные `malloc` и `realloc` не предоставляют опций для
// выравнивания, так что эта реализация должна быть улучшена и поддерживать
// выравнивание.
#[no_mangle]
pub extern fn __rust_allocate(size: usize, _align: usize) -&gt; *mut u8 {
    unsafe { libc::malloc(size as libc::size_t) as *mut u8 }
}

#[no_mangle]
pub extern fn __rust_deallocate(ptr: *mut u8, _old_size: usize, _align: usize) {
    unsafe { libc::free(ptr as *mut libc::c_void) }
}

#[no_mangle]
pub extern fn __rust_reallocate(ptr: *mut u8, _old_size: usize, size: usize,
                                _align: usize) -&gt; *mut u8 {
    unsafe {
        libc::realloc(ptr as *mut libc::c_void, size as libc::size_t) as *mut u8
    }
}

#[no_mangle]
pub extern fn __rust_reallocate_inplace(_ptr: *mut u8, old_size: usize,
                                        _size: usize, _align: usize) -&gt; usize {
    old_size // libc не поддерживает этот API
}

#[no_mangle]
pub extern fn __rust_usable_size(size: usize, _align: usize) -&gt; usize {
    size
}

# // just needed to get rustdoc to test this
# fn main() {}
# #[lang = &quot;panic_fmt&quot;] fn panic_fmt() {}
# #[lang = &quot;eh_personality&quot;] fn eh_personality() {}
# #[lang = &quot;eh_unwind_resume&quot;] extern fn eh_unwind_resume() {}
# #[no_mangle] pub extern fn rust_eh_register_frames () {}
# #[no_mangle] pub extern fn rust_eh_unregister_frames () {}
</code></pre></pre>
<p>После того как мы скомпилировали этот контейнер, мы можем использовать его
следующим образом:</p>
<pre><code class="language-rust ignore">extern crate my_allocator;

fn main() {
    let a = Box::new(8); // выделение памяти с помощью нашего контейнера
    println!(&quot;{}&quot;, a);
}
</code></pre>
<h1><a class="header" href="#Ограничения-пользовательских-менеджеров-памяти" id="Ограничения-пользовательских-менеджеров-памяти">Ограничения пользовательских менеджеров памяти</a></h1>
<p>Несколько ограничений при работе с пользовательским менеджером памяти, которые
могут быть причиной ошибок компиляции:</p>
<ul>
<li>
<p>Любой артефакт может быть скомпонован только с одним менеджером. Исполняемые
файлы, динамические библиотеки и статические библиотеки должны быть
скомпонованы с одним менеджером, и если не один не был указан, то компилятор
сам выберет один. В то же время Rust библиотеки (rlibs) не нуждаются в
компоновке с менеджером (но это возможно).</p>
</li>
<li>
<p>Потребитель какого-либо менеджера памяти имеет пометку <code>#![needs_allocator]</code>
(в данном случае контейнер <code>liballoc</code>) и какой-либо контейнер <code>#[allocator]</code>
не может транзитивно зависеть от контейнера, которому нужен менеджер (т.е.
циклическая зависимость не допускается). Это означает, что менеджеры памяти в
данный момент должны ограничить себя только libcore.</p>
</li>
</ul>
<p>% Глоссарий</p>
<p>Не каждый пользователь Rust имеет опыт работы с системами программирования, или
необходимые знания в области компьютерной науки, поэтому мы добавили разъяснения
терминов, которые могут быть незнакомы.</p>
<p><a name="abstract-syntax-tree"></a></p>
<h3><a class="header" href="#Абстрактное-синтаксическое-дерево" id="Абстрактное-синтаксическое-дерево">Абстрактное синтаксическое дерево</a></h3>
<p>Когда компилятор компилирует программу, он делает целый ряд различных вещей.
Одна из вещей, которые он делает, это преобразует текст вашей программы в
'Абстрактное синтаксическое дерево,' или 'AST.' Это дерево является
представлением структуры вашей программы. Например, <code>2 + 3</code> может быть
преобразовано в дерево:</p>
<pre><code class="language-text">  +
 / \
2   3
</code></pre>
<p>А <code>2 + (3 * 4)</code> будет выглядеть следующим образом:</p>
<pre><code class="language-text">  +
 / \
2   *
   / \
  3   4
</code></pre>
<p><a name="arity"></a></p>
<h3><a class="header" href="#Арность" id="Арность">Арность</a></h3>
<p>Арность означает число аргументов, которые принимает функция или операция.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let x = (2, 3);
let y = (4, 6);
let z = (8, 2, 6);
#}</code></pre></pre>
<p>В приведенном выше примере <code>x</code> и <code>y</code> имеют арность 2. <code>z</code> имеет арность 3.</p>
<p><a name="expression"></a></p>
<h3><a class="header" href="#Выражение" id="Выражение">Выражение</a></h3>
<p>В программировании, выражение — это комбинация значений, постоянных,
переменных и функций, которая вычисляется в одно значение. Например, <code>2 + (3 * 4)</code> — выражение, вычисляющееся в значение <code>14</code>. Стоит заметить, что у
выражений могут быть побочные эффекты. Например, функция, участвующая в
выражении, может делать что-то ещё помимо непосредственно возврата значения.</p>
<p><a name="expression-oriented-language"></a></p>
<h3><a class="header" href="#Язык-ориентированный-на-выражения" id="Язык-ориентированный-на-выражения">Язык, ориентированный на выражения</a></h3>
<p>В ранних языках программирования <a href="glossary.html#expression">выражения</a> и
<a href="glossary.html#statement">операторы</a> были двумя отдельными видами синтаксиса: выражения
вычислялись в выражение, а операторы производили действия с побочными эффектами.
Однако поздние языки уже не имели такого чёткого разделения по этому критерию. В
языке, ориентированном на выражения, почти любой оператор — это выражение, а
значит, оно возвращает значение. Следовательно, эти выражения могут сами
являться частью ещё больших выражений.</p>
<p><a name="statement"></a></p>
<h3><a class="header" href="#Оператор" id="Оператор">Оператор</a></h3>
<p>В программировании, оператор — это наименьший отдельный элемент языка, который
обозначает выполнение компьютером законченного действия. Например, в языке C
<code>printf(&quot;42&quot;);</code> — это оператор.</p>
<p>% Syntax Index</p>
<h2><a class="header" href="#keywords" id="keywords">Keywords</a></h2>
<ul>
<li><code>as</code>: primitive casting.  See <a href="casting-between-types.html#as">Casting Between Types (<code>as</code>)</a>.</li>
<li><code>break</code>: break out of loop.  See <a href="loops.html#ending-iteration-early">Loops (Ending Iteration Early)</a>.</li>
<li><code>const</code>: constant items and constant raw pointers.  See <a href="const-and-static.html"><code>const</code> and <code>static</code></a>, <a href="raw-pointers.html">Raw Pointers</a>.</li>
<li><code>continue</code>: continue to next loop iteration.  See <a href="loops.html#ending-iteration-early">Loops (Ending Iteration Early)</a>.</li>
<li><code>crate</code>: external crate linkage.  See <a href="crates-and-modules.html#importing-external-crates">Crates and Modules (Importing External Crates)</a>.</li>
<li><code>else</code>: fallback for <code>if</code> and <code>if let</code> constructs.  See <a href="if.html"><code>if</code></a>, <a href="if-let.html"><code>if let</code></a>.</li>
<li><code>enum</code>: defining enumeration.  See <a href="enums.html">Enums</a>.</li>
<li><code>extern</code>: external crate, function, and variable linkage.  See <a href="crates-and-modules.html#importing-external-crates">Crates and Modules (Importing External Crates)</a>, <a href="ffi.html">Foreign Function Interface</a>.</li>
<li><code>false</code>: boolean false literal.  See <a href="primitive-types.html#booleans">Primitive Types (Booleans)</a>.</li>
<li><code>fn</code>: function definition and function pointer types.  See <a href="functions.html">Functions</a>.</li>
<li><code>for</code>: iterator loop, part of trait <code>impl</code> syntax, and higher-ranked lifetime syntax.  See <a href="loops.html#for">Loops (<code>for</code>)</a>, <a href="method-syntax.html">Method Syntax</a>.</li>
<li><code>if</code>: conditional branching.  See <a href="if.html"><code>if</code></a>, <a href="if-let.html"><code>if let</code></a>.</li>
<li><code>impl</code>: inherent and trait implementation blocks.  See <a href="method-syntax.html">Method Syntax</a>.</li>
<li><code>in</code>: part of <code>for</code> loop syntax.  See <a href="loops.html#for">Loops (<code>for</code>)</a>.</li>
<li><code>let</code>: variable binding.  See <a href="variable-bindings.html">Variable Bindings</a>.</li>
<li><code>loop</code>: unconditional, infinite loop.  See <a href="loops.html#loop">Loops (<code>loop</code>)</a>.</li>
<li><code>match</code>: pattern matching.  See <a href="match.html">Match</a>.</li>
<li><code>mod</code>: module declaration.  See <a href="crates-and-modules.html#defining-modules">Crates and Modules (Defining Modules)</a>.</li>
<li><code>move</code>: part of closure syntax.  See <a href="closures.html#move-closures">Closures (<code>move</code> closures)</a>.</li>
<li><code>mut</code>: denotes mutability in pointer types and pattern bindings.  See <a href="mutability.html">Mutability</a>.</li>
<li><code>pub</code>: denotes public visibility in <code>struct</code> fields, <code>impl</code> blocks, and modules.  See <a href="crates-and-modules.html#exporting-a-public-interface">Crates and Modules (Exporting a Public Interface)</a>.</li>
<li><code>ref</code>: by-reference binding.  See <a href="patterns.html#ref-and-ref-mut">Patterns (<code>ref</code> and <code>ref mut</code>)</a>.</li>
<li><code>return</code>: return from function.  See <a href="functions.html#early-returns">Functions (Early Returns)</a>.</li>
<li><code>Self</code>: implementor type alias.  See <a href="traits.html">Traits</a>.</li>
<li><code>self</code>: method subject.  See <a href="method-syntax.html#method-calls">Method Syntax (Method Calls)</a>.</li>
<li><code>static</code>: global variable.  See <a href="const-and-static.html#static"><code>const</code> and <code>static</code> (<code>static</code>)</a>.</li>
<li><code>struct</code>: structure definition.  See <a href="structs.html">Structs</a>.</li>
<li><code>trait</code>: trait definition.  See <a href="traits.html">Traits</a>.</li>
<li><code>true</code>: boolean true literal.  See <a href="primitive-types.html#booleans">Primitive Types (Booleans)</a>.</li>
<li><code>type</code>: type alias, and associated type definition.  See <a href="type-aliases.html"><code>type</code> Aliases</a>, <a href="associated-types.html">Associated Types</a>.</li>
<li><code>unsafe</code>: denotes unsafe code, functions, traits, and implementations.  See <a href="unsafe.html">Unsafe</a>.</li>
<li><code>use</code>: import symbols into scope.  See <a href="crates-and-modules.html#importing-modules-with-use">Crates and Modules (Importing Modules with <code>use</code>)</a>.</li>
<li><code>where</code>: type constraint clauses.  See <a href="traits.html#where-clause">Traits (<code>where</code> clause)</a>.</li>
<li><code>while</code>: conditional loop.  See <a href="loops.html#while">Loops (<code>while</code>)</a>.</li>
</ul>
<h2><a class="header" href="#operators-and-symbols" id="operators-and-symbols">Operators and Symbols</a></h2>
<ul>
<li><code>!</code> (<code>ident!(…)</code>, <code>ident!{…}</code>, <code>ident![…]</code>): denotes macro expansion.  See <a href="macros.html">Macros</a>.</li>
<li><code>!</code> (<code>!expr</code>): bitwise or logical complement.  Overloadable (<code>Not</code>).</li>
<li><code>%</code> (<code>expr % expr</code>): arithmetic remainder.  Overloadable (<code>Rem</code>).</li>
<li><code>%=</code> (<code>var %= expr</code>): arithmetic remainder &amp; assignment.</li>
<li><code>&amp;</code> (<code>expr &amp; expr</code>): bitwise and.  Overloadable (<code>BitAnd</code>).</li>
<li><code>&amp;</code> (<code>&amp;expr</code>): borrow.  See <a href="references-and-borrowing.html">References and Borrowing</a>.</li>
<li><code>&amp;</code> (<code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code>): borrowed pointer type.  See <a href="references-and-borrowing.html">References and Borrowing</a>.</li>
<li><code>&amp;=</code> (<code>var &amp;= expr</code>): bitwise and &amp; assignment.</li>
<li><code>&amp;&amp;</code> (<code>expr &amp;&amp; expr</code>): logical and.</li>
<li><code>*</code> (<code>expr * expr</code>): arithmetic multiplication.  Overloadable (<code>Mul</code>).</li>
<li><code>*</code> (<code>*expr</code>): dereference.</li>
<li><code>*</code> (<code>*const type</code>, <code>*mut type</code>): raw pointer.  See <a href="raw-pointers.html">Raw Pointers</a>.</li>
<li><code>*=</code> (<code>var *= expr</code>): arithmetic multiplication &amp; assignment.</li>
<li><code>+</code> (<code>expr + expr</code>): arithmetic addition.  Overloadable (<code>Add</code>).</li>
<li><code>+</code> (<code>trait + trait</code>, <code>'a + trait</code>): compound type constraint.  See <a href="traits.html#multiple-trait-bounds">Traits (Multiple Trait Bounds)</a>.</li>
<li><code>+=</code> (<code>var += expr</code>): arithmetic addition &amp; assignment.</li>
<li><code>,</code>: argument and element separator.  See <a href="attributes.html">Attributes</a>, <a href="functions.html">Functions</a>, <a href="structs.html">Structs</a>, <a href="generics.html">Generics</a>, <a href="match.html">Match</a>, <a href="closures.html">Closures</a>, <a href="crates-and-modules.html#importing-modules-with-use">Crates and Modules (Importing Modules with <code>use</code>)</a>.</li>
<li><code>-</code> (<code>expr - expr</code>): arithmetic subtraction.  Overloadable (<code>Sub</code>).</li>
<li><code>-</code> (<code>- expr</code>): arithmetic negation.  Overloadable (<code>Neg</code>).</li>
<li><code>-=</code> (<code>var -= expr</code>): arithmetic subtraction &amp; assignment.</li>
<li><code>-&gt;</code> (<code>fn(…) -&gt; type</code>, <code>|…| -&gt; type</code>): function and closure return type.  See <a href="functions.html">Functions</a>, <a href="closures.html">Closures</a>.</li>
<li><code>-&gt; !</code> (<code>fn(…) -&gt; !</code>, <code>|…| -&gt; !</code>): diverging function or closure. See <a href="functions.html#diverging-functions">Diverging Functions</a>.</li>
<li><code>.</code> (<code>expr.ident</code>): member access.  See <a href="structs.html">Structs</a>, <a href="method-syntax.html">Method Syntax</a>.</li>
<li><code>..</code> (<code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code>): right-exclusive range literal.</li>
<li><code>..</code> (<code>..expr</code>): struct literal update syntax.  See <a href="structs.html#update-syntax">Structs (Update syntax)</a>.</li>
<li><code>..</code> (<code>variant(x, ..)</code>, <code>struct_type { x, .. }</code>): &quot;and the rest&quot; pattern binding.  See <a href="patterns.html#ignoring-bindings">Patterns (Ignoring bindings)</a>.</li>
<li><code>...</code> (<code>expr ... expr</code>): inclusive range pattern.  See <a href="patterns.html#ranges">Patterns (Ranges)</a>.</li>
<li><code>/</code> (<code>expr / expr</code>): arithmetic division.  Overloadable (<code>Div</code>).</li>
<li><code>/=</code> (<code>var /= expr</code>): arithmetic division &amp; assignment.</li>
<li><code>:</code> (<code>pat: type</code>, <code>ident: type</code>): constraints.  See <a href="variable-bindings.html">Variable Bindings</a>, <a href="functions.html">Functions</a>, <a href="structs.html">Structs</a>, <a href="traits.html">Traits</a>.</li>
<li><code>:</code> (<code>ident: expr</code>): struct field initializer.  See <a href="structs.html">Structs</a>.</li>
<li><code>:</code> (<code>'a: loop {…}</code>): loop label.  See <a href="loops.html#loop-labels">Loops (Loops Labels)</a>.</li>
<li><code>;</code>: statement and item terminator.</li>
<li><code>;</code> (<code>[…; len]</code>): part of fixed-size array syntax.  See <a href="primitive-types.html#arrays">Primitive Types (Arrays)</a>.</li>
<li><code>&lt;&lt;</code> (<code>expr &lt;&lt; expr</code>): left-shift.  Overloadable (<code>Shl</code>).</li>
<li><code>&lt;&lt;=</code> (<code>var &lt;&lt;= expr</code>): left-shift &amp; assignment.</li>
<li><code>&lt;</code> (<code>expr &lt; expr</code>): less-than comparison.  Overloadable (<code>Cmp</code>, <code>PartialCmp</code>).</li>
<li><code>&lt;=</code> (<code>var &lt;= expr</code>): less-than or equal-to comparison.  Overloadable (<code>Cmp</code>, <code>PartialCmp</code>).</li>
<li><code>=</code> (<code>var = expr</code>, <code>ident = type</code>): assignment/equivalence.  See <a href="variable-bindings.html">Variable Bindings</a>, <a href="type-aliases.html"><code>type</code> Aliases</a>, generic parameter defaults.</li>
<li><code>==</code> (<code>var == expr</code>): comparison.  Overloadable (<code>Eq</code>, <code>PartialEq</code>).</li>
<li><code>=&gt;</code> (<code>pat =&gt; expr</code>): part of match arm syntax.  See <a href="match.html">Match</a>.</li>
<li><code>&gt;</code> (<code>expr &gt; expr</code>): greater-than comparison.  Overloadable (<code>Cmp</code>, <code>PartialCmp</code>).</li>
<li><code>&gt;=</code> (<code>var &gt;= expr</code>): greater-than or equal-to comparison.  Overloadable (<code>Cmp</code>, <code>PartialCmp</code>).</li>
<li><code>&gt;&gt;</code> (<code>expr &gt;&gt; expr</code>): right-shift.  Overloadable (<code>Shr</code>).</li>
<li><code>&gt;&gt;=</code> (<code>var &gt;&gt;= expr</code>): right-shift &amp; assignment.</li>
<li><code>@</code> (<code>ident @ pat</code>): pattern binding.  See <a href="patterns.html#bindings">Patterns (Bindings)</a>.</li>
<li><code>^</code> (<code>expr ^ expr</code>): bitwise exclusive or.  Overloadable (<code>BitXor</code>).</li>
<li><code>^=</code> (<code>var ^= expr</code>): bitwise exclusive or &amp; assignment.</li>
<li><code>|</code> (<code>expr | expr</code>): bitwise or.  Overloadable (<code>BitOr</code>).</li>
<li><code>|</code> (<code>pat | pat</code>): pattern alternatives.  See <a href="patterns.html#multiple-patterns">Patterns (Multiple patterns)</a>.</li>
<li><code>|</code> (<code>|…| expr</code>): closures.  See <a href="closures.html">Closures</a>.</li>
<li><code>|=</code> (<code>var |= expr</code>): bitwise or &amp; assignment.</li>
<li><code>||</code> (<code>expr || expr</code>): logical or.</li>
<li><code>_</code>: &quot;ignored&quot; pattern binding.  See <a href="patterns.html#ignoring-bindings">Patterns (Ignoring bindings)</a>.</li>
</ul>
<h2><a class="header" href="#other-syntax" id="other-syntax">Other Syntax</a></h2>
<!-- Various bits of standalone stuff. -->
<ul>
<li><code>'ident</code>: named lifetime or loop label.  See <a href="lifetimes.html">Lifetimes</a>, <a href="loops.html#loop-labels">Loops (Loops Labels)</a>.</li>
<li><code>…u8</code>, <code>…i32</code>, <code>…f64</code>, <code>…usize</code>, …: numeric literal of specific type.</li>
<li><code>&quot;…&quot;</code>: string literal.  See <a href="strings.html">Strings</a>.</li>
<li><code>r&quot;…&quot;</code>, <code>r#&quot;…&quot;#</code>, <code>r##&quot;…&quot;##</code>, …: raw string literal, escape characters are not processed. See <a href="../reference.html#raw-string-literals">Reference (Raw String Literals)</a>.</li>
<li><code>b&quot;…&quot;</code>: byte string literal, constructs a <code>[u8]</code> instead of a string. See <a href="../reference.html#byte-string-literals">Reference (Byte String Literals)</a>.</li>
<li><code>br&quot;…&quot;</code>, <code>br#&quot;…&quot;#</code>, <code>br##&quot;…&quot;##</code>, …: raw byte string literal, combination of raw and byte string literal. See <a href="../reference.html#raw-byte-string-literals">Reference (Raw Byte String Literals)</a>.</li>
<li><code>'…'</code>: character literal.  See <a href="primitive-types.html#char">Primitive Types (<code>char</code>)</a>.</li>
<li><code>b'…'</code>: ASCII byte literal.</li>
<li><code>|…| expr</code>: closure.  See <a href="closures.html">Closures</a>.</li>
</ul>
<!-- Path-related syntax -->
<ul>
<li><code>ident::ident</code>: path.  See <a href="crates-and-modules.html#defining-modules">Crates and Modules (Defining Modules)</a>.</li>
<li><code>::path</code>: path relative to the crate root (<em>i.e.</em> an explicitly absolute path).  See <a href="crates-and-modules.html#re-exporting-with-pub-use">Crates and Modules (Re-exporting with <code>pub use</code>)</a>.</li>
<li><code>self::path</code>: path relative to the current module (<em>i.e.</em> an explicitly relative path).  See <a href="crates-and-modules.html#re-exporting-with-pub-use">Crates and Modules (Re-exporting with <code>pub use</code>)</a>.</li>
<li><code>super::path</code>: path relative to the parent of the current module.  See <a href="crates-and-modules.html#re-exporting-with-pub-use">Crates and Modules (Re-exporting with <code>pub use</code>)</a>.</li>
<li><code>type::ident</code>: associated constants, functions, and types.  See <a href="associated-types.html">Associated Types</a>.</li>
<li><code>&lt;type&gt;::…</code>: associated item for a type which cannot be directly named (<em>e.g.</em> <code>&lt;&amp;T&gt;::…</code>, <code>&lt;[T]&gt;::…</code>, <em>etc.</em>).  See <a href="associated-types.html">Associated Types</a>.</li>
</ul>
<!-- Generics -->
<ul>
<li><code>path&lt;…&gt;</code> (<em>e.g.</em> <code>Vec&lt;u8&gt;</code>): specifies parameters to generic type <em>in a type</em>.  See <a href="generics.html">Generics</a>.</li>
<li><code>path::&lt;…&gt;</code>, <code>method::&lt;…&gt;</code> (<em>e.g.</em> <code>&quot;42&quot;.parse::&lt;i32&gt;()</code>): specifies parameters to generic type, function, or method <em>in an expression</em>.</li>
<li><code>fn ident&lt;…&gt; …</code>: define generic function.  See <a href="generics.html">Generics</a>.</li>
<li><code>struct ident&lt;…&gt; …</code>: define generic structure.  See <a href="generics.html">Generics</a>.</li>
<li><code>enum ident&lt;…&gt; …</code>: define generic enumeration.  See <a href="generics.html">Generics</a>.</li>
<li><code>impl&lt;…&gt; …</code>: define generic implementation.</li>
<li><code>for&lt;…&gt; type</code>: higher-ranked lifetime bounds.</li>
<li><code>type&lt;ident=type&gt;</code> (<em>e.g.</em> <code>Iterator&lt;Item=T&gt;</code>): a generic type where one or more associated types have specific assignments.  See <a href="associated-types.html">Associated Types</a>.</li>
</ul>
<!-- Constraints -->
<ul>
<li><code>T: U</code>: generic parameter <code>T</code> constrained to types that implement <code>U</code>.  See <a href="traits.html">Traits</a>.</li>
<li><code>T: 'a</code>: generic type <code>T</code> must outlive lifetime <code>'a</code>.</li>
<li><code>'b: 'a</code>: generic lifetime <code>'b</code> must outlive lifetime <code>'a</code>.</li>
<li><code>T: ?Sized</code>: allow generic type parameter to be a dynamically-sized type.  See <a href="unsized-types.html#?sized">Unsized Types (<code>?Sized</code>)</a>.</li>
<li><code>'a + trait</code>, <code>trait + trait</code>: compound type constraint.  See <a href="traits.html#multiple-trait-bounds">Traits (Multiple Trait Bounds)</a>.</li>
</ul>
<!-- Macros and attributes -->
<ul>
<li><code>#[meta]</code>: outer attribute.  See <a href="attributes.html">Attributes</a>.</li>
<li><code>#![meta]</code>: inner attribute.  See <a href="attributes.html">Attributes</a>.</li>
<li><code>$ident</code>: macro substitution.  See <a href="macros.html">Macros</a>.</li>
<li><code>$ident:kind</code>: macro capture.  See <a href="macros.html">Macros</a>.</li>
<li><code>$(…)…</code>: macro repetition.  See <a href="macros.html">Macros</a>.</li>
</ul>
<!-- Comments -->
<ul>
<li><code>//</code>: line comment.  See <a href="comments.html">Comments</a>.</li>
<li><code>//!</code>: inner line doc comment.  See <a href="comments.html">Comments</a>.</li>
<li><code>///</code>: outer line doc comment.  See <a href="comments.html">Comments</a>.</li>
<li><code>/*…*/</code>: block comment.  See <a href="comments.html">Comments</a>.</li>
<li><code>/*!…*/</code>: inner block doc comment.  See <a href="comments.html">Comments</a>.</li>
<li><code>/**…*/</code>: outer block doc comment.  See <a href="comments.html">Comments</a>.</li>
</ul>
<!-- Various things involving parens and tuples -->
<ul>
<li><code>()</code>: empty tuple (<em>a.k.a.</em> unit), both literal and type.</li>
<li><code>(expr)</code>: parenthesized expression.</li>
<li><code>(expr,)</code>: single-element tuple expression.  See <a href="primitive-types.html#tuples">Primitive Types (Tuples)</a>.</li>
<li><code>(type,)</code>: single-element tuple type.  See <a href="primitive-types.html#tuples">Primitive Types (Tuples)</a>.</li>
<li><code>(expr, …)</code>: tuple expression.  See <a href="primitive-types.html#tuples">Primitive Types (Tuples)</a>.</li>
<li><code>(type, …)</code>: tuple type.  See <a href="primitive-types.html#tuples">Primitive Types (Tuples)</a>.</li>
<li><code>expr(expr, …)</code>: function call expression.  Also used to initialize tuple <code>struct</code>s and tuple <code>enum</code> variants.  See <a href="functions.html">Functions</a>.</li>
<li><code>ident!(…)</code>, <code>ident!{…}</code>, <code>ident![…]</code>: macro invocation.  See <a href="macros.html">Macros</a>.</li>
<li><code>expr.0</code>, <code>expr.1</code>, …: tuple indexing.  See <a href="primitive-types.html#tuple-indexing">Primitive Types (Tuple Indexing)</a>.</li>
</ul>
<!-- Bracey things -->
<ul>
<li><code>{…}</code>: block expression.</li>
<li><code>Type {…}</code>: <code>struct</code> literal.  See <a href="structs.html">Structs</a>.</li>
</ul>
<!-- Brackety things -->
<ul>
<li><code>[…]</code>: array literal.  See <a href="primitive-types.html#arrays">Primitive Types (Arrays)</a>.</li>
<li><code>[expr; len]</code>: array literal containing <code>len</code> copies of <code>expr</code>.  See <a href="primitive-types.html#arrays">Primitive Types (Arrays)</a>.</li>
<li><code>[type; len]</code>: array type containing <code>len</code> instances of <code>type</code>.  See <a href="primitive-types.html#arrays">Primitive Types (Arrays)</a>.</li>
<li><code>expr[expr]</code>: collection indexing.  Overloadable (<code>Index</code>, <code>IndexMut</code>).</li>
<li><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code>: collection indexing pretending to be collection slicing, using <code>Range</code>, <code>RangeFrom</code>, <code>RangeTo</code>, <code>RangeFull</code> as the &quot;index&quot;.</li>
</ul>
<p>% Библиография</p>
<p>Это — список материалов, имеющих отношние к Rust. Он включает в себя
предварительные исследования, которые в тот или иной момент оказали влияние на
структуру Rust'а, а также публикации о Rust.</p>
<h3><a class="header" href="#Система-типов" id="Система-типов">Система типов</a></h3>
<ul>
<li><a href="http://209.68.42.137/ucsd-pages/Courses/cse227.w03/handouts/cyclone-regions.pdf">Region based memory management in Cyclone</a></li>
<li><a href="http://www.cs.umd.edu/projects/PL/cyclone/scp.pdf">Safe manual memory management in Cyclone</a></li>
<li><a href="http://www.ps.uni-sb.de/courses/typen-ws99/class.ps.gz">Typeclasses: making ad-hoc polymorphism less ad hoc</a></li>
<li><a href="https://www.cs.utah.edu/plt/publications/jfp12-draft-fcdf.pdf">Macros that work together</a></li>
<li><a href="http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf">Traits: composable units of behavior</a></li>
<li><a href="http://www.cs.uwm.edu/faculty/boyland/papers/unique-preprint.ps">Alias burying</a> - We tried something similar and abandoned it.</li>
<li><a href="http://www.cs.uu.nl/research/techreps/UU-CS-2002-048.html">External uniqueness is unique enough</a></li>
<li><a href="https://research.microsoft.com/pubs/170528/msr-tr-2012-79.pdf">Uniqueness and Reference Immutability for Safe Parallelism</a></li>
<li><a href="http://www.cs.ucla.edu/%7Epalsberg/tba/papers/tofte-talpin-iandc97.pdf">Region Based Memory Management</a></li>
</ul>
<h3><a class="header" href="#Многозадачность" id="Многозадачность">Многозадачность</a></h3>
<ul>
<li><a href="https://research.microsoft.com/pubs/69431/osr2007_rethinkingsoftwarestack.pdf">Singularity: rethinking the software stack</a></li>
<li><a href="https://research.microsoft.com/pubs/67482/singsharp.pdf">Language support for fast and reliable message passing in singularity OS</a></li>
<li><a href="http://supertech.csail.mit.edu/papers/steal.pdf">Scheduling multithreaded computations by work stealing</a></li>
<li><a href="http://www.eecis.udel.edu/%7Ecavazos/cisc879-spring2008/papers/arora98thread.pdf">Thread scheduling for multiprogramming multiprocessors</a></li>
<li><a href="http://www.aladdin.cs.cmu.edu/papers/pdfs/y2000/locality_spaa00.pdf">The data locality of work stealing</a></li>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.170.1097&amp;rep=rep1&amp;type=pdf">Dynamic circular work stealing deque</a> - The Chase/Lev deque</li>
<li><a href="http://www.cs.rice.edu/%7Eyguo/pubs/PID824943.pdf">Work-first and help-first scheduling policies for async-finish task parallelism</a> - More general than fully-strict work stealing</li>
<li><a href="http://www.coopsoft.com/ar/CalamityArticle.html">A Java fork/join calamity</a> - critique of Java's fork/join library, particularly its application of work stealing to non-strict computation</li>
<li><a href="http://www.stanford.edu/%7Eouster/cgi-bin/papers/coscheduling.pdf">Scheduling techniques for concurrent systems</a></li>
<li><a href="http://www.blagodurov.net/files/a8-blagodurov.pdf">Contention aware scheduling</a></li>
<li><a href="http://www.cse.ohio-state.edu/hpcs/WWW/HTML/publications/papers/TR-12-1.pdf">Balanced work stealing for time-sharing multicores</a></li>
<li><a href="http://dl.acm.org/citation.cfm?id=1953616&amp;dl=ACM&amp;coll=DL&amp;CFID=524387192&amp;CFTOKEN=44362705">Three layer cake for shared-memory programming</a></li>
<li><a href="http://www.cs.bgu.ac.il/%7Ehendlerd/papers/p280-hendler.pdf">Non-blocking steal-half work queues</a></li>
<li><a href="http://www.mpi-sws.org/%7Eturon/reagents.pdf">Reagents: expressing and composing fine-grained concurrency</a></li>
<li><a href="https://www.cs.rochester.edu/u/scott/papers/1991_TOCS_synch.pdf">Algorithms for scalable synchronization of shared-memory multiprocessors</a></li>
<li><a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.pdf">Epoch-based reclamation</a>.</li>
</ul>
<h3><a class="header" href="#Другое" id="Другое">Другое</a></h3>
<ul>
<li><a href="https://www.usenix.org/legacy/events/hotos03/tech/full_papers/candea/candea.pdf">Crash-only software</a></li>
<li><a href="http://people.cs.umass.edu/%7Eemery/pubs/berger-pldi2001.pdf">Composing High-Performance Memory Allocators</a></li>
<li><a href="http://people.cs.umass.edu/%7Eemery/pubs/berger-oopsla2002.pdf">Reconsidering Custom Memory Allocation</a></li>
</ul>
<h3><a class="header" href="#Статьи-о-rust" id="Статьи-о-rust">Статьи <em>о</em> Rust</a></h3>
<ul>
<li><a href="http://www.cs.indiana.edu/%7Eeholk/papers/hips2013.pdf">GPU Programming in Rust: Implementing High Level Abstractions in a
Systems Level
Language</a>. Early GPU work by Eric Holk.</li>
<li><a href="https://www.usenix.org/conference/hotpar12/parallel-closures-new-twist-old-idea">Parallel closures: a new twist on an old
idea</a>
<ul>
<li>not exactly about Rust, but by nmatsakis</li>
</ul>
</li>
<li><a href="ftp://ftp.cs.washington.edu/tr/2015/03/UW-CSE-15-03-02.pdf">Patina: A Formalization of the Rust Programming
Language</a>. Early
formalization of a subset of the type system, by Eric Reed.</li>
<li><a href="http://arxiv.org/abs/1505.07383">Experience Report: Developing the Servo Web Browser Engine using
Rust</a>. By Lars Bergstrom.</li>
<li><a href="https://michaelsproul.github.io/rust_radix_paper/rust-radix-sproul.pdf">Implementing a Generic Radix Trie in
Rust</a>. Undergrad
paper by Michael Sproul.</li>
<li><a href="http://scialex.github.io/reenix.pdf">Reenix: Implementing a Unix-Like Operating System in
Rust</a>. Undergrad paper by Alex
Light.</li>
<li>[Evaluation of performance and productivity metrics of potential
programming languages in the HPC environment]
(http://octarineparrot.com/assets/mrfloya-thesis-ba.pdf).
Bachelor's thesis by Florian Wilkens. Compares C, Go and Rust.</li>
<li><a href="http://spw15.langsec.org/papers/couprie-nom.pdf">Nom, a byte oriented, streaming, zero copy, parser combinators library
in Rust</a>. By
Geoffroy Couprie, research for VLC.</li>
<li><a href="http://compilers.cs.uni-saarland.de/papers/lkh15_cgo.pdf">Graph-Based Higher-Order Intermediate
Representation</a>. An
experimental IR implemented in Impala, a Rust-like language.</li>
<li><a href="http://compilers.cs.uni-saarland.de/papers/ppl14_web.pdf">Code Refinement of Stencil
Codes</a>. Another
paper using Impala.</li>
<li><a href="http://publications.lib.chalmers.se/records/fulltext/219016/219016.pdf">Parallelization in Rust with fork-join and
friends</a>. Linus
Farnstrand's master's thesis.</li>
<li><a href="http://munksgaard.me/papers/laumann-munksgaard-larsen.pdf">Session Types for
Rust</a>. Philip
Munksgaard's master's thesis. Research for Servo.</li>
<li><a href="http://amitlevy.com/papers/tock-plos2015.pdf">Ownership is Theft: Experiences Building an Embedded OS in Rust - Amit Levy, et. al.</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        
        <!-- Google Analytics Tag -->
        <script type="text/javascript">
            var localAddrs = ["localhost", "127.0.0.1", ""];

            // make sure we don't activate google analytics if the developer is
            // inspecting the book locally...
            if (localAddrs.indexOf(document.location.hostname) === -1) {
                (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
                m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
                })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

                ga('create', 'UA-142155799-10', 'auto');
                ga('send', 'pageview');
            }
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
